{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to DBMS Chapters Chapter 1: Introduction Chapter 2: Introduction to Relational Languages Chapter 3: Introduction to SQL Chapter 4: Intermediate SQL Chapter 5: Advanced SQL Sections 5.4 onwards may be omitted. Chapter 6: Entity-Relationship Model Chapter 7: Relational Database Design Chapter 8: Complex Data Types Chapter 9: Application Design Chapter 10: Big Data Chapter 11: Data Analytics Chapter 12: Physical Storage Systems Chapter 13: Storage and File Structure Chapter 14: Indexing Chapter 15: Query Processing Chapter 16: Query Optimization Chapter 17: Transactions Chapter 18: Concurrency Control Section 18.8 (Snapshot Isolation), Section 18.9 (Weak Levels of Consistency) may be omitted. Chapter 19: Recovery System Section 19.8 (ARIES) may be omitted. PostgreSQL Cheatsheet (Markdown) This cheatsheet summarizes some essential PostgreSQL commands for managing databases, users, tables, and data. Connection: psql -h <hostname> -p <port> -d <database> -U <username> : Connect to a PostgreSQL server (replace placeholders with actual values). Databases: CREATE DATABASE <database_name> : Create a new database. DROP DATABASE <database_name> : Delete an existing database (use with caution!). \\l : List all databases. \\connect <database_name> : Switch to a different database within the same session. Users and Roles: CREATE ROLE <username> [WITH PASSWORD '<password>'] : Create a new user. GRANT <privilege> ON <object> TO <username> : Grant specific privileges (e.g., SELECT, INSERT, UPDATE, DELETE) on a database object (table, schema) to a user. REVOKE <privilege> ON <object> FROM <username> : Revoke privileges from a user. \\du : List all roles (users). Tables: CREATE TABLE <table_name> ( <column_name> <data_type> [CONSTRAINT], ...); : Create a new table with columns and constraints. DESCRIBE <table_name> : Show the structure of a table. DROP TABLE <table_name> : Delete a table (use with caution!). \\dt : List all tables in the current schema. Data Manipulation: INSERT INTO <table_name> (<column1>, <column2>, ...) VALUES (<value1>, <value2>, ...); : Insert data into a table. SELECT * FROM <table_name> [WHERE <condition>]; : Retrieve data from a table (all columns by default, with optional filtering). UPDATE <table_name> SET <column_name> = <new_value> [WHERE <condition>]; : Update existing data in a table. DELETE FROM <table_name> [WHERE <condition>]; : Delete rows from a table. Other Useful Commands: \\q : Quit the psql client. \\h : Get help on a specific command (e.g., \\h CREATE TABLE ). \\conninfo : Display connection information. Additional Notes: Remember to replace placeholders like <database_name> , <username> , etc. with actual values. This is a basic cheatsheet. PostgreSQL offers many more commands and functionalities. Refer to the official documentation for in-depth details: https://www.postgresql.org/docs/","title":"Welcome to DBMS"},{"location":"#welcome-to-dbms","text":"","title":"Welcome to DBMS"},{"location":"#chapters","text":"Chapter 1: Introduction Chapter 2: Introduction to Relational Languages Chapter 3: Introduction to SQL Chapter 4: Intermediate SQL Chapter 5: Advanced SQL Sections 5.4 onwards may be omitted. Chapter 6: Entity-Relationship Model Chapter 7: Relational Database Design Chapter 8: Complex Data Types Chapter 9: Application Design Chapter 10: Big Data Chapter 11: Data Analytics Chapter 12: Physical Storage Systems Chapter 13: Storage and File Structure Chapter 14: Indexing Chapter 15: Query Processing Chapter 16: Query Optimization Chapter 17: Transactions Chapter 18: Concurrency Control Section 18.8 (Snapshot Isolation), Section 18.9 (Weak Levels of Consistency) may be omitted. Chapter 19: Recovery System Section 19.8 (ARIES) may be omitted.","title":"Chapters"},{"location":"#postgresql-cheatsheet-markdown","text":"This cheatsheet summarizes some essential PostgreSQL commands for managing databases, users, tables, and data. Connection: psql -h <hostname> -p <port> -d <database> -U <username> : Connect to a PostgreSQL server (replace placeholders with actual values). Databases: CREATE DATABASE <database_name> : Create a new database. DROP DATABASE <database_name> : Delete an existing database (use with caution!). \\l : List all databases. \\connect <database_name> : Switch to a different database within the same session. Users and Roles: CREATE ROLE <username> [WITH PASSWORD '<password>'] : Create a new user. GRANT <privilege> ON <object> TO <username> : Grant specific privileges (e.g., SELECT, INSERT, UPDATE, DELETE) on a database object (table, schema) to a user. REVOKE <privilege> ON <object> FROM <username> : Revoke privileges from a user. \\du : List all roles (users). Tables: CREATE TABLE <table_name> ( <column_name> <data_type> [CONSTRAINT], ...); : Create a new table with columns and constraints. DESCRIBE <table_name> : Show the structure of a table. DROP TABLE <table_name> : Delete a table (use with caution!). \\dt : List all tables in the current schema. Data Manipulation: INSERT INTO <table_name> (<column1>, <column2>, ...) VALUES (<value1>, <value2>, ...); : Insert data into a table. SELECT * FROM <table_name> [WHERE <condition>]; : Retrieve data from a table (all columns by default, with optional filtering). UPDATE <table_name> SET <column_name> = <new_value> [WHERE <condition>]; : Update existing data in a table. DELETE FROM <table_name> [WHERE <condition>]; : Delete rows from a table. Other Useful Commands: \\q : Quit the psql client. \\h : Get help on a specific command (e.g., \\h CREATE TABLE ). \\conninfo : Display connection information. Additional Notes: Remember to replace placeholders like <database_name> , <username> , etc. with actual values. This is a basic cheatsheet. PostgreSQL offers many more commands and functionalities. Refer to the official documentation for in-depth details: https://www.postgresql.org/docs/","title":"PostgreSQL Cheatsheet (Markdown)"},{"location":"cheatsheet/","text":"PSQL Magic words: psql -U postgres Some interesting flags (to see all, use -h or --help depending on your psql version): -E : will describe the underlaying queries of the \\ commands (cool for learning!) -l : psql will list all databases and then exit (useful if the user you connect with doesn't has a default database, like at AWS RDS) Most \\d commands support additional param of __schema__.name__ and accept wildcards like *.* \\? : Show help (list of available commands with an explanation) \\q : Quit/Exit \\c __database__ : Connect to a database \\d __table__ : Show table definition (columns, etc.) including triggers \\d+ __table__ : More detailed table definition including description and physical disk size \\l : List databases \\dy : List events \\df : List functions \\di : List indexes \\dn : List schemas \\dt *.* : List tables from all schemas (if *.* is omitted will only show SEARCH_PATH ones) \\dT+ : List all data types \\dv : List views \\dx : List all extensions installed \\df+ __function__ : Show function SQL code. \\x : Pretty-format query results instead of the not-so-useful ASCII tables \\copy (SELECT * FROM __table_name__) TO 'file_path_and_name.csv' WITH CSV : Export a table as CSV \\des+ : List all foreign servers \\dE[S+] : List all foreign tables \\! __bash_command__ : execute __bash_command__ (e.g. \\! ls ) User Related: \\du : List users \\du __username__ : List a username if present. create role __test1__ : Create a role with an existing username. create role __test2__ noinherit login password __passsword__; : Create a role with username and password. set role __test__; : Change role for current session to __test__ . grant __test2__ to __test1__; : Allow __test1__ to set its role as __test2__ . \\deu+ : List all user mapping on server Create command There are many CREATE choices, like CREATE DATABASE __database_name__ , CREATE TABLE __table_name__ ... Parameters differ but can be checked at the official documentation . Handy queries SELECT * FROM pg_proc WHERE proname='__procedurename__' : List procedure/function SELECT * FROM pg_views WHERE viewname='__viewname__'; : List view (including the definition) SELECT pg_size_pretty(pg_total_relation_size('__table_name__')); : Show DB table space in use SELECT pg_size_pretty(pg_database_size('__database_name__')); : Show DB space in use show statement_timeout; : Show current user's statement timeout SELECT * FROM pg_indexes WHERE tablename='__table_name__' AND schemaname='__schema_name__'; : Show table indexes Get all indexes from all tables of a schema: SELECT t . relname AS table_name , i . relname AS index_name , a . attname AS column_name FROM pg_class t , pg_class i , pg_index ix , pg_attribute a , pg_namespace n WHERE t . oid = ix . indrelid AND i . oid = ix . indexrelid AND a . attrelid = t . oid AND a . attnum = ANY ( ix . indkey ) AND t . relnamespace = n . oid AND n . nspname = 'kartones' ORDER BY t . relname , i . relname Execution data: Queries being executed at a certain DB: SELECT datname , application_name , pid , backend_start , query_start , state_change , state , query FROM pg_stat_activity WHERE datname = '__database_name__' ; Get all queries from all dbs waiting for data (might be hung): SELECT * FROM pg_stat_activity WHERE waiting = 't' Currently running queries with process pid: SELECT pg_stat_get_backend_pid ( s . backendid ) AS procpid , pg_stat_get_backend_activity ( s . backendid ) AS current_query FROM ( SELECT pg_stat_get_backend_idset () AS backendid ) AS s ; Get Connections by Database: SELECT datname, numbackends FROM pg_stat_database; Casting: CAST (column AS type) or column::type '__table_name__'::regclass::oid : Get oid having a table name Query analysis: EXPLAIN __query__ : see the query plan for the given query EXPLAIN ANALYZE __query__ : see and execute the query plan for the given query ANALYZE [__table__] : collect statistics Generating random data ( source ): INSERT INTO some_table (a_float_value) SELECT random() * 100000 FROM generate_series(1, 1000000) i; Get sizes of tables, indexes and full DBs: select current_database () as database , pg_size_pretty ( total_database_size ) as total_database_size , schema_name , table_name , pg_size_pretty ( total_table_size ) as total_table_size , pg_size_pretty ( table_size ) as table_size , pg_size_pretty ( index_size ) as index_size from ( select table_name , table_schema as schema_name , pg_database_size ( current_database ()) as total_database_size , pg_total_relation_size ( table_name ) as total_table_size , pg_relation_size ( table_name ) as table_size , pg_indexes_size ( table_name ) as index_size from information_schema . tables where table_schema = current_schema () and table_name like 'table_%' order by total_table_size ) as sizes ; COPY command : Import/export from CSV to tables: COPY table_name [ ( column_name [, ...] ) ] FROM { 'filename' | STDIN } [ [ WITH ] ( option [, ...] ) ] COPY { table_name [ ( column_name [, ...] ) ] | ( query ) } TO { 'filename' | STDOUT } [ [ WITH ] ( option [, ...] ) ] List all grants for a specific user SELECT table_catalog , table_schema , table_name , privilege_type FROM information_schema . table_privileges WHERE grantee = 'user_to_check' ORDER BY table_name ; List all assigned user roles SELECT r . rolname , r . rolsuper , r . rolinherit , r . rolcreaterole , r . rolcreatedb , r . rolcanlogin , r . rolconnlimit , r . rolvaliduntil , ARRAY ( SELECT b . rolname FROM pg_catalog . pg_auth_members m JOIN pg_catalog . pg_roles b ON ( m . roleid = b . oid ) WHERE m . member = r . oid ) as memberof , r . rolreplication FROM pg_catalog . pg_roles r ORDER BY 1 ; Check permissions in a table: SELECT grantee , privilege_type FROM information_schema . role_table_grants WHERE table_name = 'name-of-the-table' ; Kill all Connections: SELECT pg_terminate_backend ( pg_stat_activity . pid ) FROM pg_stat_activity WHERE datname = current_database () AND pid <> pg_backend_pid (); Keyboard shortcuts CTRL + R : reverse-i-search Tools ptop and pg_top : top for PG. Available on the APT repository from apt.postgresql.org . pg_activity : Command line tool for PostgreSQL server activity monitoring. Unix-like reverse search in psql : $ echo \"bind \" ^R \" em-inc-search-prev\" > $HOME /.editrc $ source $HOME /.editrc Show IP of the DB Instance: SELECT inet_server_addr(); File to save PostgreSQL credentials and permissions (format: hostname:port:database:username:password ): chmod 600 ~/.pgpass Collect statistics of a database (useful to improve speed after a Database Upgrade as previous query plans are deleted): ANALYZE VERBOSE; To obtain the CREATE TABLE query of a table, any visual GUI like pgAdmin allows to easily, but else you can use pg_dump , e.g.: pg_dump -t '<schema>.<table>' --schema-only <database> ( source ) Resources & Documentation Operations Cheat Sheet : Official PG wiki cheat sheet with an amazing amount of explanations of many topics, features, and many many internal implementation details Postgres Weekly newsletter: The best way IMHO to keep up to date with PG news 100 psql Tips : Name says all, lots of useful tips! PostgreSQL Exercises : An awesome resource to learn to learn SQL, teaching you with simple examples in a great visual way. Highly recommended . A Performance Cheat Sheet for PostgreSQL : Great explanations of EXPLAIN , EXPLAIN ANALYZE , VACUUM , configuration parameters and more. Quite interesting if you need to tune-up a postgres setup. annotated.conf : Annotations of all 269 postgresql.conf settings for PostgreSQL 10. psql -c \"\\l+\" -H -q postgres > out.html : Generate a html report of your databases (source: Daniel Westermann ) </pre>","title":"Cheatsheet"},{"location":"cheatsheet/#psql","text":"Magic words: psql -U postgres Some interesting flags (to see all, use -h or --help depending on your psql version): -E : will describe the underlaying queries of the \\ commands (cool for learning!) -l : psql will list all databases and then exit (useful if the user you connect with doesn't has a default database, like at AWS RDS) Most \\d commands support additional param of __schema__.name__ and accept wildcards like *.* \\? : Show help (list of available commands with an explanation) \\q : Quit/Exit \\c __database__ : Connect to a database \\d __table__ : Show table definition (columns, etc.) including triggers \\d+ __table__ : More detailed table definition including description and physical disk size \\l : List databases \\dy : List events \\df : List functions \\di : List indexes \\dn : List schemas \\dt *.* : List tables from all schemas (if *.* is omitted will only show SEARCH_PATH ones) \\dT+ : List all data types \\dv : List views \\dx : List all extensions installed \\df+ __function__ : Show function SQL code. \\x : Pretty-format query results instead of the not-so-useful ASCII tables \\copy (SELECT * FROM __table_name__) TO 'file_path_and_name.csv' WITH CSV : Export a table as CSV \\des+ : List all foreign servers \\dE[S+] : List all foreign tables \\! __bash_command__ : execute __bash_command__ (e.g. \\! ls ) User Related: \\du : List users \\du __username__ : List a username if present. create role __test1__ : Create a role with an existing username. create role __test2__ noinherit login password __passsword__; : Create a role with username and password. set role __test__; : Change role for current session to __test__ . grant __test2__ to __test1__; : Allow __test1__ to set its role as __test2__ . \\deu+ : List all user mapping on server","title":"PSQL"},{"location":"cheatsheet/#create-command","text":"There are many CREATE choices, like CREATE DATABASE __database_name__ , CREATE TABLE __table_name__ ... Parameters differ but can be checked at the official documentation .","title":"Create command"},{"location":"cheatsheet/#handy-queries","text":"SELECT * FROM pg_proc WHERE proname='__procedurename__' : List procedure/function SELECT * FROM pg_views WHERE viewname='__viewname__'; : List view (including the definition) SELECT pg_size_pretty(pg_total_relation_size('__table_name__')); : Show DB table space in use SELECT pg_size_pretty(pg_database_size('__database_name__')); : Show DB space in use show statement_timeout; : Show current user's statement timeout SELECT * FROM pg_indexes WHERE tablename='__table_name__' AND schemaname='__schema_name__'; : Show table indexes Get all indexes from all tables of a schema: SELECT t . relname AS table_name , i . relname AS index_name , a . attname AS column_name FROM pg_class t , pg_class i , pg_index ix , pg_attribute a , pg_namespace n WHERE t . oid = ix . indrelid AND i . oid = ix . indexrelid AND a . attrelid = t . oid AND a . attnum = ANY ( ix . indkey ) AND t . relnamespace = n . oid AND n . nspname = 'kartones' ORDER BY t . relname , i . relname Execution data: Queries being executed at a certain DB: SELECT datname , application_name , pid , backend_start , query_start , state_change , state , query FROM pg_stat_activity WHERE datname = '__database_name__' ; Get all queries from all dbs waiting for data (might be hung): SELECT * FROM pg_stat_activity WHERE waiting = 't' Currently running queries with process pid: SELECT pg_stat_get_backend_pid ( s . backendid ) AS procpid , pg_stat_get_backend_activity ( s . backendid ) AS current_query FROM ( SELECT pg_stat_get_backend_idset () AS backendid ) AS s ; Get Connections by Database: SELECT datname, numbackends FROM pg_stat_database; Casting: CAST (column AS type) or column::type '__table_name__'::regclass::oid : Get oid having a table name Query analysis: EXPLAIN __query__ : see the query plan for the given query EXPLAIN ANALYZE __query__ : see and execute the query plan for the given query ANALYZE [__table__] : collect statistics Generating random data ( source ): INSERT INTO some_table (a_float_value) SELECT random() * 100000 FROM generate_series(1, 1000000) i; Get sizes of tables, indexes and full DBs: select current_database () as database , pg_size_pretty ( total_database_size ) as total_database_size , schema_name , table_name , pg_size_pretty ( total_table_size ) as total_table_size , pg_size_pretty ( table_size ) as table_size , pg_size_pretty ( index_size ) as index_size from ( select table_name , table_schema as schema_name , pg_database_size ( current_database ()) as total_database_size , pg_total_relation_size ( table_name ) as total_table_size , pg_relation_size ( table_name ) as table_size , pg_indexes_size ( table_name ) as index_size from information_schema . tables where table_schema = current_schema () and table_name like 'table_%' order by total_table_size ) as sizes ; COPY command : Import/export from CSV to tables: COPY table_name [ ( column_name [, ...] ) ] FROM { 'filename' | STDIN } [ [ WITH ] ( option [, ...] ) ] COPY { table_name [ ( column_name [, ...] ) ] | ( query ) } TO { 'filename' | STDOUT } [ [ WITH ] ( option [, ...] ) ] List all grants for a specific user SELECT table_catalog , table_schema , table_name , privilege_type FROM information_schema . table_privileges WHERE grantee = 'user_to_check' ORDER BY table_name ; List all assigned user roles SELECT r . rolname , r . rolsuper , r . rolinherit , r . rolcreaterole , r . rolcreatedb , r . rolcanlogin , r . rolconnlimit , r . rolvaliduntil , ARRAY ( SELECT b . rolname FROM pg_catalog . pg_auth_members m JOIN pg_catalog . pg_roles b ON ( m . roleid = b . oid ) WHERE m . member = r . oid ) as memberof , r . rolreplication FROM pg_catalog . pg_roles r ORDER BY 1 ; Check permissions in a table: SELECT grantee , privilege_type FROM information_schema . role_table_grants WHERE table_name = 'name-of-the-table' ; Kill all Connections: SELECT pg_terminate_backend ( pg_stat_activity . pid ) FROM pg_stat_activity WHERE datname = current_database () AND pid <> pg_backend_pid ();","title":"Handy queries"},{"location":"cheatsheet/#keyboard-shortcuts","text":"CTRL + R : reverse-i-search","title":"Keyboard shortcuts"},{"location":"cheatsheet/#tools","text":"ptop and pg_top : top for PG. Available on the APT repository from apt.postgresql.org . pg_activity : Command line tool for PostgreSQL server activity monitoring. Unix-like reverse search in psql : $ echo \"bind \" ^R \" em-inc-search-prev\" > $HOME /.editrc $ source $HOME /.editrc Show IP of the DB Instance: SELECT inet_server_addr(); File to save PostgreSQL credentials and permissions (format: hostname:port:database:username:password ): chmod 600 ~/.pgpass Collect statistics of a database (useful to improve speed after a Database Upgrade as previous query plans are deleted): ANALYZE VERBOSE; To obtain the CREATE TABLE query of a table, any visual GUI like pgAdmin allows to easily, but else you can use pg_dump , e.g.: pg_dump -t '<schema>.<table>' --schema-only <database> ( source )","title":"Tools"},{"location":"cheatsheet/#resources-documentation","text":"Operations Cheat Sheet : Official PG wiki cheat sheet with an amazing amount of explanations of many topics, features, and many many internal implementation details Postgres Weekly newsletter: The best way IMHO to keep up to date with PG news 100 psql Tips : Name says all, lots of useful tips! PostgreSQL Exercises : An awesome resource to learn to learn SQL, teaching you with simple examples in a great visual way. Highly recommended . A Performance Cheat Sheet for PostgreSQL : Great explanations of EXPLAIN , EXPLAIN ANALYZE , VACUUM , configuration parameters and more. Quite interesting if you need to tune-up a postgres setup. annotated.conf : Annotations of all 269 postgresql.conf settings for PostgreSQL 10. psql -c \"\\l+\" -H -q postgres > out.html : Generate a html report of your databases (source: Daniel Westermann ) </pre>","title":"Resources &amp; Documentation"},{"location":"Week%205/Lecture%205.1%20-%20Relational%20Database%20Design1/","text":"Lecture 5.1 - Relational Database Design1 Summary This module focuses on principles of relational database design. It emphasizes: Features of Good Design: Reflects real-world structure Accommodates future data additions Avoids redundancy Provides efficient data access Maintains data integrity Redundancy and Anomaly: Redundancy (duplicate data) leads to anomalies: Insertion: Can't add data if unknown data is required Deletion: Losing unrelated information when deleting records Update: Inaccurate changes due to multiple occurrences of data Decomposition: Decomposing relations into smaller ones removes redundancy and minimizes dependencies among attributes. Good decomposition ensures data preservation and integrity. functional dependency : dept name \u2192 building, budget In inst_dept, because dept_name is not a candidate key, the building and budget of a department may have to be repeated. \u25e6 This indicates the need to decompose inst dept Lossy Decomposition Lossless Join Decomposition is a decomposition of a relation R into relations R1 , R2 such that if we perform natural join of two smaller relations it will return the original relation Atomic Domains and First Normal Form (1NF): Atomic domains consist of indivisible elements. 1NF requires relations with atomic domains and each attribute holding a single value. Non-atomic values complicate storage and encourage redundancy. Atomic Domains An atomic domain refers to the indivisibility of data within a domain. In the context of databases, it means that the value in a particular field is indivisible and represents the smallest unit of data. Each attribute in a table should contain atomic (indivisible) values. Example of Atomic Values : 123 Main St , John Doe , 01/01/2020 Example of Non-Atomic Values : 123 Main St, Apt 4 (multiple pieces of information in one field) John and Jane Doe (multiple names in one field) First Normal Form (1NF) A relation (table) is said to be in the First Normal Form (1NF) if it satisfies the following conditions: Atomicity : All the values in the database are atomic (indivisible). Uniqueness of Rows : Each row in the table must be unique, meaning no two rows can be identical. Uniqueness of Column Names : Each column should have a unique name. No Repeating Groups : Each table should contain only one value per cell (intersection of a row and a column), and columns should not contain sets or lists of values. Examples of 1NF Non-1NF Table: StudentID Name Courses 1 John Doe Math, Science 2 Jane Smith English, History, Math In the above table: The Courses column contains multiple values, which violates the atomicity rule. 1NF Table: StudentID Name Course 1 John Doe Math 1 John Doe Science 2 Jane Smith English 2 Jane Smith History 2 Jane Smith Math In this 1NF table: Each cell contains only one value, adhering to the atomicity requirement. Each row is unique, and there are no repeating groups within any cell. Achieving 1NF To transform a table into 1NF: Remove Repeating Groups : Ensure that each column contains only a single value. Create Separate Tables for Multivalued Attributes : If necessary, split the multivalued attributes into separate rows or tables. Ensure Primary Keys : Define primary keys to uniquely identify each row in the table. By adhering to these principles, a database can be designed to comply with the First Normal Form, thus ensuring data integrity and facilitating easier querying and maintenance.","title":"Lecture 5.1 - Relational Database Design1"},{"location":"Week%205/Lecture%205.1%20-%20Relational%20Database%20Design1/#lecture-51-relational-database-design1","text":"Summary This module focuses on principles of relational database design. It emphasizes: Features of Good Design: Reflects real-world structure Accommodates future data additions Avoids redundancy Provides efficient data access Maintains data integrity Redundancy and Anomaly: Redundancy (duplicate data) leads to anomalies: Insertion: Can't add data if unknown data is required Deletion: Losing unrelated information when deleting records Update: Inaccurate changes due to multiple occurrences of data Decomposition: Decomposing relations into smaller ones removes redundancy and minimizes dependencies among attributes. Good decomposition ensures data preservation and integrity. functional dependency : dept name \u2192 building, budget In inst_dept, because dept_name is not a candidate key, the building and budget of a department may have to be repeated. \u25e6 This indicates the need to decompose inst dept Lossy Decomposition Lossless Join Decomposition is a decomposition of a relation R into relations R1 , R2 such that if we perform natural join of two smaller relations it will return the original relation Atomic Domains and First Normal Form (1NF): Atomic domains consist of indivisible elements. 1NF requires relations with atomic domains and each attribute holding a single value. Non-atomic values complicate storage and encourage redundancy. Atomic Domains An atomic domain refers to the indivisibility of data within a domain. In the context of databases, it means that the value in a particular field is indivisible and represents the smallest unit of data. Each attribute in a table should contain atomic (indivisible) values. Example of Atomic Values : 123 Main St , John Doe , 01/01/2020 Example of Non-Atomic Values : 123 Main St, Apt 4 (multiple pieces of information in one field) John and Jane Doe (multiple names in one field)","title":"Lecture 5.1 - Relational Database Design1"},{"location":"Week%205/Lecture%205.1%20-%20Relational%20Database%20Design1/#first-normal-form-1nf","text":"A relation (table) is said to be in the First Normal Form (1NF) if it satisfies the following conditions: Atomicity : All the values in the database are atomic (indivisible). Uniqueness of Rows : Each row in the table must be unique, meaning no two rows can be identical. Uniqueness of Column Names : Each column should have a unique name. No Repeating Groups : Each table should contain only one value per cell (intersection of a row and a column), and columns should not contain sets or lists of values.","title":"First Normal Form (1NF)"},{"location":"Week%205/Lecture%205.1%20-%20Relational%20Database%20Design1/#examples-of-1nf","text":"Non-1NF Table: StudentID Name Courses 1 John Doe Math, Science 2 Jane Smith English, History, Math In the above table: The Courses column contains multiple values, which violates the atomicity rule. 1NF Table: StudentID Name Course 1 John Doe Math 1 John Doe Science 2 Jane Smith English 2 Jane Smith History 2 Jane Smith Math In this 1NF table: Each cell contains only one value, adhering to the atomicity requirement. Each row is unique, and there are no repeating groups within any cell.","title":"Examples of 1NF"},{"location":"Week%205/Lecture%205.1%20-%20Relational%20Database%20Design1/#achieving-1nf","text":"To transform a table into 1NF: Remove Repeating Groups : Ensure that each column contains only a single value. Create Separate Tables for Multivalued Attributes : If necessary, split the multivalued attributes into separate rows or tables. Ensure Primary Keys : Define primary keys to uniquely identify each row in the table. By adhering to these principles, a database can be designed to comply with the First Normal Form, thus ensuring data integrity and facilitating easier querying and maintenance.","title":"Achieving 1NF"},{"location":"Week%205/Lecture%205.2%20-%20Relational%20Database%20Design2/","text":"Lecture 5.2: Relational Database Design Functional Dependencies Definition Constraints on the set of legal relations. Require that the value for a certain set of attributes determines uniquely the value for another set of attributes. A generalization of the notion of a key. Formal Definition For a relation schema \\( R \\) , \\( $\\alpha \\subseteq R$ \\) and \\( $\\beta \\subseteq R $\\) . The functional dependency ( $\\alpha \\to \\beta $) holds on \\( R \\) if for any legal relations \\( r(R) \\) , whenever any two tuples \\( $t_1$ \\) and \\( $t_2$ \\) of \\( $r$ \\) agree on the attributes \\( $ \\alpha $ \\) , they also agree on the attributes \\( $\\beta$ \\) . Example: \\( $A \\to B$ \\) does not hold, but \\( $B \\to A$ \\) holds for a certain instance. Keys Superkey: \\( $K$ \\) is a superkey for relation schema \\( $R$ \\) if and only if ($ K \\to R \\ $). Candidate Key: \\( K \\) is a candidate key for \\( R \\) if and only if \\( $K \\to R$ \\) and for no \\($\\alpha \\subset K $\\) , \\( $\\alpha \\to R $\\) . Practical Examples Schema: inst_dept(ID, name, salary, dept_name, building, budget) Expected FDs: dept_name \u2192 building dept_name \u2192 budget ID \u2192 budget Unexpected FD: dept_name \u2192 salary Trivial Functional Dependencies A functional dependency is trivial if it is satisfied by all instances of a relation. Example: \\( $\\text{ID, name} \\to \\text{ID} $\\) and \\( $\\text{name} \\to \\text{name} $\\) . Generally, \\( $\\alpha \\to \\beta $ \\) is trivial if \\( $\\beta \\subseteq \\alpha $\\) . Armstrong\u2019s Axioms Definition Given a set of FDs \\( F \\) , infer new dependencies using: Reflexivity: If \\( $\\beta \\subseteq \\alpha$ \\) , then \\( \\alpha \\to \\beta \\) . Augmentation: If \\( $\\alpha \\to \\beta $ \\) , then \\( $\\gamma\\alpha \\to \\gamma\\beta $\\) . Transitivity: If \\( $\\alpha \\to \\beta $\\) and \\( $\\beta \\to \\gamma $\\) , then \\( $\\alpha \\to \\gamma $\\) . Closure The closure of a set of FDs \\( $F$ \\) is the set \\( $F^+ $\\) of all FDs logically implied by \\( F \\) . Example: \\( $F = \\{ A \\to B, B \\to C \\}$ \\) \\( $F^+ = \\{ A \\to B, B \\to C, A \\to C \\} $\\) Properties Axioms are sound (generate only FDs that hold) and complete (generate all FDs that hold). Module Summary Introduced the notion of Functional Dependencies. Explained Armstrong\u2019s Axioms and their application to infer new FDs. Discussed the concept of the closure of a set of FDs.","title":"Lecture 5.2: Relational Database Design"},{"location":"Week%205/Lecture%205.2%20-%20Relational%20Database%20Design2/#lecture-52-relational-database-design","text":"","title":"Lecture 5.2: Relational Database Design"},{"location":"Week%205/Lecture%205.2%20-%20Relational%20Database%20Design2/#functional-dependencies","text":"","title":"Functional Dependencies"},{"location":"Week%205/Lecture%205.2%20-%20Relational%20Database%20Design2/#definition","text":"Constraints on the set of legal relations. Require that the value for a certain set of attributes determines uniquely the value for another set of attributes. A generalization of the notion of a key.","title":"Definition"},{"location":"Week%205/Lecture%205.2%20-%20Relational%20Database%20Design2/#formal-definition","text":"For a relation schema \\( R \\) , \\( $\\alpha \\subseteq R$ \\) and \\( $\\beta \\subseteq R $\\) . The functional dependency ( $\\alpha \\to \\beta $) holds on \\( R \\) if for any legal relations \\( r(R) \\) , whenever any two tuples \\( $t_1$ \\) and \\( $t_2$ \\) of \\( $r$ \\) agree on the attributes \\( $ \\alpha $ \\) , they also agree on the attributes \\( $\\beta$ \\) . Example: \\( $A \\to B$ \\) does not hold, but \\( $B \\to A$ \\) holds for a certain instance.","title":"Formal Definition"},{"location":"Week%205/Lecture%205.2%20-%20Relational%20Database%20Design2/#keys","text":"Superkey: \\( $K$ \\) is a superkey for relation schema \\( $R$ \\) if and only if ($ K \\to R \\ $). Candidate Key: \\( K \\) is a candidate key for \\( R \\) if and only if \\( $K \\to R$ \\) and for no \\($\\alpha \\subset K $\\) , \\( $\\alpha \\to R $\\) .","title":"Keys"},{"location":"Week%205/Lecture%205.2%20-%20Relational%20Database%20Design2/#practical-examples","text":"Schema: inst_dept(ID, name, salary, dept_name, building, budget) Expected FDs: dept_name \u2192 building dept_name \u2192 budget ID \u2192 budget Unexpected FD: dept_name \u2192 salary","title":"Practical Examples"},{"location":"Week%205/Lecture%205.2%20-%20Relational%20Database%20Design2/#trivial-functional-dependencies","text":"A functional dependency is trivial if it is satisfied by all instances of a relation. Example: \\( $\\text{ID, name} \\to \\text{ID} $\\) and \\( $\\text{name} \\to \\text{name} $\\) . Generally, \\( $\\alpha \\to \\beta $ \\) is trivial if \\( $\\beta \\subseteq \\alpha $\\) .","title":"Trivial Functional Dependencies"},{"location":"Week%205/Lecture%205.2%20-%20Relational%20Database%20Design2/#armstrongs-axioms","text":"","title":"Armstrong\u2019s Axioms"},{"location":"Week%205/Lecture%205.2%20-%20Relational%20Database%20Design2/#definition_1","text":"Given a set of FDs \\( F \\) , infer new dependencies using: Reflexivity: If \\( $\\beta \\subseteq \\alpha$ \\) , then \\( \\alpha \\to \\beta \\) . Augmentation: If \\( $\\alpha \\to \\beta $ \\) , then \\( $\\gamma\\alpha \\to \\gamma\\beta $\\) . Transitivity: If \\( $\\alpha \\to \\beta $\\) and \\( $\\beta \\to \\gamma $\\) , then \\( $\\alpha \\to \\gamma $\\) .","title":"Definition"},{"location":"Week%205/Lecture%205.2%20-%20Relational%20Database%20Design2/#closure","text":"The closure of a set of FDs \\( $F$ \\) is the set \\( $F^+ $\\) of all FDs logically implied by \\( F \\) . Example: \\( $F = \\{ A \\to B, B \\to C \\}$ \\) \\( $F^+ = \\{ A \\to B, B \\to C, A \\to C \\} $\\)","title":"Closure"},{"location":"Week%205/Lecture%205.2%20-%20Relational%20Database%20Design2/#properties","text":"Axioms are sound (generate only FDs that hold) and complete (generate all FDs that hold).","title":"Properties"},{"location":"Week%205/Lecture%205.2%20-%20Relational%20Database%20Design2/#module-summary","text":"Introduced the notion of Functional Dependencies. Explained Armstrong\u2019s Axioms and their application to infer new FDs. Discussed the concept of the closure of a set of FDs.","title":"Module Summary"},{"location":"Week%205/Lecture%205.3%20-%20Relational%20Database%20Design3/","text":"Lecture 5.3 - Relational Database Design 3 Summary This module discusses relational database design using functional dependencies (FDs). FD Theory: Armstrong's Axioms are used to derive new FDs from a given set. Closure of FDs generates all FDs logically implied by a set. Closure of attributes determines the attributes functionally determined by a set of attributes. Decomposition Using FDs: Boyce-Codd Normal Form (BCNF) ensures that non-trivial FDs involve superkeys or attributes in candidate keys. Decomposing relations into BCNF guarantees lossless join but may not preserve dependencies. 3NF (Third Normal Form): Relaxes BCNF by allowing attributes in candidate keys but enforces dependency preservation. Normalization Goals: Evaluate relation schemes for \"good\" form. Decompose schemes into lossless-join and dependency-preserving relations. Problems with Decomposition: Potential lossiness, dependency checking issues, and query performance concerns exist. Limitations of BCNF: BCNF may not prevent insertion anomalies in certain scenarios, suggesting the need for higher normal forms like 4NF.","title":"Lecture 5.3 - Relational Database Design 3"},{"location":"Week%205/Lecture%205.3%20-%20Relational%20Database%20Design3/#lecture-53-relational-database-design-3","text":"Summary This module discusses relational database design using functional dependencies (FDs). FD Theory: Armstrong's Axioms are used to derive new FDs from a given set. Closure of FDs generates all FDs logically implied by a set. Closure of attributes determines the attributes functionally determined by a set of attributes. Decomposition Using FDs: Boyce-Codd Normal Form (BCNF) ensures that non-trivial FDs involve superkeys or attributes in candidate keys. Decomposing relations into BCNF guarantees lossless join but may not preserve dependencies. 3NF (Third Normal Form): Relaxes BCNF by allowing attributes in candidate keys but enforces dependency preservation. Normalization Goals: Evaluate relation schemes for \"good\" form. Decompose schemes into lossless-join and dependency-preserving relations. Problems with Decomposition: Potential lossiness, dependency checking issues, and query performance concerns exist. Limitations of BCNF: BCNF may not prevent insertion anomalies in certain scenarios, suggesting the need for higher normal forms like 4NF.","title":"Lecture 5.3 - Relational Database Design 3"},{"location":"Week%205/Lecture%205.4%20-%20Relational%20Database%20Design4/","text":"Lecture 5.4 - Relational Database Design Summary This module covers algorithms and properties related to functional dependencies (FDs). Attribute Set Closure: Algorithm to find the closure of an attribute set, which includes the set itself and all attributes implied by FDs. Used to test if an attribute set is a superkey or to test functional dependencies. Extraneous Attributes: Algorithms to identify and remove extraneous attributes, which are redundant in FDs. Helps optimize the set of FDs by eliminating unnecessary dependencies. Equivalence of FD Sets: Two sets of FDs are equivalent if they logically imply each other's dependencies. Useful for comparing different representations of functional dependencies. Canonical Cover: Algorithm to find a minimal and unique set of FDs that represent a given set of FDs. Ensures that there are no redundant or extraneous dependencies. The canonical cover is often used as a \"normalized\" representation of functional dependencies. Practice Problems: Exercises to test understanding of the algorithms and concepts discussed. Cover tasks like checking FD implications, finding super and candidate keys, and computing canonical covers.","title":"Lecture 5.4 - Relational Database Design"},{"location":"Week%205/Lecture%205.4%20-%20Relational%20Database%20Design4/#lecture-54-relational-database-design","text":"Summary This module covers algorithms and properties related to functional dependencies (FDs). Attribute Set Closure: Algorithm to find the closure of an attribute set, which includes the set itself and all attributes implied by FDs. Used to test if an attribute set is a superkey or to test functional dependencies. Extraneous Attributes: Algorithms to identify and remove extraneous attributes, which are redundant in FDs. Helps optimize the set of FDs by eliminating unnecessary dependencies. Equivalence of FD Sets: Two sets of FDs are equivalent if they logically imply each other's dependencies. Useful for comparing different representations of functional dependencies. Canonical Cover: Algorithm to find a minimal and unique set of FDs that represent a given set of FDs. Ensures that there are no redundant or extraneous dependencies. The canonical cover is often used as a \"normalized\" representation of functional dependencies. Practice Problems: Exercises to test understanding of the algorithms and concepts discussed. Cover tasks like checking FD implications, finding super and candidate keys, and computing canonical covers.","title":"Lecture 5.4 - Relational Database Design"},{"location":"Week%205/Lecture%205.5%20-%20Relational%20Database%20Design5/","text":"Lecture 5.5 - Relational Database Design5.pdf (PDF file) Summary Relational Database Design Lossless Join Decomposition A decomposition of a relation R into R1 and R2 is lossless if either R1 \u2229 R2 \u2192 R1 or R1 \u2229 R2 \u2192 R2 is in the set of functional dependencies (FDs) for R. This condition ensures that the original relation can be reconstructed by joining R1 and R2. Dependency Preservation A decomposition of R into D = {R1, R2, ..., Rn} is dependency preserving if (F1 \u222a F2 \u222a ... \u222a Fn) = F, where: Fi is the set of FDs including attributes only in Ri This ensures that all FDs in F are preserved in the decomposition. Testing Dependency Preservation Test if a dependency \u03b1 \u2192 \u03b2 is preserved by: Computing F0 = F1 \u222a F2 \u222a ... \u222a Fn Check if \u03b2 is in the attribute closure of \u03b1 with respect to F0 Practice Problems Lossless Join Decomposition Determine if the following decompositions are lossless: R(ABC) : F = {A \u2192 B, A \u2192 C} \u2192 {R1(AB), R2(BC)} R(ABCDEF) : F = {A \u2192 B, B \u2192 C, C \u2192 D, E \u2192 F} \u2192 {R1(AB), R2(BCD), R3(DEF)} R(ABCDEF) : F = {A \u2192 B, C \u2192 DE, AC \u2192 F} \u2192 {R1(BE), R2(ACDEF)} R(ABCDEG) : F = {AB \u2192 C, AC \u2192 B, AD \u2192 E, B \u2192 D, BC \u2192 A, E \u2192 G} \u2192 {R1(AB), R2(BC), R3(ABDE), R4(EG)} R(ABCDEFGHIJ) : F = {AB \u2192 C, B \u2192 F, D \u2192 IJ, A \u2192 DE, F \u2192 GH} \u2192 {R1(ABC), R2(ADE), R3(BF), R4(FGH), R5(DIJ)} Dependency Preservation Verify if the following decompositions preserve dependencies: R(ABCD) : F = {A \u2192 B, B \u2192 C, C \u2192 D, D \u2192 A} \u2192 {AB, BC, CD} R(ABCDEF) : F = {AB \u2192 CD, C \u2192 D, D \u2192 E, E \u2192 F} \u2192 {AB, CDE, EF} R(ABCDEG) : F = {AB \u2192 C, AC \u2192 B, BC \u2192 A, AD \u2192 E, B \u2192 D, E \u2192 G} \u2192 {ABC, ACDE, ADG} R(ABCD) : F = {A \u2192 B, B \u2192 C, C \u2192 D, D \u2192 B} \u2192 {AB, BC, BD} R(ABCDE) : F = {A \u2192 BC, CD \u2192 E, B \u2192 D, E \u2192 A} \u2192 {ABCE, BD}","title":"Lecture 5.5 - Relational Database Design5.pdf (PDF file)"},{"location":"Week%205/Lecture%205.5%20-%20Relational%20Database%20Design5/#lecture-55-relational-database-design5pdf-pdf-file","text":"Summary Relational Database Design Lossless Join Decomposition A decomposition of a relation R into R1 and R2 is lossless if either R1 \u2229 R2 \u2192 R1 or R1 \u2229 R2 \u2192 R2 is in the set of functional dependencies (FDs) for R. This condition ensures that the original relation can be reconstructed by joining R1 and R2. Dependency Preservation A decomposition of R into D = {R1, R2, ..., Rn} is dependency preserving if (F1 \u222a F2 \u222a ... \u222a Fn) = F, where: Fi is the set of FDs including attributes only in Ri This ensures that all FDs in F are preserved in the decomposition. Testing Dependency Preservation Test if a dependency \u03b1 \u2192 \u03b2 is preserved by: Computing F0 = F1 \u222a F2 \u222a ... \u222a Fn Check if \u03b2 is in the attribute closure of \u03b1 with respect to F0 Practice Problems Lossless Join Decomposition Determine if the following decompositions are lossless: R(ABC) : F = {A \u2192 B, A \u2192 C} \u2192 {R1(AB), R2(BC)} R(ABCDEF) : F = {A \u2192 B, B \u2192 C, C \u2192 D, E \u2192 F} \u2192 {R1(AB), R2(BCD), R3(DEF)} R(ABCDEF) : F = {A \u2192 B, C \u2192 DE, AC \u2192 F} \u2192 {R1(BE), R2(ACDEF)} R(ABCDEG) : F = {AB \u2192 C, AC \u2192 B, AD \u2192 E, B \u2192 D, BC \u2192 A, E \u2192 G} \u2192 {R1(AB), R2(BC), R3(ABDE), R4(EG)} R(ABCDEFGHIJ) : F = {AB \u2192 C, B \u2192 F, D \u2192 IJ, A \u2192 DE, F \u2192 GH} \u2192 {R1(ABC), R2(ADE), R3(BF), R4(FGH), R5(DIJ)} Dependency Preservation Verify if the following decompositions preserve dependencies: R(ABCD) : F = {A \u2192 B, B \u2192 C, C \u2192 D, D \u2192 A} \u2192 {AB, BC, CD} R(ABCDEF) : F = {AB \u2192 CD, C \u2192 D, D \u2192 E, E \u2192 F} \u2192 {AB, CDE, EF} R(ABCDEG) : F = {AB \u2192 C, AC \u2192 B, BC \u2192 A, AD \u2192 E, B \u2192 D, E \u2192 G} \u2192 {ABC, ACDE, ADG} R(ABCD) : F = {A \u2192 B, B \u2192 C, C \u2192 D, D \u2192 B} \u2192 {AB, BC, BD} R(ABCDE) : F = {A \u2192 BC, CD \u2192 E, B \u2192 D, E \u2192 A} \u2192 {ABCE, BD}","title":"Lecture 5.5 - Relational Database Design5.pdf (PDF file)"},{"location":"Week%205/closureofartibut/","text":"(AC)^plus = 1. as A-> B (AC)^+ = ACB 2. as BC -> DE (AC)^+ = ACBDE 3. AEF -> G and F not in (AC)^+ 4. (AC)^+ = \"ACBDE\" 1. closure if ACF as A -> B ACF + = ACFB 2. BC -> DE ACF + = ACFBDE 3. AEF -> G ACF + = ACFBDEG","title":"Closureofartibut"},{"location":"Week%205/ex_can/","text":"","title":"Ex can"},{"location":"Week%205/week5/","text":"[ ] lec class [ ] PPA [ ] GRPA [ ] GA [ ] instructor section 1 [ ] instructor section 2 [ ] TA session 1 [ ] TA session 2 [ ] Text book","title":"Week5"},{"location":"week1/Lecture%201.1%20-%20Course%20Overview/","text":"Lecture 1.1 - Course Overview.pdf (PDF file) Summary Database Management Systems (DBMSs) are crucial in modern applications, providing organized access to large volumes of interconnected data through a user-friendly interface. They offer advantages such as eliminating data redundancy, enhancing data accessibility, promoting data security, and ensuring data integrity. This course provides an overview of DBMS concepts and applications, including fundamental sets, relations, functions, propositional and predicate logic, data structures, object-oriented analysis, and Python programming. The essential prerequisites for the course include set theory, relations and functions, propositional logic, predicate logic, data structures, programming in Python, and algorithms and programming in C. Desirable prerequisites include object-oriented analysis and design. The course outline covers: Why Databases? Know Your Course (KYC) KYC: Course Prerequisite KYC: Course Outline KYC: Course Text Book Module Summary The textbook for the course is \"Database System Concepts\" by Abraham Silberschatz, Henry Korth, and S. Sudarshan.","title":"Lecture 1.1 - Course Overview.pdf (PDF file)"},{"location":"week1/Lecture%201.1%20-%20Course%20Overview/#lecture-11-course-overviewpdf-pdf-file","text":"Summary Database Management Systems (DBMSs) are crucial in modern applications, providing organized access to large volumes of interconnected data through a user-friendly interface. They offer advantages such as eliminating data redundancy, enhancing data accessibility, promoting data security, and ensuring data integrity. This course provides an overview of DBMS concepts and applications, including fundamental sets, relations, functions, propositional and predicate logic, data structures, object-oriented analysis, and Python programming. The essential prerequisites for the course include set theory, relations and functions, propositional logic, predicate logic, data structures, programming in Python, and algorithms and programming in C. Desirable prerequisites include object-oriented analysis and design. The course outline covers: Why Databases? Know Your Course (KYC) KYC: Course Prerequisite KYC: Course Outline KYC: Course Text Book Module Summary The textbook for the course is \"Database System Concepts\" by Abraham Silberschatz, Henry Korth, and S. Sudarshan.","title":"Lecture 1.1 - Course Overview.pdf (PDF file)"},{"location":"week1/Lecture%201.2%20-%20Why%20DBMS1/","text":"Lecture 1.2 - Why DBMS1.pdf (PDF file) Summary Module 2 of the course focuses on the evolution of data management and the history of database management systems (DBMSs). It highlights the need for DBMSs from a historical perspective, tracing the evolution of data management practices. The module covers the history of DBMSs, starting with physical data management (book keeping) using ledgers and journals. It discusses the significant advancement in 1886 when Henry Brown patented a device for storing and preserving papers. The invention of punch cards by Herman Hollerith in 1890 for use in tabulating machines further propelled electronic data management. The module explores key parameters for electronic data management, including durability, scalability, security, ease of use, consistency, efficiency, cost, and others. It examines the limitations of traditional file systems in meeting growing data needs and discusses the transition to DBMSs. The module reviews the history of DBMSs, starting with the use of magnetic tapes in the 1950s and early 1960s. It highlights the development of hard disks in the late 1960s and 1970s, enabling direct access to data. The introduction of the relational data model by Ted Codd and the development of commercial relational database systems in the 1980s are also mentioned. The module concludes with a summary of the evolution of data models, DB technology, and DB architecture. Data Management Storage Retrieval Transaction Audit Archival for : individual Small/ big enterprise global Major Approach: Physical also know as Book keeping Electronic Electronic Data or Records management depends on various parameters including: \u2022 Durability \u2022 Scalability \u2022 Security \u2022 Retrieval \u2022 Ease of Use \u2022 Consistency \u2022 Efficiency \u2022 Cost Problems with such an approach of book-keeping: \u2022 Durability: Physical damage to these registers is a possibility due to rodents, humidity, wear and tear \u2022 Scalability: Very difficult to maintain for many years, some shops have numerous registers spanning over years \u2022 Security: Susceptible to tampering by outsiders \u2022 Retrieval: Time consuming process to search for a previous entry \u2022 Consistency: Prone to human errors Spreadsheet files - a better solutionm to natural file creation","title":"Lecture 1.2 - Why DBMS1.pdf (PDF file)"},{"location":"week1/Lecture%201.2%20-%20Why%20DBMS1/#lecture-12-why-dbms1pdf-pdf-file","text":"Summary Module 2 of the course focuses on the evolution of data management and the history of database management systems (DBMSs). It highlights the need for DBMSs from a historical perspective, tracing the evolution of data management practices. The module covers the history of DBMSs, starting with physical data management (book keeping) using ledgers and journals. It discusses the significant advancement in 1886 when Henry Brown patented a device for storing and preserving papers. The invention of punch cards by Herman Hollerith in 1890 for use in tabulating machines further propelled electronic data management. The module explores key parameters for electronic data management, including durability, scalability, security, ease of use, consistency, efficiency, cost, and others. It examines the limitations of traditional file systems in meeting growing data needs and discusses the transition to DBMSs. The module reviews the history of DBMSs, starting with the use of magnetic tapes in the 1950s and early 1960s. It highlights the development of hard disks in the late 1960s and 1970s, enabling direct access to data. The introduction of the relational data model by Ted Codd and the development of commercial relational database systems in the 1980s are also mentioned. The module concludes with a summary of the evolution of data models, DB technology, and DB architecture. Data Management Storage Retrieval Transaction Audit Archival for : individual Small/ big enterprise global Major Approach: Physical also know as Book keeping Electronic Electronic Data or Records management depends on various parameters including: \u2022 Durability \u2022 Scalability \u2022 Security \u2022 Retrieval \u2022 Ease of Use \u2022 Consistency \u2022 Efficiency \u2022 Cost Problems with such an approach of book-keeping: \u2022 Durability: Physical damage to these registers is a possibility due to rodents, humidity, wear and tear \u2022 Scalability: Very difficult to maintain for many years, some shops have numerous registers spanning over years \u2022 Security: Susceptible to tampering by outsiders \u2022 Retrieval: Time consuming process to search for a previous entry \u2022 Consistency: Prone to human errors Spreadsheet files - a better solutionm to natural file creation","title":"Lecture 1.2 - Why DBMS1.pdf (PDF file)"},{"location":"week1/Lecture%201.3%20-%20Why%20DBMS2/","text":"Lecture 1.3 - Why DBMS2.pdf (PDF file) Summary This module introduces file systems and database management systems (DBMSs) and compares their features. File Systems vs. Databases File systems are less efficient for data management, especially with increasing data volume and structural changes. DBMSs are scalable and provide built-in mechanisms for data handling. Python vs. SQL Python is easier to implement for file handling, while SQL provides faster execution in milliseconds even for large datasets. Parameterized Comparison Scalability: DBMSs are more scalable in terms of both data volume and structural changes. Time and Efficiency: DBMSs provide faster data processing through built-in mechanisms like indexing. However, for small datasets, the setup time of a DBMS may outweigh its advantages. Persistence, Robustness, and Security: DBMSs ensure automatic data persistence, provide mechanisms for backup and recovery, and offer user-specific security. Programmer's Productivity: DBMSs reduce coding effort by providing built-in mechanisms for data consistency and relationship maintenance. Arithmetic Operations: Python offers extensive arithmetic and logical operations, while SQL has limited support for these. Costs and Complexity: File systems are less expensive to implement and maintain, while DBMSs require specialized hardware, software, and personnel, leading to higher costs.","title":"Lecture 1.3 - Why DBMS2.pdf (PDF file)"},{"location":"week1/Lecture%201.3%20-%20Why%20DBMS2/#lecture-13-why-dbms2pdf-pdf-file","text":"Summary This module introduces file systems and database management systems (DBMSs) and compares their features. File Systems vs. Databases File systems are less efficient for data management, especially with increasing data volume and structural changes. DBMSs are scalable and provide built-in mechanisms for data handling. Python vs. SQL Python is easier to implement for file handling, while SQL provides faster execution in milliseconds even for large datasets. Parameterized Comparison Scalability: DBMSs are more scalable in terms of both data volume and structural changes. Time and Efficiency: DBMSs provide faster data processing through built-in mechanisms like indexing. However, for small datasets, the setup time of a DBMS may outweigh its advantages. Persistence, Robustness, and Security: DBMSs ensure automatic data persistence, provide mechanisms for backup and recovery, and offer user-specific security. Programmer's Productivity: DBMSs reduce coding effort by providing built-in mechanisms for data consistency and relationship maintenance. Arithmetic Operations: Python offers extensive arithmetic and logical operations, while SQL has limited support for these. Costs and Complexity: File systems are less expensive to implement and maintain, while DBMSs require specialized hardware, software, and personnel, leading to higher costs.","title":"Lecture 1.3 - Why DBMS2.pdf (PDF file)"},{"location":"week1/Lecture%201.4%20-%20Intro%20to%20DBMS1/","text":"Lecture 1.4 - Intro to DBMS1.pdf (PDF file) Summary This document provides an introduction to Database Management Systems (DBMS) by discussing various concepts and components. Levels of Abstraction: Physical level: Database storage and organization. Logical level: Data representation and relationships.= type instructor = record ID : string; name : string; dept name : string; salary : integer; end; View level: Application-specific data presentation and security. Schema and Instance: Schema: Logical structure of the database, specifying data types, constraints, and relationships. logical schema - Analogous to type information of a variable in a program. Physical schema - The overall physical structure of the database. Instance: Actual data stored in the database at a specific time. Data Models: Tools for describing data, relationships, semantics, and constraints. Relational model: Stores data in tables, with rows representing records and columns representing attributes. DDL and DML: Data Definition Language (DDL): Used to create, modify, and delete database structures (e.g., tables). Data Manipulation Language (DML): Used to access and manipulate data (e.g., insert, update, delete). SQL (Structured Query Language): Commercial DML widely used in database systems. Not Turing-machine equivalent, but often embedded in other programming languages. Database Design: Process of creating the database schema and physical layout. Logical design: Deciding on the schema, including attributes and relationships. Physical design: Determining the physical storage and optimization strategies.","title":"Lecture 1.4 - Intro to DBMS1.pdf (PDF file)"},{"location":"week1/Lecture%201.4%20-%20Intro%20to%20DBMS1/#lecture-14-intro-to-dbms1pdf-pdf-file","text":"Summary This document provides an introduction to Database Management Systems (DBMS) by discussing various concepts and components. Levels of Abstraction: Physical level: Database storage and organization. Logical level: Data representation and relationships.= type instructor = record ID : string; name : string; dept name : string; salary : integer; end; View level: Application-specific data presentation and security. Schema and Instance: Schema: Logical structure of the database, specifying data types, constraints, and relationships. logical schema - Analogous to type information of a variable in a program. Physical schema - The overall physical structure of the database. Instance: Actual data stored in the database at a specific time. Data Models: Tools for describing data, relationships, semantics, and constraints. Relational model: Stores data in tables, with rows representing records and columns representing attributes. DDL and DML: Data Definition Language (DDL): Used to create, modify, and delete database structures (e.g., tables). Data Manipulation Language (DML): Used to access and manipulate data (e.g., insert, update, delete). SQL (Structured Query Language): Commercial DML widely used in database systems. Not Turing-machine equivalent, but often embedded in other programming languages. Database Design: Process of creating the database schema and physical layout. Logical design: Deciding on the schema, including attributes and relationships. Physical design: Determining the physical storage and optimization strategies.","title":"Lecture 1.4 - Intro to DBMS1.pdf (PDF file)"},{"location":"week1/Lecture%201.5%20-%20Intro%20to%20DBMS2/","text":"Lecture 1.5 - Intro to DBMS2.pdf (PDF file) Summary Module Overview This module provides an introduction to Database Management Systems (DBMS). Objectives Understand models of DBMS Learn about key components of a database engine Familiarize with database internals and architecture Topics Database Design: Logical design (schema design) Physical design (data layout) Design methodologies (Entity-Relationship Model, Normalization Theory) Object-Relational Data Models: Extension of relational models to include object-oriented concepts Features: complex types, non-atomic values XML: Extensible Markup Language: Overview and uses Data exchange format Database Engine: Storage management: file interaction, data storage/retrieval Query processing: parsing, optimization, evaluation Transaction management: ensuring data integrity and consistency Database System Internals: Database architecture: centralized, client-server, distributed, cloud Database Users and Administrators: Different types of database users and their roles","title":"Lecture 1.5 - Intro to DBMS2.pdf (PDF file)"},{"location":"week1/Lecture%201.5%20-%20Intro%20to%20DBMS2/#lecture-15-intro-to-dbms2pdf-pdf-file","text":"Summary Module Overview This module provides an introduction to Database Management Systems (DBMS). Objectives Understand models of DBMS Learn about key components of a database engine Familiarize with database internals and architecture Topics Database Design: Logical design (schema design) Physical design (data layout) Design methodologies (Entity-Relationship Model, Normalization Theory) Object-Relational Data Models: Extension of relational models to include object-oriented concepts Features: complex types, non-atomic values XML: Extensible Markup Language: Overview and uses Data exchange format Database Engine: Storage management: file interaction, data storage/retrieval Query processing: parsing, optimization, evaluation Transaction management: ensuring data integrity and consistency Database System Internals: Database architecture: centralized, client-server, distributed, cloud Database Users and Administrators: Different types of database users and their roles","title":"Lecture 1.5 - Intro to DBMS2.pdf (PDF file)"},{"location":"week1/summary/","text":"Summary The query processor subsystem compiles and executes DDL and DML state- ments. Transaction management ensures that the database remains in a consistent (cor- rect) state despite system failures. The transaction manager ensures that concur- rent transaction executions proceed without con\ufb02icts. The architecture of a database system is greatly in\ufb02uenced by the underlying com- puter system on which the database system runs. Database systems can be central- ized, or parallel, involving multiple machines. Distributed databases span multiple geographically separated machines. Database applications are typically broken up into a front-end part that runs at client machines and a part that runs at the backend. In two-tier architectures, the front end directly communicates with a database running at the back end. In three- tier architectures, the back end part is itself broken up into an application server and a database server. There are four di\ufb00erent types of database-system users, di\ufb00erentiated by the way they expect to interact with the system. Di\ufb00erent types of user interfaces have been designed for the di\ufb00erent types of users. Data-analysis techniques attempt to automatically discover rules and patterns from data. The \ufb01eld of data mining combines knowledge-discovery techniques invented by arti\ufb01cial intelligence researchers and statistical analysts with e\ufb03cient imple- mentation techniques that enable them to be used on extremely large databases. Database-management system (DBMS) Database-system applications Online transaction processing Data analytics File-processing systems Data inconsistency Consistency constraints Data abstraction Physical level Logical level View level Instance Schema Physical schema Logical schema Subschema Physical data independence Data models Entity-relationship model Relational data model Semi-structured data model Object-based data model Database languages Data-de\ufb01nition language Data-manipulation language Procedural DML Declarative DML nonprocedural DML Query language Data-de\ufb01nition language Domain Constraints Referential Integrity Authorization Read authorization Insert authorization Update authorization Delete authorization Metadata Application program Database design Conceptual design Normalization Speci\ufb01cation of functional re- quirements Physical-design phase Database Engine Storage manager Authorization and integrity manager Transaction manager File manager Bu\ufb00er manager Data \ufb01les Data dictionary Indices Query processor DDL interpreter DML compiler Query optimization Query evaluation engine Transaction Atomicity Consistency Durability Recovery manager Failure recovery Concurrency-control manager Database Architecture Centralized Parallel Distributed Database Application Architecture Two-tier Three-tier Application server Database administrator (DBA) This chapter has described several major advantages of a database system. What - are two disadvantages? List \ufb01ve ways in which the type declaration system of a language such as Java or C++ di\ufb00ers from the data de\ufb01nition language used in a database. 3 List six major steps that you would take in setting up a database for a particular enterprise. 4Suppose you want to build a video site similar to YouTube. Consider each of the points listed in Section - 2 as disadvantages of keeping data in a \ufb01le-processing system. Discuss the relevance of each of these points to the storage of actual video data, and to metadata about the video, such as title, the user who uploaded it, tags, and which users viewed it. 5Keyword queries used in web search are quite di\ufb00erent from database queries. List key di\ufb00erences between the two, in terms of the way the queries are speci\ufb01ed and in terms of what is the result of a query. List four applications you have used that most likely employed a database system to store persistent data. 7List four signi\ufb01cant di\ufb00erences between a \ufb01le-processing system and a DBMS. 8Explain the concept of physical data independence and its importance in database systems. 9List \ufb01ve responsibilities of a database-management system. For each responsi- bility, explain the problems that would arise if the responsibility were not dis- charged. 10List at least two reasons why database systems support data manipulation using a declarative query language such as SQL, instead of just providing a library of C or C++ functions to carry out data manipulation. 11Assume that two students are trying to register for a course in which there is only one open seat. What component of a database system prevents both students from being given that last seat? 12Explain the di\ufb00erence between two-tier and three-tier application architectures. Which is better suited for web applications? Why? 13List two features developed in the 2000s and that help database systems handle data-analytics workloads. 14Explain why NoSQL systems emerged in the 2000s, and brie\ufb02y contrast their features with traditional database systems. 15Describe at least three tables that might be used to store information in a social- networking system such as Facebook.","title":"Summary"},{"location":"week1/textbook/","text":"","title":"Textbook"},{"location":"week1/week1/","text":"[X] lec class [X] PPA [X] GRPA [X] GA [X] instructor section 1 [X] instructor section 2 [X] TA session 1 [X] TA session 2 [X] Text book","title":"Week1"},{"location":"week2/Lecture%202.1%20-%20Introduction%20to%20Relational%20Model1/","text":"Lecture 2.1 - Introduction to Relational Model1 Summary This module introduces the relational model for database management systems. It covers: Attributes and Types: Attributes represent data characteristics and have specific types, such as alphanumeric strings alpha strings dates numbers alpha strings each attributes has to atomic - same datatype that is indivisble null - spl value for every domain indicates that value is unknown domain is the allowed value for each attribute Schema and Instance: Schema defines the structure of a relation (table) specifying attributes and their types. Instance is the current state of a relation, represented as a table with rows (tuples). A1 , A2 , \u00b7 \u00b7 \u00b7 , An are attributes R = (A1 , A2 , \u00b7 \u00b7 \u00b7 , An ) is a relation schema Example: instructor = (ID, name, dept name, salary ) Formally, given sets D1 , D2 , \u00b7 \u00b7 \u00b7 , Dn a relation r is a subset of D 1 \u00d7 D2 \u00d7 \u00b7 \u00b7 \u00b7 \u00d7 Dn instructor \u2261 (String (5) \u00d7 String \u00d7 String \u00d7 Number +), where D \u2208 String (5), name \u2208 String , dept name \u2208 String , and salary \u2208 Number + imp thing to note : Order of tuples / rows is irrelevant (tuples may be stored in an arbitrary order) No two tuples / rows may be identical Keys: A superkey uniquely identifies tuples in a relation. Example: {ID} and {ID, name} are both superkeys of instructor A candidate key is a minimal superkey. Example: {ID} is a candidate key for instructor A primary key is the selected candidate key used for unique identification. A surrogate key (or synthetic key) in a database is a unique identifier for either an entity in the modeled world or an object in the database eg : transaction id of amazon the transaction id is only valid in the order life time . Secondary / Alternate Key: {First Name, Last Name}, Aadhaar # Simple Key: Consists of a single attribute Composite Key: {First Name, Last Name} Consists of more than one attribute to uniquely identify an entity occurrence One or more of the attributes, which make up the key, are not simple keys in their own right Relational Query Languages: Relational algebra, a procedural language, is introduced as a tool for manipulating relations using basic operations. Other \"pure\" languages exist but are not covered here.","title":"Lecture 2.1 - Introduction to Relational Model1"},{"location":"week2/Lecture%202.1%20-%20Introduction%20to%20Relational%20Model1/#lecture-21-introduction-to-relational-model1","text":"Summary This module introduces the relational model for database management systems. It covers: Attributes and Types: Attributes represent data characteristics and have specific types, such as alphanumeric strings alpha strings dates numbers alpha strings each attributes has to atomic - same datatype that is indivisble null - spl value for every domain indicates that value is unknown domain is the allowed value for each attribute Schema and Instance: Schema defines the structure of a relation (table) specifying attributes and their types. Instance is the current state of a relation, represented as a table with rows (tuples). A1 , A2 , \u00b7 \u00b7 \u00b7 , An are attributes R = (A1 , A2 , \u00b7 \u00b7 \u00b7 , An ) is a relation schema Example: instructor = (ID, name, dept name, salary ) Formally, given sets D1 , D2 , \u00b7 \u00b7 \u00b7 , Dn a relation r is a subset of D 1 \u00d7 D2 \u00d7 \u00b7 \u00b7 \u00b7 \u00d7 Dn instructor \u2261 (String (5) \u00d7 String \u00d7 String \u00d7 Number +), where D \u2208 String (5), name \u2208 String , dept name \u2208 String , and salary \u2208 Number + imp thing to note : Order of tuples / rows is irrelevant (tuples may be stored in an arbitrary order) No two tuples / rows may be identical Keys: A superkey uniquely identifies tuples in a relation. Example: {ID} and {ID, name} are both superkeys of instructor A candidate key is a minimal superkey. Example: {ID} is a candidate key for instructor A primary key is the selected candidate key used for unique identification. A surrogate key (or synthetic key) in a database is a unique identifier for either an entity in the modeled world or an object in the database eg : transaction id of amazon the transaction id is only valid in the order life time . Secondary / Alternate Key: {First Name, Last Name}, Aadhaar # Simple Key: Consists of a single attribute Composite Key: {First Name, Last Name} Consists of more than one attribute to uniquely identify an entity occurrence One or more of the attributes, which make up the key, are not simple keys in their own right Relational Query Languages: Relational algebra, a procedural language, is introduced as a tool for manipulating relations using basic operations. Other \"pure\" languages exist but are not covered here.","title":"Lecture 2.1 - Introduction to Relational Model1"},{"location":"week2/Lecture%202.2%20-%20Introduction%20to%20Relational%20Model2/","text":"Lecture 2.2 - Introduction to Relational Model2 Summary Introduction to Relational Model Module Objectives To understand relational algebra To familiarize with the operators of relational algebra Module Outline Operations Select Project Union Difference Intersection Cartesian Product Natural Join Aggregate Operations Relational Operators Select Operation: Selects rows (tuples) that meet a specified condition. \u2022 Relation r \u2022 \u03c3A=B\u2227D>5(r) \u2227 means and Project Operation: Selects columns (Attributes) of a relation. \u2022 Relation r \u2022 \u03c0A,C (r) Union of two relations: Combines the rows of two relations, eliminating duplicates. \u2022 Relation r,s \u2022 r \u222a s Set difference of two relations: Removes rows from the first relation that are also in the second relation. \u2022 Relation r,s \u2022 r \u2212 s Set intersection of two relations: Returns rows that are common to both relations. \u2022 Relation r,s \u2022 r \u2229 s Joining two relations \u2013 Cartesian-product: Combines all rows from the first relation with all rows from the second relation. \u2022 Relation r,s \u2022 r \u00d7 s when you have two atrributes with same name we remane the atrributes in cartseian product Natural Join: Joins two relations on the common attributes, eliminating duplicate columns. \u2022 Let r and s be relations on schemas R and S respectively. Then, the \u201cnatural join\u201d of relations R and S is a relation on schema R \u222a S obtained as follows: \u25e6 Consider each pair of tuples tr from r and ts from s. \u25e6 If tr and ts have the same value on each of the attributes in R \u2229 S, add a tuple t to the result, where . t has the same value as tr on r . t has the same value as ts on s Aggregation Operators Aggregate Operators: Perform calculations on groups of rows. SUM: Computes the sum of a specified column. AVG: Computes the average of a specified column. MAX: Computes the maximum value of a specified column. MIN: Computes the minimum value of a specified column. Notes about Relational Languages Each query input is a table (or set of tables). Each query output is a table. All data in the output table appears in one of the input tables. Relational Algebra is not Turing complete. Summary of Relational Algebra Operators Operator Description \u03c3 Select \u03c0 Project \u222a Union \u2212 Difference \u2229 Intersection \u00d7 Cartesian Product \\(\\bowtie\\) Natural Join SUM Computes the sum of a specified column AVG Computes the average of a specified column MAX Computes the maximum value of a specified column MIN Computes the minimum value of a specified column Module Summary Introduced relational algebra Familiarized with the operators of relational algebra","title":"Lecture 2.2 - Introduction to Relational Model2"},{"location":"week2/Lecture%202.2%20-%20Introduction%20to%20Relational%20Model2/#lecture-22-introduction-to-relational-model2","text":"Summary Introduction to Relational Model Module Objectives To understand relational algebra To familiarize with the operators of relational algebra Module Outline Operations Select Project Union Difference Intersection Cartesian Product Natural Join Aggregate Operations Relational Operators Select Operation: Selects rows (tuples) that meet a specified condition. \u2022 Relation r \u2022 \u03c3A=B\u2227D>5(r) \u2227 means and Project Operation: Selects columns (Attributes) of a relation. \u2022 Relation r \u2022 \u03c0A,C (r) Union of two relations: Combines the rows of two relations, eliminating duplicates. \u2022 Relation r,s \u2022 r \u222a s Set difference of two relations: Removes rows from the first relation that are also in the second relation. \u2022 Relation r,s \u2022 r \u2212 s Set intersection of two relations: Returns rows that are common to both relations. \u2022 Relation r,s \u2022 r \u2229 s Joining two relations \u2013 Cartesian-product: Combines all rows from the first relation with all rows from the second relation. \u2022 Relation r,s \u2022 r \u00d7 s when you have two atrributes with same name we remane the atrributes in cartseian product Natural Join: Joins two relations on the common attributes, eliminating duplicate columns. \u2022 Let r and s be relations on schemas R and S respectively. Then, the \u201cnatural join\u201d of relations R and S is a relation on schema R \u222a S obtained as follows: \u25e6 Consider each pair of tuples tr from r and ts from s. \u25e6 If tr and ts have the same value on each of the attributes in R \u2229 S, add a tuple t to the result, where . t has the same value as tr on r . t has the same value as ts on s Aggregation Operators Aggregate Operators: Perform calculations on groups of rows. SUM: Computes the sum of a specified column. AVG: Computes the average of a specified column. MAX: Computes the maximum value of a specified column. MIN: Computes the minimum value of a specified column. Notes about Relational Languages Each query input is a table (or set of tables). Each query output is a table. All data in the output table appears in one of the input tables. Relational Algebra is not Turing complete. Summary of Relational Algebra Operators Operator Description \u03c3 Select \u03c0 Project \u222a Union \u2212 Difference \u2229 Intersection \u00d7 Cartesian Product \\(\\bowtie\\) Natural Join SUM Computes the sum of a specified column AVG Computes the average of a specified column MAX Computes the maximum value of a specified column MIN Computes the minimum value of a specified column Module Summary Introduced relational algebra Familiarized with the operators of relational algebra","title":"Lecture 2.2 - Introduction to Relational Model2"},{"location":"week2/Lecture%202.3%20-%20Introduction%20to%20SQL1/","text":"Lecture 2.3 - Introduction to SQL1 Summary Module 08: Introduction to SQL Objectives Understand relational query language Understand data definition and basic query structure Outline History of SQL Data Definition Language (DDL) Create Table Integrity Constraints Update Table Data Manipulation Language (DML): Query Structure Select Clause Where Clause From Clause History of SQL IBM developed Structured English Query Language (SEQUEL) as part of System R project. Renamed Structured Query Language (SQL: pronounced still as SEQUEL) ANSI and ISO standard SQL: SQL-86 First formalized by ANSI SQL-89 + Integrity Constraints SQL-92 Major revision (ISO/IEC 9075 standard), De-facto Industry Standard SQL:1999 + Regular Expression Matching, Recursive Queries, Triggers, Support for Procedural and Control Flow Statements, Nonscalar types (Arrays), and Some OO features (structured types), Embedding SQL in Java (SQL/OLB), and Embedding Java in SQL (SQL/JRT) SQL:2003 + XML features (SQL/XML), Window Functions, Standardized Sequences, and Columns with Auto-generated Values (identity columns) SQL:2006 + Ways of importing and storing XML data in an SQL database, manipulating it within the database, and publishing both XML and conventional SQL-data in XML form SQL:2008 Legalizes ORDER BY outside Cursor Definitions INSTEAD OF Triggers, TRUNCATE Statement, and FETCH Clause SQL:2011 + Temporal Data (PERIOD FOR) Enhancements for Window Functions and FETCH Clause SQL:2016 + Row Pattern Matching, Polymorphic Table Functions, and JSON SQL:2019 + Multidimensional Arrays (MDarray type and operators) History of Query Language: Compliance SQL is the de facto industry standard today for relational or structred data systems (that is, SQL as a protocol), but there are many alternatives to writing SQL in the applications These alternatives have been implemented in the form of frontends for working with relational databases. Some examples of a frontend include (for a section of languages): \u25e6 SchemeQL and CLSQL, which are probably the most flexible, owing to their Lisp heritage, but they also look like a lot more like SQL than other frontends \u25e6 LINQ (in .Net) \u25e6 ScalaQL and ScalaQuery (in Scala) \u25e6 SqlStatement, ActiveRecord and many others in Ruby \u25e6 HaskellDB \u25e6 ...the list goes on for many other languages. History of Query Language: Alternatives There aren\u2019t any alternatives to SQL for speaking to relational databases (that is, SQL as a protocol), but there are many alternatives to writing SQL in the applications These alternatives have been implemented in the form of frontends for working with relational databases. Some examples of a frontend include (for a section of languages): \u25e6 SchemeQL and CLSQL, which are probably the most flexible, owing to their Lisp heritage, but they also look like a lot more like SQL than other frontends \u25e6 LINQ (in .Net) \u25e6 ScalaQL and ScalaQuery (in Scala) \u25e6 SqlStatement, ActiveRecord and many others in Ruby \u25e6 HaskellDB \u25e6 ...the list goes on for many other languages. Source: What are good alternatives to SQL (the language)? History of Query Language: Derivatives There are several query languages that are derived from or inspired by SQL. Of these, the most popular and effective is SPARQL. \u25e6 SPARQL (pronounced sparkle, a recursive acronym for SPARQL Protocol and RDF Query Language) is an RDF query language . A semantic query language for databases - able to retrieve and manipulate data stored in Resource Description Framework (RDF) format. . It has been standardized by the W3C Consortium as key technology of the semantic web . Versions: \u2212 SPARQL 1.0 (January 2008) \u2212 SPARQL 1.1 (March, 2013) . Used as the query languages for several NoSQL systems - particularly the Graph Databases that use RDF as store Data Definition Language (DDL) The SQL data-definition language (DDL) allows the specification of information about relations, including: The Schema for each Relation The Domain of values associated with each Attribute Integrity Constraints And, as we will see later, also other information such as \u25e6 The set of Indices to be maintained for each relations \u25e6 Security and Authorization information for each relation \u25e6 The Physical Storage Structure of each relation on disk Domain Types in SQL char(n). Fixed length character string, with user-specified length n varchar(n). Variable length character strings, with user-specified maximum length n int. Integer (a finite subset of the integers that is machine-dependent) smallint(n). Small integer (a machine-dependent subset of the integer domain type) numeric(p, d). Fixed point number, with user-specified precision of p digits, with d digits to the right of decimal point. (ex., numeric(3, 1), allows 44.5 to be stores exactly, but not 444.5 or 0.32) real, double precision. Floating point and double-precision floating point numbers, with machine-dependent precision float(n). Floating point number, with user-specified precision of at least n digits More are covered in Chapter 4 Create Table Construct An SQL relation is defined using the create table command: create table r (A1D1, A2D2, . . . , AnDn), (integrity-constraint1), . . . (integrity-constraintk )); \u25e6 r is the name of the relation \u25e6 each Ai is an attribute name in the schema of relation r \u25e6 Di is the data type of values in the domain of attribute Ai Create Table Construct (2) create table instructor ( ID char(5), name varchar(20) dept name varchar(20) salary numeric(8, 2)); Create Table Construct (3): Integrity Constraints not null primary key (A1, . . . , An) foreign key (Am, . . . , An) references r create table instructor (ID char(5),name varchar(20) not null,dept name varchar(20),salary numeric(8, 2),primary key (ID),foreign key (dept name) references department)); primary key declaration on an attribute automatically ensures not null University Schema Create Table Construct (4): More Relations create table student ( ID varchar(5), name varchar(20) not null, dept name varchar(20), tot cred numeric(3, 0), primary key (ID), foreign key (dept name) references department); create table course ( course id varchar(8), title varchar(50), dept name varchar(20), credits numeric(2, 0), primary key (course id), foreign key (dept name) references department); create table takes ( ID varchar(5), course id varchar(8), sec id varchar(8), semester varchar(6), year numeric(4, 0), grade varchar(2), primary key (ID, course id, sec id, semester, year ), foreign key (ID) references student foreign key (course id, sec id, semester, year ) references section); \u2022 Note: sec id can be dropped from primary key above, to ensure a student cannot be registered for two sections of the same course in the same semester Update Tables Insert (DML command) \u25e6 insert into instructor values (\u201810211\u2019, \u2018Smith\u2019, \u2018Biology\u2019, 66000); Delete (DML command) \u25e6 Remove all tuples from the student relation delete from student Drop Table (DDL command) \u25e6 drop table r Alter (DDL command) \u25e6 alter table r add A D . Where A is the name of the attribute to be added to relation r and D is the domain of A . All existing tuples in the relation are assigned null as the value for the new attribute \u25e6 alter table r drop A . Where A is the name of an attribute of relation r . Dropping of attributes not supported by many databases Data Manipulation Language (DML): Query Structure A typical SQL query has the form: select A1, A2, . . . , An,from r1,r2, ...,rmwhere P \u25e6 Ai represents an attribute from ri \u2019s \u25e6 ri represents a relation \u25e6 P is a predicate The result of an SQL query is a relation Basic Query Structure The select clause lists the attributes desired in the result of a query \u25e6 Corresponds to the projection operation of the relational algebra","title":"Lecture 2.3 - Introduction to SQL1"},{"location":"week2/Lecture%202.3%20-%20Introduction%20to%20SQL1/#lecture-23-introduction-to-sql1","text":"Summary Module 08: Introduction to SQL Objectives Understand relational query language Understand data definition and basic query structure Outline History of SQL Data Definition Language (DDL) Create Table Integrity Constraints Update Table Data Manipulation Language (DML): Query Structure Select Clause Where Clause From Clause History of SQL IBM developed Structured English Query Language (SEQUEL) as part of System R project. Renamed Structured Query Language (SQL: pronounced still as SEQUEL) ANSI and ISO standard SQL: SQL-86 First formalized by ANSI SQL-89 + Integrity Constraints SQL-92 Major revision (ISO/IEC 9075 standard), De-facto Industry Standard SQL:1999 + Regular Expression Matching, Recursive Queries, Triggers, Support for Procedural and Control Flow Statements, Nonscalar types (Arrays), and Some OO features (structured types), Embedding SQL in Java (SQL/OLB), and Embedding Java in SQL (SQL/JRT) SQL:2003 + XML features (SQL/XML), Window Functions, Standardized Sequences, and Columns with Auto-generated Values (identity columns) SQL:2006 + Ways of importing and storing XML data in an SQL database, manipulating it within the database, and publishing both XML and conventional SQL-data in XML form SQL:2008 Legalizes ORDER BY outside Cursor Definitions INSTEAD OF Triggers, TRUNCATE Statement, and FETCH Clause SQL:2011 + Temporal Data (PERIOD FOR) Enhancements for Window Functions and FETCH Clause SQL:2016 + Row Pattern Matching, Polymorphic Table Functions, and JSON SQL:2019 + Multidimensional Arrays (MDarray type and operators) History of Query Language: Compliance SQL is the de facto industry standard today for relational or structred data systems (that is, SQL as a protocol), but there are many alternatives to writing SQL in the applications These alternatives have been implemented in the form of frontends for working with relational databases. Some examples of a frontend include (for a section of languages): \u25e6 SchemeQL and CLSQL, which are probably the most flexible, owing to their Lisp heritage, but they also look like a lot more like SQL than other frontends \u25e6 LINQ (in .Net) \u25e6 ScalaQL and ScalaQuery (in Scala) \u25e6 SqlStatement, ActiveRecord and many others in Ruby \u25e6 HaskellDB \u25e6 ...the list goes on for many other languages. History of Query Language: Alternatives There aren\u2019t any alternatives to SQL for speaking to relational databases (that is, SQL as a protocol), but there are many alternatives to writing SQL in the applications These alternatives have been implemented in the form of frontends for working with relational databases. Some examples of a frontend include (for a section of languages): \u25e6 SchemeQL and CLSQL, which are probably the most flexible, owing to their Lisp heritage, but they also look like a lot more like SQL than other frontends \u25e6 LINQ (in .Net) \u25e6 ScalaQL and ScalaQuery (in Scala) \u25e6 SqlStatement, ActiveRecord and many others in Ruby \u25e6 HaskellDB \u25e6 ...the list goes on for many other languages. Source: What are good alternatives to SQL (the language)? History of Query Language: Derivatives There are several query languages that are derived from or inspired by SQL. Of these, the most popular and effective is SPARQL. \u25e6 SPARQL (pronounced sparkle, a recursive acronym for SPARQL Protocol and RDF Query Language) is an RDF query language . A semantic query language for databases - able to retrieve and manipulate data stored in Resource Description Framework (RDF) format. . It has been standardized by the W3C Consortium as key technology of the semantic web . Versions: \u2212 SPARQL 1.0 (January 2008) \u2212 SPARQL 1.1 (March, 2013) . Used as the query languages for several NoSQL systems - particularly the Graph Databases that use RDF as store Data Definition Language (DDL) The SQL data-definition language (DDL) allows the specification of information about relations, including: The Schema for each Relation The Domain of values associated with each Attribute Integrity Constraints And, as we will see later, also other information such as \u25e6 The set of Indices to be maintained for each relations \u25e6 Security and Authorization information for each relation \u25e6 The Physical Storage Structure of each relation on disk Domain Types in SQL char(n). Fixed length character string, with user-specified length n varchar(n). Variable length character strings, with user-specified maximum length n int. Integer (a finite subset of the integers that is machine-dependent) smallint(n). Small integer (a machine-dependent subset of the integer domain type) numeric(p, d). Fixed point number, with user-specified precision of p digits, with d digits to the right of decimal point. (ex., numeric(3, 1), allows 44.5 to be stores exactly, but not 444.5 or 0.32) real, double precision. Floating point and double-precision floating point numbers, with machine-dependent precision float(n). Floating point number, with user-specified precision of at least n digits More are covered in Chapter 4 Create Table Construct An SQL relation is defined using the create table command: create table r (A1D1, A2D2, . . . , AnDn), (integrity-constraint1), . . . (integrity-constraintk )); \u25e6 r is the name of the relation \u25e6 each Ai is an attribute name in the schema of relation r \u25e6 Di is the data type of values in the domain of attribute Ai Create Table Construct (2) create table instructor ( ID char(5), name varchar(20) dept name varchar(20) salary numeric(8, 2)); Create Table Construct (3): Integrity Constraints not null primary key (A1, . . . , An) foreign key (Am, . . . , An) references r create table instructor (ID char(5),name varchar(20) not null,dept name varchar(20),salary numeric(8, 2),primary key (ID),foreign key (dept name) references department)); primary key declaration on an attribute automatically ensures not null University Schema Create Table Construct (4): More Relations create table student ( ID varchar(5), name varchar(20) not null, dept name varchar(20), tot cred numeric(3, 0), primary key (ID), foreign key (dept name) references department); create table course ( course id varchar(8), title varchar(50), dept name varchar(20), credits numeric(2, 0), primary key (course id), foreign key (dept name) references department); create table takes ( ID varchar(5), course id varchar(8), sec id varchar(8), semester varchar(6), year numeric(4, 0), grade varchar(2), primary key (ID, course id, sec id, semester, year ), foreign key (ID) references student foreign key (course id, sec id, semester, year ) references section); \u2022 Note: sec id can be dropped from primary key above, to ensure a student cannot be registered for two sections of the same course in the same semester Update Tables Insert (DML command) \u25e6 insert into instructor values (\u201810211\u2019, \u2018Smith\u2019, \u2018Biology\u2019, 66000); Delete (DML command) \u25e6 Remove all tuples from the student relation delete from student Drop Table (DDL command) \u25e6 drop table r Alter (DDL command) \u25e6 alter table r add A D . Where A is the name of the attribute to be added to relation r and D is the domain of A . All existing tuples in the relation are assigned null as the value for the new attribute \u25e6 alter table r drop A . Where A is the name of an attribute of relation r . Dropping of attributes not supported by many databases Data Manipulation Language (DML): Query Structure A typical SQL query has the form: select A1, A2, . . . , An,from r1,r2, ...,rmwhere P \u25e6 Ai represents an attribute from ri \u2019s \u25e6 ri represents a relation \u25e6 P is a predicate The result of an SQL query is a relation Basic Query Structure The select clause lists the attributes desired in the result of a query \u25e6 Corresponds to the projection operation of the relational algebra","title":"Lecture 2.3 - Introduction to SQL1"},{"location":"week2/Lecture%202.4%20-%20Introduction%20to%20SQL2/","text":"Lecture 2.4 - Introduction to SQL2 Summary Additional Basic Operations Cartesian Product Finds all possible combinations of tuples from two or more relations. Useful when selecting data based on relationships between tables. Example: Select all possible instructor-course pairs using Cartesian product: select * from instructor , teaches Rename AS Operation Allows renaming of relations and attributes using the as clause: old name as new name Optional keyword as may be omitted. String Values SQL includes a string-matching operator ( like ) for character string comparisons. Uses special characters: Percent (%) matches any substring Underscore (_) matches any character Example: Find instructors with \"dar\" in their name: select name from instructor where name like '%dar%' \u2022 Patterns are case sensitive \u2022 Pattern matching examples: \u25e6 \u2019Intro%\u2019 matches any string beginning with \u201cIntro\u201d \u25e6 \u2019%Comp%\u2019 matches any string containing \u201cComp\u201d as a substring \u25e6 \u2019- - - \u2019 matches any string of exactly three characters \u25e6 \u2019 _ _%\u2019 matches any string of at least two characters \u2022 SQL supports a variety of string operations such as \u25e6 concatenation (using \u201c||\u201d) \u25e6 converting from upper to lower case (and vice versa) \u25e6 finding string length, extracting substrings, et Order By Clause Orders the display of tuples in ascending or descending order. By default, it is in ascending order. Can order by multiple attributes. Example: Order by name in descending order: select distinct name from instructor order by name desc Select Top / Fetch Clause Limits the number of records returned in the output. Useful for large tables to avoid performance impact. Example: Select the top 10 distinct names from the instructor table: select top 10 distinct name from instructor Where Clause Predicates Allows selecting tuples that meet specified conditions. Uses comparison operators, logical operators, and functions. Between operator allows specifying a range of values. Example: Find instructors with salaries between $90,000 and $100,000: select name from instructor where salary between 90000 and 100000 In Operator Allows specifying multiple values in a where clause. Shorthand for multiple or conditions. Example: Find instructors in the 'Comp. Sci.' or 'Biology' departments: select name from instructor where dept name in ( 'Comp. Sci.' , 'Biology' ) Tuple comparison select name, course_id from instructor , teaches where (instructor.ID, dept name) = (teaches.ID, \u2019Biology\u2019); Duplicates ???? SQL handles duplicates based on multiset semantics. Number of copies of tuples in the result depends on the number of copies in the input relations. For example, if there are two copies of tuple (1, a) in r1 and three copies of tuple (2) in r2, then the expression: \u03a0 B ( r1 ) x r2 would result in six copies of tuple (a, 2).","title":"Lecture 2.4 - Introduction to SQL2"},{"location":"week2/Lecture%202.4%20-%20Introduction%20to%20SQL2/#lecture-24-introduction-to-sql2","text":"Summary","title":"Lecture 2.4 - Introduction to SQL2"},{"location":"week2/Lecture%202.4%20-%20Introduction%20to%20SQL2/#additional-basic-operations","text":"","title":"Additional Basic Operations"},{"location":"week2/Lecture%202.4%20-%20Introduction%20to%20SQL2/#cartesian-product","text":"Finds all possible combinations of tuples from two or more relations. Useful when selecting data based on relationships between tables. Example: Select all possible instructor-course pairs using Cartesian product: select * from instructor , teaches","title":"Cartesian Product"},{"location":"week2/Lecture%202.4%20-%20Introduction%20to%20SQL2/#rename-as-operation","text":"Allows renaming of relations and attributes using the as clause: old name as new name Optional keyword as may be omitted.","title":"Rename AS Operation"},{"location":"week2/Lecture%202.4%20-%20Introduction%20to%20SQL2/#string-values","text":"SQL includes a string-matching operator ( like ) for character string comparisons. Uses special characters: Percent (%) matches any substring Underscore (_) matches any character Example: Find instructors with \"dar\" in their name: select name from instructor where name like '%dar%' \u2022 Patterns are case sensitive \u2022 Pattern matching examples: \u25e6 \u2019Intro%\u2019 matches any string beginning with \u201cIntro\u201d \u25e6 \u2019%Comp%\u2019 matches any string containing \u201cComp\u201d as a substring \u25e6 \u2019- - - \u2019 matches any string of exactly three characters \u25e6 \u2019 _ _%\u2019 matches any string of at least two characters \u2022 SQL supports a variety of string operations such as \u25e6 concatenation (using \u201c||\u201d) \u25e6 converting from upper to lower case (and vice versa) \u25e6 finding string length, extracting substrings, et","title":"String Values"},{"location":"week2/Lecture%202.4%20-%20Introduction%20to%20SQL2/#order-by-clause","text":"Orders the display of tuples in ascending or descending order. By default, it is in ascending order. Can order by multiple attributes. Example: Order by name in descending order: select distinct name from instructor order by name desc","title":"Order By Clause"},{"location":"week2/Lecture%202.4%20-%20Introduction%20to%20SQL2/#select-top-fetch-clause","text":"Limits the number of records returned in the output. Useful for large tables to avoid performance impact. Example: Select the top 10 distinct names from the instructor table: select top 10 distinct name from instructor","title":"Select Top / Fetch Clause"},{"location":"week2/Lecture%202.4%20-%20Introduction%20to%20SQL2/#where-clause-predicates","text":"Allows selecting tuples that meet specified conditions. Uses comparison operators, logical operators, and functions. Between operator allows specifying a range of values. Example: Find instructors with salaries between $90,000 and $100,000: select name from instructor where salary between 90000 and 100000","title":"Where Clause Predicates"},{"location":"week2/Lecture%202.4%20-%20Introduction%20to%20SQL2/#in-operator","text":"Allows specifying multiple values in a where clause. Shorthand for multiple or conditions. Example: Find instructors in the 'Comp. Sci.' or 'Biology' departments: select name from instructor where dept name in ( 'Comp. Sci.' , 'Biology' ) Tuple comparison select name, course_id from instructor , teaches where (instructor.ID, dept name) = (teaches.ID, \u2019Biology\u2019);","title":"In Operator"},{"location":"week2/Lecture%202.4%20-%20Introduction%20to%20SQL2/#duplicates","text":"SQL handles duplicates based on multiset semantics. Number of copies of tuples in the result depends on the number of copies in the input relations. For example, if there are two copies of tuple (1, a) in r1 and three copies of tuple (2) in r2, then the expression: \u03a0 B ( r1 ) x r2 would result in six copies of tuple (a, 2).","title":"Duplicates ????"},{"location":"week2/Lecture%202.5%20-%20Introduction%20to%20SQL3/","text":"Lecture 2.5 - Introduction to SQL3 Summary Introduction This module provides an overview of set operations, null values, and aggregation in SQL/3. It introduces the concepts of set union, intersection, and exception, as well as the handling of null values and aggregate functions. The module concludes with a summary of the key points covered. Objectives Upon completion of this module, students will be able to: Understand and apply set operations (union, intersection, except) Handle null values in SQL queries Use aggregate functions (avg, min, max, sum, count) Group data using the GROUP BY clause Filter grouped data using the HAVING clause Outline Set Operations Null Values Three-Valued Logic Aggregate Functions GROUP BY HAVING Null Values with Aggregates Set Operations Set operations in SQL/3 allow you to combine or compare the results of two or more queries. The three most common set operations are union, intersection, and except. Union: Returns all unique rows from both input queries. Intersection: Returns only the rows that are common to both input queries. Except: Returns all rows from the first input query that are not present in the second input query. Null Values Null values represent the absence of a value or an unknown value in SQL/3. They are distinct from zero or empty strings. usage : is null or is not null Three-Valued Logic Due to the inclusion of null values, SQL/3 uses a three-valued logic system, where a predicate can be evaluated as true, false, or unknown. True: If the predicate is satisfied without any null values. False: If the predicate is not satisfied, or if it involves null values. Unknown: If the predicate involves a comparison with a null value. Aggregate Functions Aggregate functions operate on a group of values and return a single result. Some common aggregate functions include: AVG: Average value MIN: Minimum value MAX: Maximum value SUM: Sum of values COUNT: Number of values GROUP BY The GROUP BY clause is used to group the results of a query based on one or more attributes. It allows for aggregation and filtering of data within each group. HAVING The HAVING clause is similar to the WHERE clause, but it is used to filter grouped data. It applies predicates to the aggregate values rather than the individual rows. Null Values with Aggregates Aggregate functions ignore null values unless the COUNT( ) function is used. COUNT( ) counts all rows, regardless of whether they contain null values. Module Summary This module has covered the following key concepts: Set operations (union, intersection, except) Null values and three-valued logic Aggregate functions (avg, min, max, sum, count) GROUP BY and HAVING clauses Handling null values with aggregates These concepts are essential for working with data in SQL/3. Understanding these concepts will enable you to perform complex data analysis and manipulation tasks efficiently.","title":"Lecture 2.5 - Introduction to SQL3"},{"location":"week2/Lecture%202.5%20-%20Introduction%20to%20SQL3/#lecture-25-introduction-to-sql3","text":"Summary Introduction This module provides an overview of set operations, null values, and aggregation in SQL/3. It introduces the concepts of set union, intersection, and exception, as well as the handling of null values and aggregate functions. The module concludes with a summary of the key points covered. Objectives Upon completion of this module, students will be able to: Understand and apply set operations (union, intersection, except) Handle null values in SQL queries Use aggregate functions (avg, min, max, sum, count) Group data using the GROUP BY clause Filter grouped data using the HAVING clause Outline Set Operations Null Values Three-Valued Logic Aggregate Functions GROUP BY HAVING Null Values with Aggregates Set Operations Set operations in SQL/3 allow you to combine or compare the results of two or more queries. The three most common set operations are union, intersection, and except. Union: Returns all unique rows from both input queries. Intersection: Returns only the rows that are common to both input queries. Except: Returns all rows from the first input query that are not present in the second input query. Null Values Null values represent the absence of a value or an unknown value in SQL/3. They are distinct from zero or empty strings. usage : is null or is not null Three-Valued Logic Due to the inclusion of null values, SQL/3 uses a three-valued logic system, where a predicate can be evaluated as true, false, or unknown. True: If the predicate is satisfied without any null values. False: If the predicate is not satisfied, or if it involves null values. Unknown: If the predicate involves a comparison with a null value. Aggregate Functions Aggregate functions operate on a group of values and return a single result. Some common aggregate functions include: AVG: Average value MIN: Minimum value MAX: Maximum value SUM: Sum of values COUNT: Number of values GROUP BY The GROUP BY clause is used to group the results of a query based on one or more attributes. It allows for aggregation and filtering of data within each group. HAVING The HAVING clause is similar to the WHERE clause, but it is used to filter grouped data. It applies predicates to the aggregate values rather than the individual rows. Null Values with Aggregates Aggregate functions ignore null values unless the COUNT( ) function is used. COUNT( ) counts all rows, regardless of whether they contain null values. Module Summary This module has covered the following key concepts: Set operations (union, intersection, except) Null values and three-valued logic Aggregate functions (avg, min, max, sum, count) GROUP BY and HAVING clauses Handling null values with aggregates These concepts are essential for working with data in SQL/3. Understanding these concepts will enable you to perform complex data analysis and manipulation tasks efficiently.","title":"Lecture 2.5 - Introduction to SQL3"},{"location":"week2/check_list/","text":"[ ] Text Book [X] slides [ ] weekly assigment [X] lecture [ ] live session [ ] text book activity","title":"Check list"},{"location":"week2/inst_sec/","text":"columns - attribute rows - tuple Primary keys: not null uniquie Table will have one Primary key multiple candiates key Domain set of allowed values for each attribute is called domain primary key is not nullable Atomic values - it cant mean broken down into smaller junks eg : Schema $$ R = (A_1, A_2, ..... A_n) \\ \\ \\\\ Domain\\ D = (D_1 , D_2, ....D_n) $$ order of rows or tuple is irrelevant no two tuple or row may be identical Keys A superkey uniquely identifies tuples in a relation. Example: {ID} and {ID, name} are both superkeys of instructor A candidate key is a minimal superkey. min no of super key to indentify a tuple. Example: {ID} is a candidate key for instructor A primary key is the selected candidate key used for unique identification. A surrogate key (or synthetic key) in a database is a unique identifier for either an entity in the modeled world or an object in the database eg : transaction id of amazon the transaction id is only valid in the order life time . Super key. Candidate key. Primary key. Surrogate key. Secondary / Alternate Key: {First Name, Last Name}, Aadhaar # Simple Key: Consists of a single attribute Aadhaar # Composite Key: {First Name, Last Name} Foreign key constrain : Value in a relation must appear in another he matches becomes the referencing relationship and host_team_id , guest_team_id is foreign key. Match_num is primary key in match_referees and matches. Compound key = two foreign key + simple key to used to identify an entity occurrence . Procedural and Non Procedural Language Operations Select Project Union Difference Intersection Cartesian Product Natural Join A relation is set. Selection \u2022 Relation r \\(\u03c3_{A=B\u2227D>5(r)}\\) \u2227 means and (A = B) intersect D > 5 Projection \u2022 Relation r \u2022 \\(\u03c0_{A,C}\\) (r) fetch the columns no dulipcates Union \u2022 Relation r,s \u2022 \\(r \u222a s\\) same nuumber of attributes or degree domains of the attributes has to be same Difference \\[ r-s \\] Intersection \\[ r \u2229 s = r- (r-s) \\] rows that are common to both relations. Cartesian Product \\[ R \\bowtie S \\] when you have two atrributes with same name we remane the atrributes in cartseian product. we rename the table using \\[ P_s(r) \\] renaming the table or relationship r to s \\[ r \\bowtie p_s(r) \\] self join and rename r to s = $ r\\bowtie s$ \\[ \\sigma_{A=C}(r \\bowtie s) \\] do a cross join of r and s and the find A = C not equal \\(<>\\) Inner Join Natural Join \\[ r\u2229s \\]","title":"Inst sec"},{"location":"week2/inst_sec/#domain","text":"set of allowed values for each attribute is called domain primary key is not nullable Atomic values - it cant mean broken down into smaller junks eg : Schema $$ R = (A_1, A_2, ..... A_n) \\ \\ \\\\ Domain\\ D = (D_1 , D_2, ....D_n) $$ order of rows or tuple is irrelevant no two tuple or row may be identical","title":"Domain"},{"location":"week2/inst_sec/#keys","text":"A superkey uniquely identifies tuples in a relation. Example: {ID} and {ID, name} are both superkeys of instructor A candidate key is a minimal superkey. min no of super key to indentify a tuple. Example: {ID} is a candidate key for instructor A primary key is the selected candidate key used for unique identification. A surrogate key (or synthetic key) in a database is a unique identifier for either an entity in the modeled world or an object in the database eg : transaction id of amazon the transaction id is only valid in the order life time . Super key. Candidate key. Primary key. Surrogate key. Secondary / Alternate Key: {First Name, Last Name}, Aadhaar # Simple Key: Consists of a single attribute Aadhaar # Composite Key: {First Name, Last Name} Foreign key constrain : Value in a relation must appear in another he matches becomes the referencing relationship and host_team_id , guest_team_id is foreign key. Match_num is primary key in match_referees and matches. Compound key = two foreign key + simple key to used to identify an entity occurrence .","title":"Keys"},{"location":"week2/inst_sec/#procedural-and-non-procedural-language","text":"","title":"Procedural and Non Procedural Language"},{"location":"week2/inst_sec/#operations","text":"Select Project Union Difference Intersection Cartesian Product Natural Join A relation is set.","title":"Operations"},{"location":"week2/inst_sec/#selection","text":"\u2022 Relation r \\(\u03c3_{A=B\u2227D>5(r)}\\) \u2227 means and (A = B) intersect D > 5","title":"Selection"},{"location":"week2/inst_sec/#projection","text":"\u2022 Relation r \u2022 \\(\u03c0_{A,C}\\) (r) fetch the columns no dulipcates","title":"Projection"},{"location":"week2/inst_sec/#union","text":"\u2022 Relation r,s \u2022 \\(r \u222a s\\) same nuumber of attributes or degree domains of the attributes has to be same","title":"Union"},{"location":"week2/inst_sec/#difference","text":"\\[ r-s \\]","title":"Difference"},{"location":"week2/inst_sec/#intersection","text":"\\[ r \u2229 s = r- (r-s) \\] rows that are common to both relations.","title":"Intersection"},{"location":"week2/inst_sec/#cartesian-product","text":"\\[ R \\bowtie S \\] when you have two atrributes with same name we remane the atrributes in cartseian product. we rename the table using \\[ P_s(r) \\] renaming the table or relationship r to s \\[ r \\bowtie p_s(r) \\] self join and rename r to s = $ r\\bowtie s$ \\[ \\sigma_{A=C}(r \\bowtie s) \\] do a cross join of r and s and the find A = C not equal \\(<>\\)","title":"Cartesian Product"},{"location":"week2/inst_sec/#inner-join","text":"","title":"Inner Join"},{"location":"week2/inst_sec/#natural-join","text":"\\[ r\u2229s \\]","title":"Natural Join"},{"location":"week2/live%20session_sat/","text":"","title":"Live session sat"},{"location":"week2/tutorial_2.1/","text":"","title":"Tutorial 2.1"},{"location":"week2/week2/","text":"[X] lec class [X] PPA [X] GRPA [X] GA [X] instructor section 1 [ ] instructor section 2 [X] TA session 1 [ ] TA session 2 [X] Text book","title":"Week2"},{"location":"week3/Lecture%203.1%20-%20SQL%20Examples/","text":"Lecture 3.1 - SQL Examples.pdf (PDF file) Summary Introduction summary of the concepts covered in SQL Examples, a module in Database Management Systems. The focus is on providing a comprehensive overview of the material, including select statements, Cartesian products, the AS keyword, WHERE clauses with AND/OR operators, string operations, ORDER BY statements, the IN operator, set operations (UNION, INTERSECT, EXCEPT), and aggregation functions (AVG, MIN, MAX, COUNT, SUM). SELECT Statements The SELECT statement is used to retrieve data from one or more tables. The basic syntax is: SELECT column_list FROM table_name WHERE conditions; The column_list specifies the columns to be retrieved, table_name specifies the table(s) to be queried, and the WHERE clause specifies any conditions that must be met for the rows to be included in the result. Cartesian Products / AS Keyword A Cartesian product is a combination of all rows from one table with all rows from another table. The AS keyword is used to assign an alias to a column or table. The syntax for a Cartesian product is: SELECT column_list FROM table_name1, table_name2 [AS alias]; WHERE Clauses with AND/OR Operators The WHERE clause is used to specify conditions that must be met for rows to be included in the result. The AND operator is used to combine multiple conditions that must all be true, and the OR operator is used to combine multiple conditions that only one must be true. The syntax is: WHERE condition1 [AND/OR condition2]...; String Operations String operations can be used to compare strings and extract substrings. The most common string operators are: = and !=: Equality and inequality < and >: Less than and greater than LIKE: Pattern matching SUBSTRING(): Extracts a substring ORDER BY Statements The ORDER BY statement is used to sort the results of a query. The syntax is: ORDER BY column_name [ASC/DESC]; The ASC keyword specifies ascending order, and the DESC keyword specifies descending order. IN Operator The IN operator is used to check if a value is contained in a set of values. The syntax is: WHERE column_name IN (value1, value2, ...); Set Operations (UNION, INTERSECT, EXCEPT) Set operations are used to combine the results of multiple queries. The UNION operator combines the results of two or more queries, removing duplicate rows. The INTERSECT operator combines the results of two or more queries, keeping only the rows that are common to all queries. The EXCEPT operator combines the results of two or more queries, keeping only the rows that are not common to all queries. The syntax is: SELECT column_list FROM query1 [UNION/INTERSECT/EXCEPT] SELECT column_list FROM query2; Aggregation Functions (AVG, MIN, MAX, COUNT, SUM) Aggregation functions are used to perform calculations on groups of rows. The most common aggregation functions are: AVG(): Average MIN(): Minimum MAX(): Maximum COUNT(): Count SUM(): Sum The syntax is: SELECT aggregate_function(column_name) FROM table_name GROUP BY group_by_column; Conclusion This summary has provided a comprehensive overview of the concepts covered in SQL Examples, a module in Database Management Systems. By understanding these concepts, you can effectively use SQL to retrieve, manipulate, and analyze data stored in relational databases.","title":"Lecture 3.1 - SQL Examples.pdf (PDF file)"},{"location":"week3/Lecture%203.1%20-%20SQL%20Examples/#lecture-31-sql-examplespdf-pdf-file","text":"Summary Introduction summary of the concepts covered in SQL Examples, a module in Database Management Systems. The focus is on providing a comprehensive overview of the material, including select statements, Cartesian products, the AS keyword, WHERE clauses with AND/OR operators, string operations, ORDER BY statements, the IN operator, set operations (UNION, INTERSECT, EXCEPT), and aggregation functions (AVG, MIN, MAX, COUNT, SUM). SELECT Statements The SELECT statement is used to retrieve data from one or more tables. The basic syntax is: SELECT column_list FROM table_name WHERE conditions; The column_list specifies the columns to be retrieved, table_name specifies the table(s) to be queried, and the WHERE clause specifies any conditions that must be met for the rows to be included in the result. Cartesian Products / AS Keyword A Cartesian product is a combination of all rows from one table with all rows from another table. The AS keyword is used to assign an alias to a column or table. The syntax for a Cartesian product is: SELECT column_list FROM table_name1, table_name2 [AS alias]; WHERE Clauses with AND/OR Operators The WHERE clause is used to specify conditions that must be met for rows to be included in the result. The AND operator is used to combine multiple conditions that must all be true, and the OR operator is used to combine multiple conditions that only one must be true. The syntax is: WHERE condition1 [AND/OR condition2]...; String Operations String operations can be used to compare strings and extract substrings. The most common string operators are: = and !=: Equality and inequality < and >: Less than and greater than LIKE: Pattern matching SUBSTRING(): Extracts a substring ORDER BY Statements The ORDER BY statement is used to sort the results of a query. The syntax is: ORDER BY column_name [ASC/DESC]; The ASC keyword specifies ascending order, and the DESC keyword specifies descending order. IN Operator The IN operator is used to check if a value is contained in a set of values. The syntax is: WHERE column_name IN (value1, value2, ...); Set Operations (UNION, INTERSECT, EXCEPT) Set operations are used to combine the results of multiple queries. The UNION operator combines the results of two or more queries, removing duplicate rows. The INTERSECT operator combines the results of two or more queries, keeping only the rows that are common to all queries. The EXCEPT operator combines the results of two or more queries, keeping only the rows that are not common to all queries. The syntax is: SELECT column_list FROM query1 [UNION/INTERSECT/EXCEPT] SELECT column_list FROM query2; Aggregation Functions (AVG, MIN, MAX, COUNT, SUM) Aggregation functions are used to perform calculations on groups of rows. The most common aggregation functions are: AVG(): Average MIN(): Minimum MAX(): Maximum COUNT(): Count SUM(): Sum The syntax is: SELECT aggregate_function(column_name) FROM table_name GROUP BY group_by_column; Conclusion This summary has provided a comprehensive overview of the concepts covered in SQL Examples, a module in Database Management Systems. By understanding these concepts, you can effectively use SQL to retrieve, manipulate, and analyze data stored in relational databases.","title":"Lecture 3.1 - SQL Examples.pdf (PDF file)"},{"location":"week3/Lecture%203.2%20-%20Intermediate%20SQL1/","text":"","title":"Lecture 3.2   Intermediate SQL1"},{"location":"week3/tutorial_3_5/","text":"","title":"Tutorial 3 5"},{"location":"week3/week3/","text":"[ ] lec class [ ] PPA [ ] GRPA [ ] GA [ ] instructor section 1 [ ] instructor section 2 [ ] TA session 1 [ ] TA session 2 [ ] Text book","title":"Week3"},{"location":"week3/image/Lecture%203.3%20-%20Intermediate%20SQL2/","text":"Lecture 3.3 - Intermediate SQL2.pdf (PDF file) Summary Module 13: Intermediate SQL/2 Objectives To learn SQL expressions for Join To learn SQL expressions for Views Outline Join Expressions Views Join Expressions Definition: Join operations take two relations and return as a result another relation. Purpose: Join operations are used to combine rows from two relations based on a specified condition. Types of Join between Relations Cross join: Returns the Cartesian product of rows from tables in the join. Inner join: Returns rows that match on the specified condition. Outer join: Returns all rows from one relation and rows from the other relation that match on the specified condition. Left outer join: Returns all rows from the left relation and rows from the right relation that match on the specified condition. Right outer join: Returns all rows from the right relation and rows from the left relation that match on the specified condition. Full outer join: Returns all rows from both relations, regardless of whether they match on the specified condition. Views Definition: A view is a virtual relation that is defined by a query expression. Purpose: Views provide a mechanism to hide certain data from users or to create a new relation that is derived from existing relations. View Definition A view is defined using the create view statement, which has the form: create view v as < query expression > The view name is represented by v . The query expression specifies the rows and columns that are included in the view. View Expansion Definition: View expansion is the process of replacing a view reference in a query or another view with the query expression that defines the view. Purpose: View expansion is used to ensure that queries that use views always return the correct results, even if the underlying relations change. Update of a View Updates to views are typically not allowed. In some cases, updates to simple views (views that meet certain criteria) may be allowed. Materialized Views Definition: A materialized view is a physical table that contains the results of a query. Purpose: Materialized views can improve query performance by avoiding the need to re-execute the query every time it is used. Module Summary Join expressions are used to combine rows from two relations based on a specified condition. Views provide a mechanism to hide certain data from users or to create a new relation that is derived from existing relations. View expansion ensures that queries that use views always return the correct results, even if the underlying relations change. Updates to views are typically not allowed, but may be allowed in some cases for simple views. Materialized views can improve query performance by avoiding the need to re-execute the query every time it is used.","title":"Lecture 3.3 - Intermediate SQL2.pdf (PDF file)"},{"location":"week3/image/Lecture%203.3%20-%20Intermediate%20SQL2/#lecture-33-intermediate-sql2pdf-pdf-file","text":"Summary Module 13: Intermediate SQL/2 Objectives To learn SQL expressions for Join To learn SQL expressions for Views Outline Join Expressions Views Join Expressions Definition: Join operations take two relations and return as a result another relation. Purpose: Join operations are used to combine rows from two relations based on a specified condition. Types of Join between Relations Cross join: Returns the Cartesian product of rows from tables in the join. Inner join: Returns rows that match on the specified condition. Outer join: Returns all rows from one relation and rows from the other relation that match on the specified condition. Left outer join: Returns all rows from the left relation and rows from the right relation that match on the specified condition. Right outer join: Returns all rows from the right relation and rows from the left relation that match on the specified condition. Full outer join: Returns all rows from both relations, regardless of whether they match on the specified condition. Views Definition: A view is a virtual relation that is defined by a query expression. Purpose: Views provide a mechanism to hide certain data from users or to create a new relation that is derived from existing relations. View Definition A view is defined using the create view statement, which has the form: create view v as < query expression > The view name is represented by v . The query expression specifies the rows and columns that are included in the view. View Expansion Definition: View expansion is the process of replacing a view reference in a query or another view with the query expression that defines the view. Purpose: View expansion is used to ensure that queries that use views always return the correct results, even if the underlying relations change. Update of a View Updates to views are typically not allowed. In some cases, updates to simple views (views that meet certain criteria) may be allowed. Materialized Views Definition: A materialized view is a physical table that contains the results of a query. Purpose: Materialized views can improve query performance by avoiding the need to re-execute the query every time it is used. Module Summary Join expressions are used to combine rows from two relations based on a specified condition. Views provide a mechanism to hide certain data from users or to create a new relation that is derived from existing relations. View expansion ensures that queries that use views always return the correct results, even if the underlying relations change. Updates to views are typically not allowed, but may be allowed in some cases for simple views. Materialized views can improve query performance by avoiding the need to re-execute the query every time it is used.","title":"Lecture 3.3 - Intermediate SQL2.pdf (PDF file)"},{"location":"week4/Lecture%204.1%20-%20Formal%20Relational%20Query%20Languages1_annotated/","text":"Lecture 4.1 - Formal Relational Query Languages1_annotated.pdf (PDF file) Summary Module 16 of Database Management Systems focuses on formal relational query languages like relational algebra. Relational algebra is an algebra-based language for querying relational databases. It has six basic operators: Select (\u03c3): Filters rows based on a condition. Project (\u03a0): Selects specific columns. Union (\u222a): Combines rows from two compatible relations. Difference (-): Removes rows that are in the second relation but not the first. Intersection (\u2229): Finds rows that are common to both relations. Cartesian Product (x): Combines all rows from one relation with all rows from another. These operators can be used in combination to create complex queries. Additionally, relational algebra includes a rename operation (\u03c1) and a division operation (\u00f7), which is a derived operation. The basic operations and examples of division are explained in detail. The module provides a thorough understanding of relational algebra and its use in formal relational query languages. Lec file Lecture 4.1 - Formal Relational Query Languages1_annotated.pdf (PDF file)","title":"Lecture 4.1 - Formal Relational Query Languages1_annotated.pdf (PDF file)"},{"location":"week4/Lecture%204.1%20-%20Formal%20Relational%20Query%20Languages1_annotated/#lecture-41-formal-relational-query-languages1_annotatedpdf-pdf-file","text":"Summary Module 16 of Database Management Systems focuses on formal relational query languages like relational algebra. Relational algebra is an algebra-based language for querying relational databases. It has six basic operators: Select (\u03c3): Filters rows based on a condition. Project (\u03a0): Selects specific columns. Union (\u222a): Combines rows from two compatible relations. Difference (-): Removes rows that are in the second relation but not the first. Intersection (\u2229): Finds rows that are common to both relations. Cartesian Product (x): Combines all rows from one relation with all rows from another. These operators can be used in combination to create complex queries. Additionally, relational algebra includes a rename operation (\u03c1) and a division operation (\u00f7), which is a derived operation. The basic operations and examples of division are explained in detail. The module provides a thorough understanding of relational algebra and its use in formal relational query languages. Lec file","title":"Lecture 4.1 - Formal Relational Query Languages1_annotated.pdf (PDF file)"},{"location":"week4/Lecture%204.1%20-%20Formal%20Relational%20Query%20Languages1_annotated/#lecture-41-formal-relational-query-languages1_annotatedpdf-pdf-file_1","text":"","title":"Lecture 4.1 - Formal Relational Query Languages1_annotated.pdf (PDF file)"},{"location":"week4/Lecture%204.2%20-%20Formal%20Relational%20Query%20Languages2_annotated/","text":"Lecture 4.2 - Formal Relational Query Languages2_annotated.pdf (PDF file) Summary This module covers formal calculus-based query languages, including the study of relational algebra, tuple relational calculus, and domain relational calculus. Predicate logic is introduced as the foundation for these calculus-based query languages. Key concepts include: Predicate Logic: A way of expressing statements that cannot be adequately represented by propositional logic. Uses predicates and quantifiers to describe properties and relationships between objects. Tuple Relational Calculus (TRC): A non-procedural query language where queries are expressed as sets of tuples satisfying certain conditions. Uses quantifiers and predicates to define the desired tuples. Domain Relational Calculus (DRC): Equivalent in power to TRC, but uses domain variables instead of tuples. Formulas in DRC resemble predicate calculus formulas. The text also establishes the equivalence of relational algebra, TRC, and DRC, highlighting their equal expressive power. The concept of safe expressions is introduced to prevent infinite relations from being generated in TRC and DRC expressions. Lec file Lecture 4.2 - Formal Relational Query Languages2_annotated.pdf (PDF file)","title":"Lecture 4.2 - Formal Relational Query Languages2_annotated.pdf (PDF file)"},{"location":"week4/Lecture%204.2%20-%20Formal%20Relational%20Query%20Languages2_annotated/#lecture-42-formal-relational-query-languages2_annotatedpdf-pdf-file","text":"Summary This module covers formal calculus-based query languages, including the study of relational algebra, tuple relational calculus, and domain relational calculus. Predicate logic is introduced as the foundation for these calculus-based query languages. Key concepts include: Predicate Logic: A way of expressing statements that cannot be adequately represented by propositional logic. Uses predicates and quantifiers to describe properties and relationships between objects. Tuple Relational Calculus (TRC): A non-procedural query language where queries are expressed as sets of tuples satisfying certain conditions. Uses quantifiers and predicates to define the desired tuples. Domain Relational Calculus (DRC): Equivalent in power to TRC, but uses domain variables instead of tuples. Formulas in DRC resemble predicate calculus formulas. The text also establishes the equivalence of relational algebra, TRC, and DRC, highlighting their equal expressive power. The concept of safe expressions is introduced to prevent infinite relations from being generated in TRC and DRC expressions. Lec file","title":"Lecture 4.2 - Formal Relational Query Languages2_annotated.pdf (PDF file)"},{"location":"week4/Lecture%204.2%20-%20Formal%20Relational%20Query%20Languages2_annotated/#lecture-42-formal-relational-query-languages2_annotatedpdf-pdf-file_1","text":"","title":"Lecture 4.2 - Formal Relational Query Languages2_annotated.pdf (PDF file)"},{"location":"week4/Lecture%204.3%20-%20Entity-Relationship%20Model1_annotated/","text":"Lecture 4.3 - Entity-Relationship Model1_annotated.pdf (PDF file) Summary Database Design Process: Requirement Analysis: Define data needs and business requirements Database Designing: Create an abstraction using a modeling framework Logical Model: Determine database schema Physical Model: Plan database layout Entity-Relationship (ER) Model: Represents an enterprise as a collection of entities, attributes, and relationships Attributes: Properties of entities Entity Sets: Collections of entities of the same type Relationships: Associations among multiple entities Entity Sets: Entities are objects distinguishable from others (e.g., person, company) Entity sets contain entities with shared properties Primary keys uniquely identify members of an entity set Relationships: Associations between entities (e.g., student-advisor relationship) Relationship sets define mathematical relations between multiple entities Mapping Cardinality Constraints: Expresses the number of entities that can be associated via a relationship Types: One to one One to many Many to one Many to many Weak Entity Sets: Entity sets that lack sufficient attributes for unique identification Dependent on strong entity sets through an identifying relationship Primary key of weak entity set = Discriminator + Primary Key of strong entity set Lec file Lecture 4.3 - Entity-Relationship Model1_annotated.pdf (PDF file)","title":"Lecture 4.3 - Entity-Relationship Model1_annotated.pdf (PDF file)"},{"location":"week4/Lecture%204.3%20-%20Entity-Relationship%20Model1_annotated/#lecture-43-entity-relationship-model1_annotatedpdf-pdf-file","text":"Summary Database Design Process: Requirement Analysis: Define data needs and business requirements Database Designing: Create an abstraction using a modeling framework Logical Model: Determine database schema Physical Model: Plan database layout Entity-Relationship (ER) Model: Represents an enterprise as a collection of entities, attributes, and relationships Attributes: Properties of entities Entity Sets: Collections of entities of the same type Relationships: Associations among multiple entities Entity Sets: Entities are objects distinguishable from others (e.g., person, company) Entity sets contain entities with shared properties Primary keys uniquely identify members of an entity set Relationships: Associations between entities (e.g., student-advisor relationship) Relationship sets define mathematical relations between multiple entities Mapping Cardinality Constraints: Expresses the number of entities that can be associated via a relationship Types: One to one One to many Many to one Many to many Weak Entity Sets: Entity sets that lack sufficient attributes for unique identification Dependent on strong entity sets through an identifying relationship Primary key of weak entity set = Discriminator + Primary Key of strong entity set Lec file","title":"Lecture 4.3 - Entity-Relationship Model1_annotated.pdf (PDF file)"},{"location":"week4/Lecture%204.3%20-%20Entity-Relationship%20Model1_annotated/#lecture-43-entity-relationship-model1_annotatedpdf-pdf-file_1","text":"","title":"Lecture 4.3 - Entity-Relationship Model1_annotated.pdf (PDF file)"},{"location":"week4/Lecture%204.4%20-%20Entity-Relationship%20Model2_annotated/","text":"Lecture 4.4 - Entity-Relationship Model2_annotated.pdf (PDF file) Summary Entity-Relationship (ER) Diagram Components: Entity Sets: Represent real-world entities (e.g., Student, Course). Relationship Sets: Represent relationships between entities (e.g., Advisor). ERD Notation: Rectangles: Entity sets Diamonds: Relationship sets Underlining: Primary key attributes Roles: Labels on lines connecting entities to relationship sets Minimum and maximum cardinality constraints: l..h (e.g., 1..*, 0..1) Total participation: Double line Partial participation: Single line Entity Sets: Strong entity sets: Every entity must participate in the set. Weak entity sets: Entities dependent on another entity set (identifying entity set). Relationship Sets: One-to-one: Each entity in one set relates to exactly one entity in the other set. Many-to-one: Each entity in one set relates to multiple entities in the other set. Many-to-many: Entities in both sets relate to multiple entities in the other set. ER Model to Relational Schema Translation: Entity sets are represented by tables with the same attributes. Relationship sets are represented by tables with the primary keys of the participating entity sets. Complex attributes are flattened into separate attributes. Multivalued attributes are represented by a separate table. Redundancy in Schema: Many-to-one/one-to-many relationships can be represented by adding an attribute to the \"many\" side instead of creating a separate schema. Weak entity sets are redundant and can be represented by the identifying entity set. Lec file Lecture 4.4 - Entity-Relationship Model2_annotated.pdf (PDF file)","title":"Lecture 4.4 - Entity-Relationship Model2_annotated.pdf (PDF file)"},{"location":"week4/Lecture%204.4%20-%20Entity-Relationship%20Model2_annotated/#lecture-44-entity-relationship-model2_annotatedpdf-pdf-file","text":"Summary Entity-Relationship (ER) Diagram Components: Entity Sets: Represent real-world entities (e.g., Student, Course). Relationship Sets: Represent relationships between entities (e.g., Advisor). ERD Notation: Rectangles: Entity sets Diamonds: Relationship sets Underlining: Primary key attributes Roles: Labels on lines connecting entities to relationship sets Minimum and maximum cardinality constraints: l..h (e.g., 1..*, 0..1) Total participation: Double line Partial participation: Single line Entity Sets: Strong entity sets: Every entity must participate in the set. Weak entity sets: Entities dependent on another entity set (identifying entity set). Relationship Sets: One-to-one: Each entity in one set relates to exactly one entity in the other set. Many-to-one: Each entity in one set relates to multiple entities in the other set. Many-to-many: Entities in both sets relate to multiple entities in the other set. ER Model to Relational Schema Translation: Entity sets are represented by tables with the same attributes. Relationship sets are represented by tables with the primary keys of the participating entity sets. Complex attributes are flattened into separate attributes. Multivalued attributes are represented by a separate table. Redundancy in Schema: Many-to-one/one-to-many relationships can be represented by adding an attribute to the \"many\" side instead of creating a separate schema. Weak entity sets are redundant and can be represented by the identifying entity set. Lec file","title":"Lecture 4.4 - Entity-Relationship Model2_annotated.pdf (PDF file)"},{"location":"week4/Lecture%204.4%20-%20Entity-Relationship%20Model2_annotated/#lecture-44-entity-relationship-model2_annotatedpdf-pdf-file_1","text":"","title":"Lecture 4.4 - Entity-Relationship Model2_annotated.pdf (PDF file)"},{"location":"week4/Lecture%204.5%20-%20Entity-Relationship%20Model3_annotated/","text":"Lecture 4.5 - Entity-Relationship Model3_annotated.pdf (PDF file) Summary Extended Features of the Entity-Relationship Model Non-binary relationships: These relationships involve more than two entities. Specialization: A sub-group of entities within an entity set is designated with distinctive characteristics. These sub-groups become lower-level entity sets that inherit attributes and relationships from the higher-level entity set. Generalization: Combining a number of entity sets with shared features into a higher-level entity set. Aggregation: Treating a relationship set as an abstract entity, allowing for relationships between relationships. Design Issues Entities vs. Attributes: Deciding whether to represent an object as an entity or an attribute. Entities vs. Relationship Sets: Distinguishing between real-world concepts that are best expressed by entities or relationships. Binary vs. Non-Binary Relationships: Determining whether to use binary or non-binary relationships to represent a relationship. Strong vs. Weak Entity Sets: Strong entity sets have an independent existence, while weak entity sets exist only in conjunction with another entity set. Specialization/Generalization: Using specialization to divide an entity set into sub-groups or generalization to combine entity sets with shared features. Aggregation: Treating an aggregate entity set as a unit without considering its internal structure. ER Notation Symbols for representing entities, relationships, and attributes in an ER diagram. Diagrams provide a graphical representation of the relationships and constraints between entities in a database. Lec file Lecture 4.5 - Entity-Relationship Model3_annotated.pdf (PDF file)","title":"Lecture 4.5 - Entity-Relationship Model3_annotated.pdf (PDF file)"},{"location":"week4/Lecture%204.5%20-%20Entity-Relationship%20Model3_annotated/#lecture-45-entity-relationship-model3_annotatedpdf-pdf-file","text":"Summary Extended Features of the Entity-Relationship Model Non-binary relationships: These relationships involve more than two entities. Specialization: A sub-group of entities within an entity set is designated with distinctive characteristics. These sub-groups become lower-level entity sets that inherit attributes and relationships from the higher-level entity set. Generalization: Combining a number of entity sets with shared features into a higher-level entity set. Aggregation: Treating a relationship set as an abstract entity, allowing for relationships between relationships. Design Issues Entities vs. Attributes: Deciding whether to represent an object as an entity or an attribute. Entities vs. Relationship Sets: Distinguishing between real-world concepts that are best expressed by entities or relationships. Binary vs. Non-Binary Relationships: Determining whether to use binary or non-binary relationships to represent a relationship. Strong vs. Weak Entity Sets: Strong entity sets have an independent existence, while weak entity sets exist only in conjunction with another entity set. Specialization/Generalization: Using specialization to divide an entity set into sub-groups or generalization to combine entity sets with shared features. Aggregation: Treating an aggregate entity set as a unit without considering its internal structure. ER Notation Symbols for representing entities, relationships, and attributes in an ER diagram. Diagrams provide a graphical representation of the relationships and constraints between entities in a database. Lec file","title":"Lecture 4.5 - Entity-Relationship Model3_annotated.pdf (PDF file)"},{"location":"week4/Lecture%204.5%20-%20Entity-Relationship%20Model3_annotated/#lecture-45-entity-relationship-model3_annotatedpdf-pdf-file_1","text":"","title":"Lecture 4.5 - Entity-Relationship Model3_annotated.pdf (PDF file)"},{"location":"week4/week4/","text":"[ ] lec class [ ] PPA [ ] GRPA [ ] GA [ ] instructor section 1 [ ] instructor section 2 [ ] TA session 1 [ ] TA session 2 [ ] Text book","title":"Week4"}]}