{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to DBMS Chapters Chapter 1: Introduction Chapter 2: Introduction to Relational Languages Chapter 3: Introduction to SQL Chapter 4: Intermediate SQL Chapter 5: Advanced SQL Sections 5.4 onwards may be omitted. Chapter 6: Entity-Relationship Model Chapter 7: Relational Database Design Chapter 8: Complex Data Types Chapter 9: Application Design Chapter 10: Big Data Chapter 11: Data Analytics Chapter 12: Physical Storage Systems Chapter 13: Storage and File Structure Chapter 14: Indexing Chapter 15: Query Processing Chapter 16: Query Optimization Chapter 17: Transactions Chapter 18: Concurrency Control Section 18.8 (Snapshot Isolation), Section 18.9 (Weak Levels of Consistency) may be omitted. Chapter 19: Recovery System Section 19.8 (ARIES) may be omitted. PostgreSQL Cheatsheet (Markdown) This cheatsheet summarizes some essential PostgreSQL commands for managing databases, users, tables, and data. Connection: psql -h <hostname> -p <port> -d <database> -U <username> : Connect to a PostgreSQL server (replace placeholders with actual values). Databases: CREATE DATABASE <database_name> : Create a new database. DROP DATABASE <database_name> : Delete an existing database (use with caution!). \\l : List all databases. \\connect <database_name> : Switch to a different database within the same session. Users and Roles: CREATE ROLE <username> [WITH PASSWORD '<password>'] : Create a new user. GRANT <privilege> ON <object> TO <username> : Grant specific privileges (e.g., SELECT, INSERT, UPDATE, DELETE) on a database object (table, schema) to a user. REVOKE <privilege> ON <object> FROM <username> : Revoke privileges from a user. \\du : List all roles (users). Tables: CREATE TABLE <table_name> ( <column_name> <data_type> [CONSTRAINT], ...); : Create a new table with columns and constraints. DESCRIBE <table_name> : Show the structure of a table. DROP TABLE <table_name> : Delete a table (use with caution!). \\dt : List all tables in the current schema. Data Manipulation: INSERT INTO <table_name> (<column1>, <column2>, ...) VALUES (<value1>, <value2>, ...); : Insert data into a table. SELECT * FROM <table_name> [WHERE <condition>]; : Retrieve data from a table (all columns by default, with optional filtering). UPDATE <table_name> SET <column_name> = <new_value> [WHERE <condition>]; : Update existing data in a table. DELETE FROM <table_name> [WHERE <condition>]; : Delete rows from a table. Other Useful Commands: \\q : Quit the psql client. \\h : Get help on a specific command (e.g., \\h CREATE TABLE ). \\conninfo : Display connection information. Additional Notes: Remember to replace placeholders like <database_name> , <username> , etc. with actual values. This is a basic cheatsheet. PostgreSQL offers many more commands and functionalities. Refer to the official documentation for in-depth details: https://www.postgresql.org/docs/","title":"Welcome to DBMS"},{"location":"#welcome-to-dbms","text":"","title":"Welcome to DBMS"},{"location":"#chapters","text":"Chapter 1: Introduction Chapter 2: Introduction to Relational Languages Chapter 3: Introduction to SQL Chapter 4: Intermediate SQL Chapter 5: Advanced SQL Sections 5.4 onwards may be omitted. Chapter 6: Entity-Relationship Model Chapter 7: Relational Database Design Chapter 8: Complex Data Types Chapter 9: Application Design Chapter 10: Big Data Chapter 11: Data Analytics Chapter 12: Physical Storage Systems Chapter 13: Storage and File Structure Chapter 14: Indexing Chapter 15: Query Processing Chapter 16: Query Optimization Chapter 17: Transactions Chapter 18: Concurrency Control Section 18.8 (Snapshot Isolation), Section 18.9 (Weak Levels of Consistency) may be omitted. Chapter 19: Recovery System Section 19.8 (ARIES) may be omitted.","title":"Chapters"},{"location":"#postgresql-cheatsheet-markdown","text":"This cheatsheet summarizes some essential PostgreSQL commands for managing databases, users, tables, and data. Connection: psql -h <hostname> -p <port> -d <database> -U <username> : Connect to a PostgreSQL server (replace placeholders with actual values). Databases: CREATE DATABASE <database_name> : Create a new database. DROP DATABASE <database_name> : Delete an existing database (use with caution!). \\l : List all databases. \\connect <database_name> : Switch to a different database within the same session. Users and Roles: CREATE ROLE <username> [WITH PASSWORD '<password>'] : Create a new user. GRANT <privilege> ON <object> TO <username> : Grant specific privileges (e.g., SELECT, INSERT, UPDATE, DELETE) on a database object (table, schema) to a user. REVOKE <privilege> ON <object> FROM <username> : Revoke privileges from a user. \\du : List all roles (users). Tables: CREATE TABLE <table_name> ( <column_name> <data_type> [CONSTRAINT], ...); : Create a new table with columns and constraints. DESCRIBE <table_name> : Show the structure of a table. DROP TABLE <table_name> : Delete a table (use with caution!). \\dt : List all tables in the current schema. Data Manipulation: INSERT INTO <table_name> (<column1>, <column2>, ...) VALUES (<value1>, <value2>, ...); : Insert data into a table. SELECT * FROM <table_name> [WHERE <condition>]; : Retrieve data from a table (all columns by default, with optional filtering). UPDATE <table_name> SET <column_name> = <new_value> [WHERE <condition>]; : Update existing data in a table. DELETE FROM <table_name> [WHERE <condition>]; : Delete rows from a table. Other Useful Commands: \\q : Quit the psql client. \\h : Get help on a specific command (e.g., \\h CREATE TABLE ). \\conninfo : Display connection information. Additional Notes: Remember to replace placeholders like <database_name> , <username> , etc. with actual values. This is a basic cheatsheet. PostgreSQL offers many more commands and functionalities. Refer to the official documentation for in-depth details: https://www.postgresql.org/docs/","title":"PostgreSQL Cheatsheet (Markdown)"},{"location":"cheatsheet/","text":"PSQL Magic words: psql -U postgres Some interesting flags (to see all, use -h or --help depending on your psql version): -E : will describe the underlaying queries of the \\ commands (cool for learning!) -l : psql will list all databases and then exit (useful if the user you connect with doesn't has a default database, like at AWS RDS) Most \\d commands support additional param of __schema__.name__ and accept wildcards like *.* \\? : Show help (list of available commands with an explanation) \\q : Quit/Exit \\c __database__ : Connect to a database \\d __table__ : Show table definition (columns, etc.) including triggers \\d+ __table__ : More detailed table definition including description and physical disk size \\l : List databases \\dy : List events \\df : List functions \\di : List indexes \\dn : List schemas \\dt *.* : List tables from all schemas (if *.* is omitted will only show SEARCH_PATH ones) \\dT+ : List all data types \\dv : List views \\dx : List all extensions installed \\df+ __function__ : Show function SQL code. \\x : Pretty-format query results instead of the not-so-useful ASCII tables \\copy (SELECT * FROM __table_name__) TO 'file_path_and_name.csv' WITH CSV : Export a table as CSV \\des+ : List all foreign servers \\dE[S+] : List all foreign tables \\! __bash_command__ : execute __bash_command__ (e.g. \\! ls ) User Related: \\du : List users \\du __username__ : List a username if present. create role __test1__ : Create a role with an existing username. create role __test2__ noinherit login password __passsword__; : Create a role with username and password. set role __test__; : Change role for current session to __test__ . grant __test2__ to __test1__; : Allow __test1__ to set its role as __test2__ . \\deu+ : List all user mapping on server Create command There are many CREATE choices, like CREATE DATABASE __database_name__ , CREATE TABLE __table_name__ ... Parameters differ but can be checked at the official documentation . Handy queries SELECT * FROM pg_proc WHERE proname='__procedurename__' : List procedure/function SELECT * FROM pg_views WHERE viewname='__viewname__'; : List view (including the definition) SELECT pg_size_pretty(pg_total_relation_size('__table_name__')); : Show DB table space in use SELECT pg_size_pretty(pg_database_size('__database_name__')); : Show DB space in use show statement_timeout; : Show current user's statement timeout SELECT * FROM pg_indexes WHERE tablename='__table_name__' AND schemaname='__schema_name__'; : Show table indexes Get all indexes from all tables of a schema: SELECT t . relname AS table_name , i . relname AS index_name , a . attname AS column_name FROM pg_class t , pg_class i , pg_index ix , pg_attribute a , pg_namespace n WHERE t . oid = ix . indrelid AND i . oid = ix . indexrelid AND a . attrelid = t . oid AND a . attnum = ANY ( ix . indkey ) AND t . relnamespace = n . oid AND n . nspname = 'kartones' ORDER BY t . relname , i . relname Execution data: Queries being executed at a certain DB: SELECT datname , application_name , pid , backend_start , query_start , state_change , state , query FROM pg_stat_activity WHERE datname = '__database_name__' ; Get all queries from all dbs waiting for data (might be hung): SELECT * FROM pg_stat_activity WHERE waiting = 't' Currently running queries with process pid: SELECT pg_stat_get_backend_pid ( s . backendid ) AS procpid , pg_stat_get_backend_activity ( s . backendid ) AS current_query FROM ( SELECT pg_stat_get_backend_idset () AS backendid ) AS s ; Get Connections by Database: SELECT datname, numbackends FROM pg_stat_database; Casting: CAST (column AS type) or column::type '__table_name__'::regclass::oid : Get oid having a table name Query analysis: EXPLAIN __query__ : see the query plan for the given query EXPLAIN ANALYZE __query__ : see and execute the query plan for the given query ANALYZE [__table__] : collect statistics Generating random data ( source ): INSERT INTO some_table (a_float_value) SELECT random() * 100000 FROM generate_series(1, 1000000) i; Get sizes of tables, indexes and full DBs: select current_database () as database , pg_size_pretty ( total_database_size ) as total_database_size , schema_name , table_name , pg_size_pretty ( total_table_size ) as total_table_size , pg_size_pretty ( table_size ) as table_size , pg_size_pretty ( index_size ) as index_size from ( select table_name , table_schema as schema_name , pg_database_size ( current_database ()) as total_database_size , pg_total_relation_size ( table_name ) as total_table_size , pg_relation_size ( table_name ) as table_size , pg_indexes_size ( table_name ) as index_size from information_schema . tables where table_schema = current_schema () and table_name like 'table_%' order by total_table_size ) as sizes ; COPY command : Import/export from CSV to tables: COPY table_name [ ( column_name [, ...] ) ] FROM { 'filename' | STDIN } [ [ WITH ] ( option [, ...] ) ] COPY { table_name [ ( column_name [, ...] ) ] | ( query ) } TO { 'filename' | STDOUT } [ [ WITH ] ( option [, ...] ) ] List all grants for a specific user SELECT table_catalog , table_schema , table_name , privilege_type FROM information_schema . table_privileges WHERE grantee = 'user_to_check' ORDER BY table_name ; List all assigned user roles SELECT r . rolname , r . rolsuper , r . rolinherit , r . rolcreaterole , r . rolcreatedb , r . rolcanlogin , r . rolconnlimit , r . rolvaliduntil , ARRAY ( SELECT b . rolname FROM pg_catalog . pg_auth_members m JOIN pg_catalog . pg_roles b ON ( m . roleid = b . oid ) WHERE m . member = r . oid ) as memberof , r . rolreplication FROM pg_catalog . pg_roles r ORDER BY 1 ; Check permissions in a table: SELECT grantee , privilege_type FROM information_schema . role_table_grants WHERE table_name = 'name-of-the-table' ; Kill all Connections: SELECT pg_terminate_backend ( pg_stat_activity . pid ) FROM pg_stat_activity WHERE datname = current_database () AND pid <> pg_backend_pid (); Keyboard shortcuts CTRL + R : reverse-i-search Tools ptop and pg_top : top for PG. Available on the APT repository from apt.postgresql.org . pg_activity : Command line tool for PostgreSQL server activity monitoring. Unix-like reverse search in psql : $ echo \"bind \" ^R \" em-inc-search-prev\" > $HOME /.editrc $ source $HOME /.editrc Show IP of the DB Instance: SELECT inet_server_addr(); File to save PostgreSQL credentials and permissions (format: hostname:port:database:username:password ): chmod 600 ~/.pgpass Collect statistics of a database (useful to improve speed after a Database Upgrade as previous query plans are deleted): ANALYZE VERBOSE; To obtain the CREATE TABLE query of a table, any visual GUI like pgAdmin allows to easily, but else you can use pg_dump , e.g.: pg_dump -t '<schema>.<table>' --schema-only <database> ( source ) Resources & Documentation Operations Cheat Sheet : Official PG wiki cheat sheet with an amazing amount of explanations of many topics, features, and many many internal implementation details Postgres Weekly newsletter: The best way IMHO to keep up to date with PG news 100 psql Tips : Name says all, lots of useful tips! PostgreSQL Exercises : An awesome resource to learn to learn SQL, teaching you with simple examples in a great visual way. Highly recommended . A Performance Cheat Sheet for PostgreSQL : Great explanations of EXPLAIN , EXPLAIN ANALYZE , VACUUM , configuration parameters and more. Quite interesting if you need to tune-up a postgres setup. annotated.conf : Annotations of all 269 postgresql.conf settings for PostgreSQL 10. psql -c \"\\l+\" -H -q postgres > out.html : Generate a html report of your databases (source: Daniel Westermann ) </pre>","title":"Cheatsheet"},{"location":"cheatsheet/#psql","text":"Magic words: psql -U postgres Some interesting flags (to see all, use -h or --help depending on your psql version): -E : will describe the underlaying queries of the \\ commands (cool for learning!) -l : psql will list all databases and then exit (useful if the user you connect with doesn't has a default database, like at AWS RDS) Most \\d commands support additional param of __schema__.name__ and accept wildcards like *.* \\? : Show help (list of available commands with an explanation) \\q : Quit/Exit \\c __database__ : Connect to a database \\d __table__ : Show table definition (columns, etc.) including triggers \\d+ __table__ : More detailed table definition including description and physical disk size \\l : List databases \\dy : List events \\df : List functions \\di : List indexes \\dn : List schemas \\dt *.* : List tables from all schemas (if *.* is omitted will only show SEARCH_PATH ones) \\dT+ : List all data types \\dv : List views \\dx : List all extensions installed \\df+ __function__ : Show function SQL code. \\x : Pretty-format query results instead of the not-so-useful ASCII tables \\copy (SELECT * FROM __table_name__) TO 'file_path_and_name.csv' WITH CSV : Export a table as CSV \\des+ : List all foreign servers \\dE[S+] : List all foreign tables \\! __bash_command__ : execute __bash_command__ (e.g. \\! ls ) User Related: \\du : List users \\du __username__ : List a username if present. create role __test1__ : Create a role with an existing username. create role __test2__ noinherit login password __passsword__; : Create a role with username and password. set role __test__; : Change role for current session to __test__ . grant __test2__ to __test1__; : Allow __test1__ to set its role as __test2__ . \\deu+ : List all user mapping on server","title":"PSQL"},{"location":"cheatsheet/#create-command","text":"There are many CREATE choices, like CREATE DATABASE __database_name__ , CREATE TABLE __table_name__ ... Parameters differ but can be checked at the official documentation .","title":"Create command"},{"location":"cheatsheet/#handy-queries","text":"SELECT * FROM pg_proc WHERE proname='__procedurename__' : List procedure/function SELECT * FROM pg_views WHERE viewname='__viewname__'; : List view (including the definition) SELECT pg_size_pretty(pg_total_relation_size('__table_name__')); : Show DB table space in use SELECT pg_size_pretty(pg_database_size('__database_name__')); : Show DB space in use show statement_timeout; : Show current user's statement timeout SELECT * FROM pg_indexes WHERE tablename='__table_name__' AND schemaname='__schema_name__'; : Show table indexes Get all indexes from all tables of a schema: SELECT t . relname AS table_name , i . relname AS index_name , a . attname AS column_name FROM pg_class t , pg_class i , pg_index ix , pg_attribute a , pg_namespace n WHERE t . oid = ix . indrelid AND i . oid = ix . indexrelid AND a . attrelid = t . oid AND a . attnum = ANY ( ix . indkey ) AND t . relnamespace = n . oid AND n . nspname = 'kartones' ORDER BY t . relname , i . relname Execution data: Queries being executed at a certain DB: SELECT datname , application_name , pid , backend_start , query_start , state_change , state , query FROM pg_stat_activity WHERE datname = '__database_name__' ; Get all queries from all dbs waiting for data (might be hung): SELECT * FROM pg_stat_activity WHERE waiting = 't' Currently running queries with process pid: SELECT pg_stat_get_backend_pid ( s . backendid ) AS procpid , pg_stat_get_backend_activity ( s . backendid ) AS current_query FROM ( SELECT pg_stat_get_backend_idset () AS backendid ) AS s ; Get Connections by Database: SELECT datname, numbackends FROM pg_stat_database; Casting: CAST (column AS type) or column::type '__table_name__'::regclass::oid : Get oid having a table name Query analysis: EXPLAIN __query__ : see the query plan for the given query EXPLAIN ANALYZE __query__ : see and execute the query plan for the given query ANALYZE [__table__] : collect statistics Generating random data ( source ): INSERT INTO some_table (a_float_value) SELECT random() * 100000 FROM generate_series(1, 1000000) i; Get sizes of tables, indexes and full DBs: select current_database () as database , pg_size_pretty ( total_database_size ) as total_database_size , schema_name , table_name , pg_size_pretty ( total_table_size ) as total_table_size , pg_size_pretty ( table_size ) as table_size , pg_size_pretty ( index_size ) as index_size from ( select table_name , table_schema as schema_name , pg_database_size ( current_database ()) as total_database_size , pg_total_relation_size ( table_name ) as total_table_size , pg_relation_size ( table_name ) as table_size , pg_indexes_size ( table_name ) as index_size from information_schema . tables where table_schema = current_schema () and table_name like 'table_%' order by total_table_size ) as sizes ; COPY command : Import/export from CSV to tables: COPY table_name [ ( column_name [, ...] ) ] FROM { 'filename' | STDIN } [ [ WITH ] ( option [, ...] ) ] COPY { table_name [ ( column_name [, ...] ) ] | ( query ) } TO { 'filename' | STDOUT } [ [ WITH ] ( option [, ...] ) ] List all grants for a specific user SELECT table_catalog , table_schema , table_name , privilege_type FROM information_schema . table_privileges WHERE grantee = 'user_to_check' ORDER BY table_name ; List all assigned user roles SELECT r . rolname , r . rolsuper , r . rolinherit , r . rolcreaterole , r . rolcreatedb , r . rolcanlogin , r . rolconnlimit , r . rolvaliduntil , ARRAY ( SELECT b . rolname FROM pg_catalog . pg_auth_members m JOIN pg_catalog . pg_roles b ON ( m . roleid = b . oid ) WHERE m . member = r . oid ) as memberof , r . rolreplication FROM pg_catalog . pg_roles r ORDER BY 1 ; Check permissions in a table: SELECT grantee , privilege_type FROM information_schema . role_table_grants WHERE table_name = 'name-of-the-table' ; Kill all Connections: SELECT pg_terminate_backend ( pg_stat_activity . pid ) FROM pg_stat_activity WHERE datname = current_database () AND pid <> pg_backend_pid ();","title":"Handy queries"},{"location":"cheatsheet/#keyboard-shortcuts","text":"CTRL + R : reverse-i-search","title":"Keyboard shortcuts"},{"location":"cheatsheet/#tools","text":"ptop and pg_top : top for PG. Available on the APT repository from apt.postgresql.org . pg_activity : Command line tool for PostgreSQL server activity monitoring. Unix-like reverse search in psql : $ echo \"bind \" ^R \" em-inc-search-prev\" > $HOME /.editrc $ source $HOME /.editrc Show IP of the DB Instance: SELECT inet_server_addr(); File to save PostgreSQL credentials and permissions (format: hostname:port:database:username:password ): chmod 600 ~/.pgpass Collect statistics of a database (useful to improve speed after a Database Upgrade as previous query plans are deleted): ANALYZE VERBOSE; To obtain the CREATE TABLE query of a table, any visual GUI like pgAdmin allows to easily, but else you can use pg_dump , e.g.: pg_dump -t '<schema>.<table>' --schema-only <database> ( source )","title":"Tools"},{"location":"cheatsheet/#resources-documentation","text":"Operations Cheat Sheet : Official PG wiki cheat sheet with an amazing amount of explanations of many topics, features, and many many internal implementation details Postgres Weekly newsletter: The best way IMHO to keep up to date with PG news 100 psql Tips : Name says all, lots of useful tips! PostgreSQL Exercises : An awesome resource to learn to learn SQL, teaching you with simple examples in a great visual way. Highly recommended . A Performance Cheat Sheet for PostgreSQL : Great explanations of EXPLAIN , EXPLAIN ANALYZE , VACUUM , configuration parameters and more. Quite interesting if you need to tune-up a postgres setup. annotated.conf : Annotations of all 269 postgresql.conf settings for PostgreSQL 10. psql -c \"\\l+\" -H -q postgres > out.html : Generate a html report of your databases (source: Daniel Westermann ) </pre>","title":"Resources &amp; Documentation"},{"location":"Piyush%20Wairale/ER_model/","text":"Entity Relationship Model Entity. Strong Entity weak Entity Attributes. key attributes partial key attribute multi valued attribute derived composite attributes Relationship. one to one one to many many to one many to many Entity Entity: Distinguishable objects in the real world (e.g., student, car). entity is represented by a set of attributes Student entity will have Name attribute age attribute Roll_no attribute etc Entity Set: A set of entities with the same attributes (e.g., all students) Relationship: A relationship is a assosication among several entities.","title":"Entity Relationship Model"},{"location":"Piyush%20Wairale/ER_model/#entity-relationship-model","text":"Entity. Strong Entity weak Entity Attributes. key attributes partial key attribute multi valued attribute derived composite attributes Relationship. one to one one to many many to one many to many","title":"Entity Relationship Model"},{"location":"Piyush%20Wairale/ER_model/#entity","text":"Entity: Distinguishable objects in the real world (e.g., student, car). entity is represented by a set of attributes Student entity will have Name attribute age attribute Roll_no attribute etc Entity Set: A set of entities with the same attributes (e.g., all students) Relationship: A relationship is a assosication among several entities.","title":"Entity"},{"location":"Piyush%20Wairale/checklist/","text":"[ ] Lecture: 01 | Database Management & Warehousing | GATE Data Science & AI #gate2024 #datascience [ ] Lecture: 02 | Database Management & Warehousing | GATE Data Science & AI #gate2024 #datascience [X] Lecture: 03- Intro to ER Model| Database Management & Warehousing | GATE Data Science & AI #gate2024 [X] Lecture: 04- Previous Year Questions | Database Management & Warehousing | GATE Data Science & AI [X] Lecture: 05- ER Model | Database Management & Warehousing | GATE Data Science & AI #gate2024 [X] Lecture: 06- ER Model | Database Management & Warehousing | GATE Data Science & AI #gate2024 [ ] Relational Algebra | Database Management & Warehousing | GATE Data Science & AI | Lec : 07 [ ] Tutorial: Relational Algebra | Database Management & Warehousing | GATE Data Science & AI | [ ] Relational Algebra-Part 2| Database Management & Warehousing | GATE Data Science & AI | Lec : 08 [ ] Relational Algebra-Part 3| Database Management & Warehousing | GATE Data Science & AI | Lec : 09 [ ] Tuple Relational Calculus | DBMS | GATE DA [ ] Intro to SQL | Database Management & Warehousing | GATE Data Science & AI #gate2024 [ ] Datatypes and Constraints | Database Management & Warehousing | GATE Data Science & AI #gate2024 [ ] Tutorial: Datatype and Constraints Example | Database Management & Warehousing | GATE DA [ ] SQL command part 1 | Database Management & Warehousing | GATE Data Science & AI #gate2024 [ ] SQL command part 2 | Database Management & Warehousing | GATE Data Science & AI #gate2024 [ ] SQL: SELECT Command |Database Management & Warehousing | GATE Data Science & AI #gate2024 [ ] Functional Dependency | DBMS and Warehousing | GATE Data Science & AI [ ] PYQ: SQL, Relational Algebra & Calculus | Database Management & Warehousing | GATE DA #gate2025 [ ] Lec 01: Intro to Data Warehouse | Database Management & Warehousing | GATE DA #gate2025 [ ] Lecture 02: What is Data Warehouse | Database Management & Warehousing | GATE DA #gate2025 [ ] Normalization | Database Management & Warehousing | GATE DA PYQ #gate2025 | GATE Data Science [ ] Lecture 03: Data Warehouse, Data Lake and Data LakeHouse |Database Management & Warehousing| GATE DA","title":"Checklist"},{"location":"Week%205/Lecture%205.1%20-%20Relational%20Database%20Design1/","text":"Lecture 5.1 - Relational Database Design1 Summary This module focuses on principles of relational database design. It emphasizes: Features of Good Design: Reflects real-world structure Accommodates future data additions Avoids redundancy Provides efficient data access Maintains data integrity Redundancy and Anomaly: Redundancy (duplicate data) leads to anomalies: Insertion: Can't add data if unknown data is required Deletion: Losing unrelated information when deleting records Update: Inaccurate changes due to multiple occurrences of data Decomposition: Decomposing relations into smaller ones removes redundancy and minimizes dependencies among attributes. Good decomposition ensures data preservation and integrity. functional dependency : dept name \u2192 building, budget In inst_dept, because dept_name is not a candidate key, the building and budget of a department may have to be repeated. \u25e6 This indicates the need to decompose inst dept Lossy Decomposition Lossless Join Decomposition is a decomposition of a relation R into relations R1 , R2 such that if we perform natural join of two smaller relations it will return the original relation Atomic Domains and First Normal Form (1NF): Atomic domains consist of indivisible elements. 1NF requires relations with atomic domains and each attribute holding a single value. Non-atomic values complicate storage and encourage redundancy. Atomic Domains An atomic domain refers to the indivisibility of data within a domain. In the context of databases, it means that the value in a particular field is indivisible and represents the smallest unit of data. Each attribute in a table should contain atomic (indivisible) values. Example of Atomic Values : 123 Main St , John Doe , 01/01/2020 Example of Non-Atomic Values : 123 Main St, Apt 4 (multiple pieces of information in one field) John and Jane Doe (multiple names in one field) First Normal Form (1NF) A relation (table) is said to be in the First Normal Form (1NF) if it satisfies the following conditions: Atomicity : All the values in the database are atomic (indivisible). Uniqueness of Rows : Each row in the table must be unique, meaning no two rows can be identical. Uniqueness of Column Names : Each column should have a unique name. No Repeating Groups : Each table should contain only one value per cell (intersection of a row and a column), and columns should not contain sets or lists of values. Examples of 1NF Non-1NF Table: StudentID Name Courses 1 John Doe Math, Science 2 Jane Smith English, History, Math In the above table: The Courses column contains multiple values, which violates the atomicity rule. 1NF Table: StudentID Name Course 1 John Doe Math 1 John Doe Science 2 Jane Smith English 2 Jane Smith History 2 Jane Smith Math In this 1NF table: Each cell contains only one value, adhering to the atomicity requirement. Each row is unique, and there are no repeating groups within any cell. Achieving 1NF To transform a table into 1NF: Remove Repeating Groups : Ensure that each column contains only a single value. Create Separate Tables for Multivalued Attributes : If necessary, split the multivalued attributes into separate rows or tables. Ensure Primary Keys : Define primary keys to uniquely identify each row in the table. By adhering to these principles, a database can be designed to comply with the First Normal Form, thus ensuring data integrity and facilitating easier querying and maintenance.","title":"Lecture 5.1 - Relational Database Design1"},{"location":"Week%205/Lecture%205.1%20-%20Relational%20Database%20Design1/#lecture-51-relational-database-design1","text":"Summary This module focuses on principles of relational database design. It emphasizes: Features of Good Design: Reflects real-world structure Accommodates future data additions Avoids redundancy Provides efficient data access Maintains data integrity Redundancy and Anomaly: Redundancy (duplicate data) leads to anomalies: Insertion: Can't add data if unknown data is required Deletion: Losing unrelated information when deleting records Update: Inaccurate changes due to multiple occurrences of data Decomposition: Decomposing relations into smaller ones removes redundancy and minimizes dependencies among attributes. Good decomposition ensures data preservation and integrity. functional dependency : dept name \u2192 building, budget In inst_dept, because dept_name is not a candidate key, the building and budget of a department may have to be repeated. \u25e6 This indicates the need to decompose inst dept Lossy Decomposition Lossless Join Decomposition is a decomposition of a relation R into relations R1 , R2 such that if we perform natural join of two smaller relations it will return the original relation Atomic Domains and First Normal Form (1NF): Atomic domains consist of indivisible elements. 1NF requires relations with atomic domains and each attribute holding a single value. Non-atomic values complicate storage and encourage redundancy. Atomic Domains An atomic domain refers to the indivisibility of data within a domain. In the context of databases, it means that the value in a particular field is indivisible and represents the smallest unit of data. Each attribute in a table should contain atomic (indivisible) values. Example of Atomic Values : 123 Main St , John Doe , 01/01/2020 Example of Non-Atomic Values : 123 Main St, Apt 4 (multiple pieces of information in one field) John and Jane Doe (multiple names in one field)","title":"Lecture 5.1 - Relational Database Design1"},{"location":"Week%205/Lecture%205.1%20-%20Relational%20Database%20Design1/#first-normal-form-1nf","text":"A relation (table) is said to be in the First Normal Form (1NF) if it satisfies the following conditions: Atomicity : All the values in the database are atomic (indivisible). Uniqueness of Rows : Each row in the table must be unique, meaning no two rows can be identical. Uniqueness of Column Names : Each column should have a unique name. No Repeating Groups : Each table should contain only one value per cell (intersection of a row and a column), and columns should not contain sets or lists of values.","title":"First Normal Form (1NF)"},{"location":"Week%205/Lecture%205.1%20-%20Relational%20Database%20Design1/#examples-of-1nf","text":"Non-1NF Table: StudentID Name Courses 1 John Doe Math, Science 2 Jane Smith English, History, Math In the above table: The Courses column contains multiple values, which violates the atomicity rule. 1NF Table: StudentID Name Course 1 John Doe Math 1 John Doe Science 2 Jane Smith English 2 Jane Smith History 2 Jane Smith Math In this 1NF table: Each cell contains only one value, adhering to the atomicity requirement. Each row is unique, and there are no repeating groups within any cell.","title":"Examples of 1NF"},{"location":"Week%205/Lecture%205.1%20-%20Relational%20Database%20Design1/#achieving-1nf","text":"To transform a table into 1NF: Remove Repeating Groups : Ensure that each column contains only a single value. Create Separate Tables for Multivalued Attributes : If necessary, split the multivalued attributes into separate rows or tables. Ensure Primary Keys : Define primary keys to uniquely identify each row in the table. By adhering to these principles, a database can be designed to comply with the First Normal Form, thus ensuring data integrity and facilitating easier querying and maintenance.","title":"Achieving 1NF"},{"location":"Week%205/Lecture%205.2%20-%20Relational%20Database%20Design2/","text":"Lecture 5.2: Relational Database Design Functional Dependencies Definition Constraints on the set of legal relations. Require that the value for a certain set of attributes determines uniquely the value for another set of attributes. A generalization of the notion of a key. Formal Definition For a relation schema ( R ), ( \\(\\\\alpha \\\\subseteq R\\) ) and ( $\\beta \\subseteq R $). The functional dependency ( $\\alpha \\to \\beta $) holds on ( R ) if for any legal relations ( r(R) ), whenever any two tuples ( \\(t_1\\) ) and ( \\(t_2\\) ) of ( \\(r\\) ) agree on the attributes ( $ \\alpha $ ), they also agree on the attributes ( \\(\\\\beta\\) ). Example: ( \\(A \\\\to B\\) ) does not hold, but ( \\(B \\\\to A\\) ) holds for a certain instance. Keys Superkey: ( \\(K\\) ) is a superkey for relation schema ( \\(R\\) ) if and only if ($ K \\to R \\ $). Candidate Key: ( K ) is a candidate key for ( R ) if and only if ( \\(K \\\\to R\\) ) and for no ($\\alpha \\subset K $), ( $\\alpha \\to R $). Practical Examples Schema: inst_dept(ID, name, salary, dept_name, building, budget) Expected FDs: dept_name \u2192 building dept_name \u2192 budget ID \u2192 budget Unexpected FD: dept_name \u2192 salary Trivial Functional Dependencies A functional dependency is trivial if it is satisfied by all instances of a relation. Example: ( $\\text{ID, name} \\to \\text{ID} $) and ( $\\text{name} \\to \\text{name} $). Generally, ( $\\alpha \\to \\beta $ ) is trivial if ( $\\beta \\subseteq \\alpha $). Armstrong\u2019s Axioms Definition Given a set of FDs ( F ), infer new dependencies using: Reflexivity: If ( \\(\\\\beta \\\\subseteq \\\\alpha\\) ), then ( \\alpha \\to \\beta ). Augmentation: If ( $\\alpha \\to \\beta $ ), then ( $\\gamma\\alpha \\to \\gamma\\beta $). Transitivity: If ( $\\alpha \\to \\beta $) and ( $\\beta \\to \\gamma $), then ( $\\alpha \\to \\gamma $). Closure The closure of a set of FDs ( \\(F\\) ) is the set ( $F^+ $) of all FDs logically implied by ( F ). Example: ( \\(F = { A \\\\to B, B \\\\to C }\\) ) ( $F^+ = { A \\to B, B \\to C, A \\to C } $) Properties Axioms are sound (generate only FDs that hold) and complete (generate all FDs that hold). Module Summary Introduced the notion of Functional Dependencies. Explained Armstrong\u2019s Axioms and their application to infer new FDs. Discussed the concept of the closure of a set of FDs.","title":"Lecture 5.2: Relational Database Design"},{"location":"Week%205/Lecture%205.2%20-%20Relational%20Database%20Design2/#lecture-52-relational-database-design","text":"","title":"Lecture 5.2: Relational Database Design"},{"location":"Week%205/Lecture%205.2%20-%20Relational%20Database%20Design2/#functional-dependencies","text":"","title":"Functional Dependencies"},{"location":"Week%205/Lecture%205.2%20-%20Relational%20Database%20Design2/#definition","text":"Constraints on the set of legal relations. Require that the value for a certain set of attributes determines uniquely the value for another set of attributes. A generalization of the notion of a key.","title":"Definition"},{"location":"Week%205/Lecture%205.2%20-%20Relational%20Database%20Design2/#formal-definition","text":"For a relation schema ( R ), ( \\(\\\\alpha \\\\subseteq R\\) ) and ( $\\beta \\subseteq R $). The functional dependency ( $\\alpha \\to \\beta $) holds on ( R ) if for any legal relations ( r(R) ), whenever any two tuples ( \\(t_1\\) ) and ( \\(t_2\\) ) of ( \\(r\\) ) agree on the attributes ( $ \\alpha $ ), they also agree on the attributes ( \\(\\\\beta\\) ). Example: ( \\(A \\\\to B\\) ) does not hold, but ( \\(B \\\\to A\\) ) holds for a certain instance.","title":"Formal Definition"},{"location":"Week%205/Lecture%205.2%20-%20Relational%20Database%20Design2/#keys","text":"Superkey: ( \\(K\\) ) is a superkey for relation schema ( \\(R\\) ) if and only if ($ K \\to R \\ $). Candidate Key: ( K ) is a candidate key for ( R ) if and only if ( \\(K \\\\to R\\) ) and for no ($\\alpha \\subset K $), ( $\\alpha \\to R $).","title":"Keys"},{"location":"Week%205/Lecture%205.2%20-%20Relational%20Database%20Design2/#practical-examples","text":"Schema: inst_dept(ID, name, salary, dept_name, building, budget) Expected FDs: dept_name \u2192 building dept_name \u2192 budget ID \u2192 budget Unexpected FD: dept_name \u2192 salary","title":"Practical Examples"},{"location":"Week%205/Lecture%205.2%20-%20Relational%20Database%20Design2/#trivial-functional-dependencies","text":"A functional dependency is trivial if it is satisfied by all instances of a relation. Example: ( $\\text{ID, name} \\to \\text{ID} $) and ( $\\text{name} \\to \\text{name} $). Generally, ( $\\alpha \\to \\beta $ ) is trivial if ( $\\beta \\subseteq \\alpha $).","title":"Trivial Functional Dependencies"},{"location":"Week%205/Lecture%205.2%20-%20Relational%20Database%20Design2/#armstrongs-axioms","text":"","title":"Armstrong\u2019s Axioms"},{"location":"Week%205/Lecture%205.2%20-%20Relational%20Database%20Design2/#definition_1","text":"Given a set of FDs ( F ), infer new dependencies using: Reflexivity: If ( \\(\\\\beta \\\\subseteq \\\\alpha\\) ), then ( \\alpha \\to \\beta ). Augmentation: If ( $\\alpha \\to \\beta $ ), then ( $\\gamma\\alpha \\to \\gamma\\beta $). Transitivity: If ( $\\alpha \\to \\beta $) and ( $\\beta \\to \\gamma $), then ( $\\alpha \\to \\gamma $).","title":"Definition"},{"location":"Week%205/Lecture%205.2%20-%20Relational%20Database%20Design2/#closure","text":"The closure of a set of FDs ( \\(F\\) ) is the set ( $F^+ $) of all FDs logically implied by ( F ). Example: ( \\(F = { A \\\\to B, B \\\\to C }\\) ) ( $F^+ = { A \\to B, B \\to C, A \\to C } $)","title":"Closure"},{"location":"Week%205/Lecture%205.2%20-%20Relational%20Database%20Design2/#properties","text":"Axioms are sound (generate only FDs that hold) and complete (generate all FDs that hold).","title":"Properties"},{"location":"Week%205/Lecture%205.2%20-%20Relational%20Database%20Design2/#module-summary","text":"Introduced the notion of Functional Dependencies. Explained Armstrong\u2019s Axioms and their application to infer new FDs. Discussed the concept of the closure of a set of FDs.","title":"Module Summary"},{"location":"Week%205/Lecture%205.3%20-%20Relational%20Database%20Design3/","text":"Lecture 5.3 - Relational Database Design 3 Summary This module discusses relational database design using functional dependencies (FDs). FD Theory: Armstrong's Axioms are used to derive new FDs from a given set. Closure of FDs generates all FDs logically implied by a set. Closure of attributes determines the attributes functionally determined by a set of attributes. Decomposition Using FDs: Boyce-Codd Normal Form (BCNF) ensures that non-trivial FDs involve superkeys or attributes in candidate keys. Decomposing relations into BCNF guarantees lossless join but may not preserve dependencies. 3NF (Third Normal Form): Relaxes BCNF by allowing attributes in candidate keys but enforces dependency preservation. Normalization Goals: Evaluate relation schemes for \"good\" form. Decompose schemes into lossless-join and dependency-preserving relations. Problems with Decomposition: Potential lossiness, dependency checking issues, and query performance concerns exist. Limitations of BCNF: BCNF may not prevent insertion anomalies in certain scenarios, suggesting the need for higher normal forms like 4NF.","title":"Lecture 5.3 - Relational Database Design 3"},{"location":"Week%205/Lecture%205.3%20-%20Relational%20Database%20Design3/#lecture-53-relational-database-design-3","text":"Summary This module discusses relational database design using functional dependencies (FDs). FD Theory: Armstrong's Axioms are used to derive new FDs from a given set. Closure of FDs generates all FDs logically implied by a set. Closure of attributes determines the attributes functionally determined by a set of attributes. Decomposition Using FDs: Boyce-Codd Normal Form (BCNF) ensures that non-trivial FDs involve superkeys or attributes in candidate keys. Decomposing relations into BCNF guarantees lossless join but may not preserve dependencies. 3NF (Third Normal Form): Relaxes BCNF by allowing attributes in candidate keys but enforces dependency preservation. Normalization Goals: Evaluate relation schemes for \"good\" form. Decompose schemes into lossless-join and dependency-preserving relations. Problems with Decomposition: Potential lossiness, dependency checking issues, and query performance concerns exist. Limitations of BCNF: BCNF may not prevent insertion anomalies in certain scenarios, suggesting the need for higher normal forms like 4NF.","title":"Lecture 5.3 - Relational Database Design 3"},{"location":"Week%205/Lecture%205.4%20-%20Relational%20Database%20Design4/","text":"Lecture 5.4 - Relational Database Design Summary This module covers algorithms and properties related to functional dependencies (FDs). Attribute Set Closure: Algorithm to find the closure of an attribute set, which includes the set itself and all attributes implied by FDs. Used to test if an attribute set is a superkey or to test functional dependencies. Extraneous Attributes: Algorithms to identify and remove extraneous attributes, which are redundant in FDs. Helps optimize the set of FDs by eliminating unnecessary dependencies. Equivalence of FD Sets: Two sets of FDs are equivalent if they logically imply each other's dependencies. Useful for comparing different representations of functional dependencies. Canonical Cover: Algorithm to find a minimal and unique set of FDs that represent a given set of FDs. Ensures that there are no redundant or extraneous dependencies. The canonical cover is often used as a \"normalized\" representation of functional dependencies. Practice Problems: Exercises to test understanding of the algorithms and concepts discussed. Cover tasks like checking FD implications, finding super and candidate keys, and computing canonical covers.","title":"Lecture 5.4 - Relational Database Design"},{"location":"Week%205/Lecture%205.4%20-%20Relational%20Database%20Design4/#lecture-54-relational-database-design","text":"Summary This module covers algorithms and properties related to functional dependencies (FDs). Attribute Set Closure: Algorithm to find the closure of an attribute set, which includes the set itself and all attributes implied by FDs. Used to test if an attribute set is a superkey or to test functional dependencies. Extraneous Attributes: Algorithms to identify and remove extraneous attributes, which are redundant in FDs. Helps optimize the set of FDs by eliminating unnecessary dependencies. Equivalence of FD Sets: Two sets of FDs are equivalent if they logically imply each other's dependencies. Useful for comparing different representations of functional dependencies. Canonical Cover: Algorithm to find a minimal and unique set of FDs that represent a given set of FDs. Ensures that there are no redundant or extraneous dependencies. The canonical cover is often used as a \"normalized\" representation of functional dependencies. Practice Problems: Exercises to test understanding of the algorithms and concepts discussed. Cover tasks like checking FD implications, finding super and candidate keys, and computing canonical covers.","title":"Lecture 5.4 - Relational Database Design"},{"location":"Week%205/Lecture%205.5%20-%20Relational%20Database%20Design5/","text":"Lecture 5.5 - Relational Database Design5.pdf (PDF file) Summary Relational Database Design Lossless Join Decomposition A decomposition of a relation R into R1 and R2 is lossless if either R1 \u2229 R2 \u2192 R1 or R1 \u2229 R2 \u2192 R2 is in the set of functional dependencies (FDs) for R. This condition ensures that the original relation can be reconstructed by joining R1 and R2. Dependency Preservation A decomposition of R into D = {R1, R2, ..., Rn} is dependency preserving if (F1 \u222a F2 \u222a ... \u222a Fn) = F, where: Fi is the set of FDs including attributes only in Ri This ensures that all FDs in F are preserved in the decomposition. Testing Dependency Preservation Test if a dependency \u03b1 \u2192 \u03b2 is preserved by: Computing F0 = F1 \u222a F2 \u222a ... \u222a Fn Check if \u03b2 is in the attribute closure of \u03b1 with respect to F0 Practice Problems Lossless Join Decomposition Determine if the following decompositions are lossless: R(ABC) : F = {A \u2192 B, A \u2192 C} \u2192 {R1(AB), R2(BC)} R(ABCDEF) : F = {A \u2192 B, B \u2192 C, C \u2192 D, E \u2192 F} \u2192 {R1(AB), R2(BCD), R3(DEF)} R(ABCDEF) : F = {A \u2192 B, C \u2192 DE, AC \u2192 F} \u2192 {R1(BE), R2(ACDEF)} R(ABCDEG) : F = {AB \u2192 C, AC \u2192 B, AD \u2192 E, B \u2192 D, BC \u2192 A, E \u2192 G} \u2192 {R1(AB), R2(BC), R3(ABDE), R4(EG)} R(ABCDEFGHIJ) : F = {AB \u2192 C, B \u2192 F, D \u2192 IJ, A \u2192 DE, F \u2192 GH} \u2192 {R1(ABC), R2(ADE), R3(BF), R4(FGH), R5(DIJ)} Dependency Preservation Verify if the following decompositions preserve dependencies: R(ABCD) : F = {A \u2192 B, B \u2192 C, C \u2192 D, D \u2192 A} \u2192 {AB, BC, CD} R(ABCDEF) : F = {AB \u2192 CD, C \u2192 D, D \u2192 E, E \u2192 F} \u2192 {AB, CDE, EF} R(ABCDEG) : F = {AB \u2192 C, AC \u2192 B, BC \u2192 A, AD \u2192 E, B \u2192 D, E \u2192 G} \u2192 {ABC, ACDE, ADG} R(ABCD) : F = {A \u2192 B, B \u2192 C, C \u2192 D, D \u2192 B} \u2192 {AB, BC, BD} R(ABCDE) : F = {A \u2192 BC, CD \u2192 E, B \u2192 D, E \u2192 A} \u2192 {ABCE, BD}","title":"Lecture 5.5 - Relational Database Design5.pdf (PDF file)"},{"location":"Week%205/Lecture%205.5%20-%20Relational%20Database%20Design5/#lecture-55-relational-database-design5pdf-pdf-file","text":"Summary Relational Database Design Lossless Join Decomposition A decomposition of a relation R into R1 and R2 is lossless if either R1 \u2229 R2 \u2192 R1 or R1 \u2229 R2 \u2192 R2 is in the set of functional dependencies (FDs) for R. This condition ensures that the original relation can be reconstructed by joining R1 and R2. Dependency Preservation A decomposition of R into D = {R1, R2, ..., Rn} is dependency preserving if (F1 \u222a F2 \u222a ... \u222a Fn) = F, where: Fi is the set of FDs including attributes only in Ri This ensures that all FDs in F are preserved in the decomposition. Testing Dependency Preservation Test if a dependency \u03b1 \u2192 \u03b2 is preserved by: Computing F0 = F1 \u222a F2 \u222a ... \u222a Fn Check if \u03b2 is in the attribute closure of \u03b1 with respect to F0 Practice Problems Lossless Join Decomposition Determine if the following decompositions are lossless: R(ABC) : F = {A \u2192 B, A \u2192 C} \u2192 {R1(AB), R2(BC)} R(ABCDEF) : F = {A \u2192 B, B \u2192 C, C \u2192 D, E \u2192 F} \u2192 {R1(AB), R2(BCD), R3(DEF)} R(ABCDEF) : F = {A \u2192 B, C \u2192 DE, AC \u2192 F} \u2192 {R1(BE), R2(ACDEF)} R(ABCDEG) : F = {AB \u2192 C, AC \u2192 B, AD \u2192 E, B \u2192 D, BC \u2192 A, E \u2192 G} \u2192 {R1(AB), R2(BC), R3(ABDE), R4(EG)} R(ABCDEFGHIJ) : F = {AB \u2192 C, B \u2192 F, D \u2192 IJ, A \u2192 DE, F \u2192 GH} \u2192 {R1(ABC), R2(ADE), R3(BF), R4(FGH), R5(DIJ)} Dependency Preservation Verify if the following decompositions preserve dependencies: R(ABCD) : F = {A \u2192 B, B \u2192 C, C \u2192 D, D \u2192 A} \u2192 {AB, BC, CD} R(ABCDEF) : F = {AB \u2192 CD, C \u2192 D, D \u2192 E, E \u2192 F} \u2192 {AB, CDE, EF} R(ABCDEG) : F = {AB \u2192 C, AC \u2192 B, BC \u2192 A, AD \u2192 E, B \u2192 D, E \u2192 G} \u2192 {ABC, ACDE, ADG} R(ABCD) : F = {A \u2192 B, B \u2192 C, C \u2192 D, D \u2192 B} \u2192 {AB, BC, BD} R(ABCDE) : F = {A \u2192 BC, CD \u2192 E, B \u2192 D, E \u2192 A} \u2192 {ABCE, BD}","title":"Lecture 5.5 - Relational Database Design5.pdf (PDF file)"},{"location":"Week%205/closureofartibut/","text":"(AC)^plus = as A-> B (AC)^+ = ACB as BC -> DE (AC)^+ = ACBDE AEF -> G and F not in (AC)^+ (AC)^+ = \"ACBDE\" closure if ACF as A -> B ACF + = ACFB BC -> DE ACF + = ACFBDE AEF -> G ACF + = ACFBDEG","title":"Closureofartibut"},{"location":"Week%205/ex_can/","text":"","title":"Ex can"},{"location":"Week%205/week5/","text":"[ ] lec class [ ] PPA [ ] GRPA [ ] GA [ ] instructor section 1 [ ] instructor section 2 [ ] TA session 1 [ ] TA session 2 [ ] Text book","title":"Week5"},{"location":"gatesmashers/checklist/","text":"[X] Lec-1: DBMS Syllabus for GATE, UGCNET, NIELIT, DSSSB etc.| Full DBMS for College/University Students [X] Lec-2: Introduction to DBMS (Database Management System) With Real life examples | What is DBMS [X] Lec-3: File System vs DBMS | Disadvantages of File System | DBMS Advantages [X] Lec-4: 2 tier and 3 tier Architecture with real life examples | Database Management System [X] Lec-5: What is Schema | How to define Schema | Database management system in Hindi [X] Lec-6: Three Schema Architecture | Three Level of Abstraction | Database Management System [X] Lec-7: What is Data Independence | Logical vs. Physical Independence | DBMS [X] Lec-8.0: Integrity Constraints in Database with Examples [X] Lec-8: What is CANDIDATE KEY and PRIMARY key | Full Concept | Most suitable examples | DBMS [X] Lec-9: What is Primary Key in DBMS | Primary Key with Examples in Hindi [X] Lec-10: Foreign Key in DBMS | Full Concept with examples | DBMS in Hindi [X] Lec-11: Insert, Update & Delete from Foreign Key table | Referential Integrity [X] Lec-12: Question on Foreign Key | \u092f\u0947 Question Competition Exams \u092e\u0947\u0902 \u0905\u0915\u094d\u0938\u0930 \u092a\u0942\u091b\u093e \u0917\u092f\u093e \u0939\u0948 [X] Lec-13: Super key in DBMS in HINDI | \u092f\u0947 Question Competition Exams \u092e\u0947\u0902 \u0905\u0915\u094d\u0938\u0930 \u092a\u0942\u091b\u093e \u0917\u092f\u093e \u0939\u0948 [ ] Lec-14: Introduction to ER model | ER Model \u0915\u094d\u092f\u093e \u0939\u0948 [ ] Lec-15: Types of Attributes in ER Model | Full Concept | DBMS in Hindi [ ] Lec-16: One to One relationship in DBMS in Hindi [ ] Lec-17: One to Many Relationship in DBMS in Hindi | 1-M Relationship [ ] Lec-18: Many to Many Relationship in DBMS | M-N Relationship [ ] Lec-19:Question on Minimize tables in ER Model | \u092f\u0947 Question Competition Exams \u092e\u0947\u0902 \u0905\u0915\u094d\u0938\u0930 \u092a\u0942\u091b\u093e \u0917\u092f\u093e \u0939\u0948 [ ] Lec-20: Introduction to Normalization | Insertion, Deletion & Updation Anomaly [ ] Lec-21: First Normal form in DBMS in HINDI | 1st Normal form \u0915\u094d\u092f\u093e \u0939\u094b\u0924\u0940 \u0939\u0948 ? [ ] Lec-22: Finding Closure of Functional dependency in DBMS | Easiest & Simplest way [ ] Lec-23: Functional Dependency & its properties in DBMS in HINDI [ ] Lec-24: Second Normal Form | 2NF | Database Management System [ ] Lec-25: Third Normal Form in dbms with examples in Hindi | Normalization [ ] Lec-26: Boyce Codd Normal Form #BCNF #DBMS #Normalization with best examples [ ] Lec-27: BCNF Always Ensures Dependency Preserving Decomposition?? Normalization Examples [ ] Lec-28: Lossless and Lossy Decomposition| Fifth (5th) Normal Form | Database Management System [ ] Lec-29: All Normal Forms with Real life examples | 1NF 2NF 3NF BCNF 4NF 5NF | All in One [ ] Lec-30: Minimal Cover in DBMS With Example | Canonical cover [ ] Lec-31: Practice Question on Normalization | Database Management System [ ] Lec-32: How to find out the Normal form of a Relation | DBMS [ ] Lec-33: How to Solve Normalization Questions | DBMS [ ] Lec-34: Important Question Explanation on Normalization [ ] Lec-35: Cover and Equivalence of Functional Dependencies | Database Management System [ ] Lec-36: Dependency Preserving Decomposition in DBMS with Examples in Hindi | DBMS [ ] Lec-37: Dependency Preserving Decomposition in DBMS | Example 2 in Hindi [X] Lec-38: Introduction to Joins and its types | Need of Joins with example | DBMS [X] Lec-39: Natural Join operation with Example | Database Management System [X] Lec-40: Self Join operation with Example | Database Management System [X] Lec-41: Equi Join operation with Example | Database Management System [X] Lec-42: Left Ou>>>?ter Join operation with Example | Database Management System [X] Lec-43: Right Outer Join operation with Example | Database Management System [X] Lec-44: Introduction to Relational Algebra | Database Management System [X] Lec-45: Projection in Relational Algebra | Database Management System [X] Lec-46: Selection in Relational Algebra | Database Management System [X] Lec-47: Cross/Cartesian Product in Relational Algebra | Database Management System [X] Lec-48: Set Difference in Relational Algebra | Database Management System [X] Lec-49: Union Operation in Relational Algebra | Database Management System [X] Lec-50: Division Operation in Relational Algebra | Database Management System [X] Lec-51: Tuple Calculus in DBMS with examples [X] Lec-52: Introduction to Structured Query Language | All Points regarding its Features and Syllabus [X] Lec-53: All Types of SQL Commands with Example | DDL, DML, DCL, TCL and CONSTRAINTS | DBMS [X] Lec-54: Create table in SQL with execution | SQL for Beginners | Oracle LIVE [X] Lec-55: ALTER Command (DDL) in SQL with Implementation on ORACLE [X] Lec-56: Difference between Alter and Update in SQL with examples in Hindi | DBMS [X] Lec-57 Difference between Delete, Drop & Truncate in SQL | DBMS [X] Lec-58: Constraints in SQL in Hindi | DBMS [X] Lec-59: SQL Queries and Subqueries (part-1) | Database Management System [X] Lec-60: SQL Queries and Subqueries (part-2) | 2nd Highest Salary | Nested Queries | DBMS [X] Lec-61: SQL Queries and Subqueries (part-3) | Group By clause | Database Management System [X] Lec-62: SQL Queries and Subqueries (part-4) | Having clause | Database Management System [X] Lec-63: SQL Queries and Subqueries (part-5) | Database Management System [X] Lec-64: SQL Queries and Subqueries (part-6)| use of IN and Not IN | Database Management System [X] Lec-65: SQL Queries and Subqueries (part-7)| use of IN and Not IN in Subquery | DBMS [X] Lec-66: EXIST and NOT EXIST Subqueries(part-8) | Database Management System [X] Lec-67: SQL Aggregate Functions - SUM, AVG(n), COUNT, MIN, MAX Functions | DBMS [X] Lec-68: Correlated Subquery in SQL with Example | Imp for Placements, GATE, NET & SQL certification [X] Lec-69: Difference between Joins, Nested Subquery and Correlated Subquery | Most Imp Concept of SQL [X] Lec-70: Find Nth(1st,2nd,3rd....N) Highest Salary in SQL | Imp for Competitive & Placement exam [X] Lec-71: 3 Imp Questions on SQL basic Concepts | DBMS [ ] Lec-72: Introduction to PL-SQL in DBMS [ ] Lec-73: Introduction to Transaction Concurrency in HINDI | Database Management System [ ] Lec-74: ACID Properties of a Transaction | Database Management System [ ] Lec-75: Transaction States | Database Management System [ ] Lec-76: What is Schedule | Serial Vs Parallel Schedule | Database Management System [ ] Lec-77: All Concurrency Problems | Dirty Read | Incorrect Summary | Lost Update | Phantom Read [ ] Lec-78: Write-Read Conflict or Dirty Read Problem | Database Management System [ ] Lec-79: Read-Write Conflict or Unrepeatable Read Problem | Database Management System [ ] Lec-80: Irrecoverable Vs Recoverable Schedules in Transactions | DBMS [ ] Lec-81: Cascading vs Cascadeless Schedule with Example | Recoverability | DBMS [ ] Lec-82: Introduction to Serializability | Transactions Concurrency and Control | DBMS [ ] Lec-83: Conflict Equivalent Schedules with Example | Transaction concurrency and Control | DBMS [ ] Lec-84: Conflict Serializability | Precedence Graph | Transaction | DBMS [ ] Lec-85: Why View Serializability is Used | Introduction to View Serializability | DBMS [ ] Lec-86:Shared Exclusive Locking Protocol with Example in Hindi | Concurrency Control | DBMS | Part-1 [ ] Lec-87: Drawbacks in Shared/Exclusive Locking Protocol with Example | Concurrency Control Part-2 [ ] Lec-88: 2 Phase Locking(2PL) Protocol in Transaction Concurrency Control | DBMS [ ] Lec-89: Drawbacks in 2 Phase Locking(2PL) Protocol with examples | Concurrency Control | DBMS [ ] Lec-90: Strict 2PL, Rigorous 2PL and Conservative 2PLSchedule | 2 Phase Locking in DBMS [ ] Lec-91: Basic Timestamp Ordering Protocol with Example in Hindi | Concurrency Control | DBMS [ ] Lec-92: How to Solve Question on Timestamp Ordering Protocol | Concurrency Control | DBMS [ ] Lec-93: Why Indexing is used | Indexing Beginning | DBMS [ ] Lec-94: Numerical Example on I/O Cost in Indexing | Part-1 | DBMS [ ] Lec-95: Numerical Example on I/O Cost in Indexing | Part 2 | DBMS [ ] Lec-96: Types Of Indexes | Most Important Video on Indexing [ ] Lec-97: Primary Index With Example | GATE, PSU and UGC NET | DBMS [ ] Lec-98: Clustered Index in Database with Example [ ] Lec-99: Secondary Index in Database with Example | Multilevel Indexing [ ] Lec-100: Introduction to B-Tree and its Structure | Block Pointer, Record Pointer, Key [ ] Lec-101: Insertion in B-Tree with example in Hindi [ ] Lec-102: How to find Order of B-Tree | Imp Question on B-Tree [ ] Lec-103: Difference b/w B-Tree & B+Tree in Hindi with examples [ ] Lec-104: Order of B+ Tree | Order of Leaf Node & Non Leaf Node in B+Tree [ ] Lec-105: Immediate Database Modification in DBMS | Log Based Recovery Methods [ ] Lec-106: Deferred Database Modification in DBMS | Log Based Recovery | Imp for UGC NET and KVS [ ] Lec-107: Like Command in SQL with example in Hindi | Learn SQL in Easiest Way| DBMS [ ] Lec-108: Basic PL-SQL Programming With Execution | Part-1 [ ] Lec-109: Basic PL-SQL Programming(While, For Loop) With Execution | Part-2 [ ] Lec-110: Single row and Multi row functions in SQL [ ] Lec-111: Character functions in SQL with execution | Oracle LIVE [ ] Lec-112: View in Database | Oracle, SQL Server Views | Types of Views [ ] Lec-113: How Aggregate Functions work on NULL Values | SQL | DBMS [ ] Lec-114: What is RAID? RAID 0, RAID 1, RAID 4, RAID 5, RAID 6, Nested RAID 10 Explained [ ] Lec-115: Various objects in Database | Oracle, SQL Server [ ] Lec-116: Important Question explanation on ER Model | DBMS [ ] Lec-117: Very Imp. Questions on DBMS basic concepts and Data Modelling | DBMS [ ] Lec-118: Question on Inner, Left, Right & Full Outer Joins Explanation | DBMS [ ] Lec-119: 4 Imp Questions on Advance DBMS | BIG Data and Data Warehouse | DBMS [ ] Lec-120: Important Question on Normalization (Schemas) Explanation | DBMS [ ] Lec-121: Important Question on Relational Algebra | DBMS [ ] Lec-122: Codd\u2019s 12 Rules of RDBMS with examples [ ] Lec-123: Top 15 SQL Interview Questions Answers | Most Important Questions for Job Interview [ ] Lec-124: CREATE Command (DDL) in SQL with Implementation on ORACLE [ ] Lec-125: SEQUENCE in SQL with Syntax & Examples [ ] Lec-126: How SQL Query executes?? Order of SQL Query Execution\u23f3\ud83d\udd04 [ ] Lec-127: Introduction to Hadoop\ud83d\udc18| What is Hadoop\ud83d\udc18| Hadoop Framework\ud83d\udda5 [ ] Lec-128: Introduction to BIG Data in Hindi | Small Data Vs BIG Data | Real Life Examples [ ] Lec-129: Simple vs Complex vs Materialized Views with examples | DBMS [ ] Foreign Key\ud83d\udd11 with On Delete Cascade with Execution [ ] Procedures in PL-SQL | Local Procedure vs Stored Procedure [ ] How to Fetch Data from Database using Procedures | PL-SQL Procedure [ ] %TYPE & %ROWTYPE in PL-SQL with Examples [ ] What is Cursor in PL-SQL with example","title":"Checklist"},{"location":"gatesmashers/notes/","text":"","title":"Notes"},{"location":"gatesmashers/sql/","text":"SQL key Candidate Key -> Primary Key Candidate key -> keys which are not used as primary key are called alternative key Primary Key {Unique + Not Null } Foreign Key Refrencing Table insert course violation if FK is not in in refrenced table Refrenced Table on delete cascade on delete set null on delete no action on update cascade on update set null on update no action Summary of Relational Algebra Operators Operator Description \u03c3 Select \u03c0 Project \u222a Union \u2212 Difference \u2229 Intersection \u00d7 Cartesian Product $ \\rho$ Rename \\(\\bowtie\\) Natural Join SUM Computes the sum of a specified column AVG Computes the average of a specified column MAX Computes the maximum value of a specified column MIN Computes the minimum value of a specified column DDL- Data Definition Language Create Alter Drop Truncate Rename DML - Data Defination Language Select Insert update Delete DCL - Data Control Language Grant Revoke TCL - Transaction Control Language Commit Rollback save point Constraints primary key foreign key check unique default Not null Create Table - DDL create table <table name> ( col1name datattype , col2name datattype , col1name datattype); desc tablename; create table student ( ID varchar(5),name varchar(20) not null, dept name varchar(20),tot cred numeric(3, 0), primary key (ID), foreign key (dept name) references department); Alter - DDL add columns remove columns modify datatype modify datatype length add constraints remove constraints rename constraints Alter vs Update alter - DDL update - DML Delete Vs Drop Vs Truncate Delete - DML Drop - DDL - drop table Truncate - DDL - no back up even in roll back Constraints Condition for columns or attribute unique not null primary -> unique + not null check forgien key default Nested subquery Vs correlated sub query vs joins Instructor = e1= id salary 1 10000 2 20000 3 20000 4 30000 5 40000 6 5000 Instructor = e2= id salary 1 10000 2 20000 3 20000 4 30000 5 40000 6 5000 first row id e1.salary id e2.salary e2.salary > e1.salary count 1 10000 1 10000 False 0 1 10000 2 20000 True 1 1 10000 3 20000 True 2 1 10000 4 30000 True 2 1 10000 5 40000 True 3 1 10000 2 50000 True 4 Second row id e1.salary id e2.salary e2.salary > e1.salary count 2 20000 1 10000 False 0 2 20000 2 20000 False 0 2 20000 3 20000 False 0 2 20000 4 30000 True 1 2 20000 5 40000 True 2 2 20000 2 50000 True 3 Joins employee= PK Eno E-name Address 1 Ram delhi 2 varun chd 3 Ravi chd 4 Amrit Delhi 5 Nitin noida Department = PK FK Dep_no Name eno D1 HR 1 D2 IT 2 D3 MRKT 4 D4 FINANCE 5 Natural join cross poduct + condition = join employee natural join department = cross poduct + condition \\(empolyee.eno = department.eno\\) cross product = select * from employee , department employee.Eno E-name Address Dep_no Name departmment.eno 1 Ram delhi D1 HR 1 1 Ram delhi D2 IT 2 1 Ram delhi D3 MRKT 4 1 Ram delhi D4 FINANCE 5 2 varun chd D1 HR 1 2 varun chd D2 IT 2 2 varun chd D3 MRKT 4 2 varun chd D4 FINANCE 5 3 Ravi chd D1 HR 1 3 Ravi chd D2 IT 2 3 Ravi chd D3 MRKT 4 3 Ravi chd D4 FINANCE 5 4 Amrit Delhi D1 HR 1 4 Amrit Delhi D2 IT 2 4 Amrit Delhi D3 MRKT 4 4 Amrit Delhi D4 FINANCE 5 5 Nitin noida D1 HR 1 5 Nitin noida D2 IT 2 5 Nitin noida D3 MRKT 4 5 Nitin noida D4 FINANCE 5 select * from employee department empolyee.eno = department.eno Eno E-name Address Dep_no Name eno empolyee.eno = department.eno 1 Ram delhi D1 HR 1 True 1 Ram delhi D2 IT 2 False 1 Ram delhi D3 MRKT 4 False 1 Ram delhi D4 FINANCE 5 False 2 varun chd D1 HR 1 False 2 varun chd D2 IT 2 True 2 varun chd D3 MRKT 4 False 2 varun chd D4 FINANCE 5 False 3 Ravi chd D1 HR 1 False 3 Ravi chd D2 IT 2 False 3 Ravi chd D3 MRKT 4 False 3 Ravi chd D4 FINANCE 5 False 4 Amrit Delhi D1 HR 1 False 4 Amrit Delhi D2 IT 2 False 4 Amrit Delhi D3 MRKT 4 True 4 Amrit Delhi D4 FINANCE 5 False 5 Nitin noida D1 HR 1 False 5 Nitin noida D2 IT 2 False 5 Nitin noida D3 MRKT 4 False 5 Nitin noida D4 FINANCE 5 True result= Eno E-name Address Dep_no Name eno 1 Ram delhi D1 HR 1 2 varun chd D2 IT 2 4 Amrit Delhi D3 MRKT 4 5 Nitin noida D4 FINANCE 5 select E-name from employee natural join department E-name Ram varun Amrit Nitin self Join S_id course_id since s1 c1 2016 s2 c2 2017 s1 c2 2017 find student who is enrolled in two courses ? cross prduct S_id (Left) course_id (Left) since (Left) S_id (Right) course_id (Right) since (Right) s1 c1 2016 s1 c1 2016 s1 c1 2016 s2 c2 2017 s1 c1 2016 s1 c2 2017 s2 c2 2017 s1 c1 2016 s2 c2 2017 s2 c2 2017 s2 c2 2017 s1 c2 2017 s1 c2 2017 s1 c1 2016 s1 c2 2017 s2 c2 2017 s1 c2 2017 s1 c2 2017 select LEFT.s_id from study as left study as right where left.s_id = right.s_id and left.course_id < > right.course_id S_id (Left) course_id (Left) since (Left) S_id (Right) course_id (Right) since (Right) CONDF s1 c1 2016 s1 c1 2016 FALSE s1 c1 2016 s2 c2 2017 FALSE s1 c1 2016 s1 c2 2017 TRUE s2 c2 2017 s1 c1 2016 FALSE s2 c2 2017 s2 c2 2017 FALSE s2 c2 2017 s1 c2 2017 FALSE s1 c2 2017 s1 c1 2016 TRUE s1 c2 2017 s2 c2 2017 FALSE s1 c2 2017 s1 c2 2017 FALSE S_id (Left) s1 Equi Join select e.E_name from emp e dept d where e.address = d.location and e.en_no = d.eno; left outer join A LEFT OUTER JOIN in SQL is a type of join operation that combines rows from two or more tables based on a specified condition and includes unmatched rows from the left table. It allows you to retrieve data from multiple tables based on their related values. Here's a detailed explanation: What is a LEFT OUTER JOIN? A LEFT OUTER JOIN is a type of join operation that combines rows from two or more tables based on a specified condition. It includes all rows from the left table (the \"left\" or \"first\" table) and matching rows from the right table (the \"right\" or \"second\" table). If there is no match in the right table, the result includes NULL values for the columns of the right table[1][2][3]. Syntax The syntax for a LEFT OUTER JOIN in SQL is as follows: SELECT column_name ( s ) FROM table1 LEFT JOIN table2 ON table1 . column_name = table2 . column_name ; Example For example, consider a query that retrieves all employees along with their departments and salaries (if available). The Employees table is the left table, and we perform a LEFT OUTER JOIN with the Departments table using the join condition E.DepartmentID = D.DepartmentID . This ensures that all employees from the Employees table are included in the result set, regardless of whether they have a matching department. We then perform another LEFT OUTER JOIN with the Salaries table using the join condition E.EmployeeID = S.EmployeeID , allowing us to include salary information for employees if it exists[2]. SELECT E . EmployeeID , E . Name , D . DepartmentName , S . SalaryAmount FROM Employees E LEFT OUTER JOIN Departments D ON E . DepartmentID = D . DepartmentID LEFT OUTER JOIN Salaries S ON E . EmployeeID = S . EmployeeID ; Output The output of this query would include all employees, even if they do not have a matching department or salary. The unmatched rows in the Employees table would have NULL values in the DepartmentName and SalaryAmount columns[2]. Key Points Includes all rows from the left table : A LEFT OUTER JOIN includes all rows from the left table, even if there are no matching rows in the right table. Includes matching rows from the right table : If there is a match in the right table, the result includes the corresponding row from the right table. Includes NULL values for unmatched rows in the right table : If there is no match in the right table, the result includes NULL values for the columns of the right table[1][2][3]. Practical Examples Retrieving all customers, even if they haven't placed any orders : A LEFT OUTER JOIN can be used to retrieve all customers, even if they haven't placed any orders. The unmatched rows in the Customers table would have NULL values in the OrdersID column[2]. Right outer join","title":"SQL"},{"location":"gatesmashers/sql/#sql","text":"","title":"SQL"},{"location":"gatesmashers/sql/#key","text":"Candidate Key -> Primary Key Candidate key -> keys which are not used as primary key are called alternative key","title":"key"},{"location":"gatesmashers/sql/#primary-key","text":"{Unique + Not Null }","title":"Primary Key"},{"location":"gatesmashers/sql/#foreign-key","text":"Refrencing Table insert course violation if FK is not in in refrenced table Refrenced Table on delete cascade on delete set null on delete no action on update cascade on update set null on update no action Summary of Relational Algebra Operators Operator Description \u03c3 Select \u03c0 Project \u222a Union \u2212 Difference \u2229 Intersection \u00d7 Cartesian Product $ \\rho$ Rename \\(\\bowtie\\) Natural Join SUM Computes the sum of a specified column AVG Computes the average of a specified column MAX Computes the maximum value of a specified column MIN Computes the minimum value of a specified column","title":"Foreign Key"},{"location":"gatesmashers/sql/#ddl-data-definition-language","text":"Create Alter Drop Truncate Rename","title":"DDL- Data Definition Language"},{"location":"gatesmashers/sql/#dml-data-defination-language","text":"Select Insert update Delete","title":"DML - Data Defination Language"},{"location":"gatesmashers/sql/#dcl-data-control-language","text":"Grant Revoke","title":"DCL - Data Control Language"},{"location":"gatesmashers/sql/#tcl-transaction-control-language","text":"Commit Rollback save point","title":"TCL - Transaction Control Language"},{"location":"gatesmashers/sql/#constraints","text":"primary key foreign key check unique default Not null","title":"Constraints"},{"location":"gatesmashers/sql/#create-table-ddl","text":"create table <table name> ( col1name datattype , col2name datattype , col1name datattype); desc tablename; create table student ( ID varchar(5),name varchar(20) not null, dept name varchar(20),tot cred numeric(3, 0), primary key (ID), foreign key (dept name) references department);","title":"Create Table - DDL"},{"location":"gatesmashers/sql/#alter-ddl","text":"add columns remove columns modify datatype modify datatype length add constraints remove constraints rename constraints","title":"Alter - DDL"},{"location":"gatesmashers/sql/#alter-vs-update","text":"alter - DDL update - DML","title":"Alter vs Update"},{"location":"gatesmashers/sql/#delete-vs-drop-vs-truncate","text":"Delete - DML Drop - DDL - drop table Truncate - DDL - no back up even in roll back","title":"Delete Vs Drop Vs Truncate"},{"location":"gatesmashers/sql/#constraints_1","text":"Condition for columns or attribute unique not null primary -> unique + not null check forgien key default","title":"Constraints"},{"location":"gatesmashers/sql/#nested-subquery-vs-correlated-sub-query-vs-joins","text":"Instructor = e1= id salary 1 10000 2 20000 3 20000 4 30000 5 40000 6 5000 Instructor = e2= id salary 1 10000 2 20000 3 20000 4 30000 5 40000 6 5000 first row id e1.salary id e2.salary e2.salary > e1.salary count 1 10000 1 10000 False 0 1 10000 2 20000 True 1 1 10000 3 20000 True 2 1 10000 4 30000 True 2 1 10000 5 40000 True 3 1 10000 2 50000 True 4 Second row id e1.salary id e2.salary e2.salary > e1.salary count 2 20000 1 10000 False 0 2 20000 2 20000 False 0 2 20000 3 20000 False 0 2 20000 4 30000 True 1 2 20000 5 40000 True 2 2 20000 2 50000 True 3","title":"Nested subquery Vs correlated sub query vs joins"},{"location":"gatesmashers/sql/#joins","text":"employee= PK Eno E-name Address 1 Ram delhi 2 varun chd 3 Ravi chd 4 Amrit Delhi 5 Nitin noida Department = PK FK Dep_no Name eno D1 HR 1 D2 IT 2 D3 MRKT 4 D4 FINANCE 5","title":"Joins"},{"location":"gatesmashers/sql/#natural-join","text":"cross poduct + condition = join employee natural join department = cross poduct + condition \\(empolyee.eno = department.eno\\) cross product = select * from employee , department employee.Eno E-name Address Dep_no Name departmment.eno 1 Ram delhi D1 HR 1 1 Ram delhi D2 IT 2 1 Ram delhi D3 MRKT 4 1 Ram delhi D4 FINANCE 5 2 varun chd D1 HR 1 2 varun chd D2 IT 2 2 varun chd D3 MRKT 4 2 varun chd D4 FINANCE 5 3 Ravi chd D1 HR 1 3 Ravi chd D2 IT 2 3 Ravi chd D3 MRKT 4 3 Ravi chd D4 FINANCE 5 4 Amrit Delhi D1 HR 1 4 Amrit Delhi D2 IT 2 4 Amrit Delhi D3 MRKT 4 4 Amrit Delhi D4 FINANCE 5 5 Nitin noida D1 HR 1 5 Nitin noida D2 IT 2 5 Nitin noida D3 MRKT 4 5 Nitin noida D4 FINANCE 5 select * from employee department empolyee.eno = department.eno Eno E-name Address Dep_no Name eno empolyee.eno = department.eno 1 Ram delhi D1 HR 1 True 1 Ram delhi D2 IT 2 False 1 Ram delhi D3 MRKT 4 False 1 Ram delhi D4 FINANCE 5 False 2 varun chd D1 HR 1 False 2 varun chd D2 IT 2 True 2 varun chd D3 MRKT 4 False 2 varun chd D4 FINANCE 5 False 3 Ravi chd D1 HR 1 False 3 Ravi chd D2 IT 2 False 3 Ravi chd D3 MRKT 4 False 3 Ravi chd D4 FINANCE 5 False 4 Amrit Delhi D1 HR 1 False 4 Amrit Delhi D2 IT 2 False 4 Amrit Delhi D3 MRKT 4 True 4 Amrit Delhi D4 FINANCE 5 False 5 Nitin noida D1 HR 1 False 5 Nitin noida D2 IT 2 False 5 Nitin noida D3 MRKT 4 False 5 Nitin noida D4 FINANCE 5 True","title":"Natural join"},{"location":"gatesmashers/sql/#result","text":"Eno E-name Address Dep_no Name eno 1 Ram delhi D1 HR 1 2 varun chd D2 IT 2 4 Amrit Delhi D3 MRKT 4 5 Nitin noida D4 FINANCE 5 select E-name from employee natural join department E-name Ram varun Amrit Nitin","title":"result="},{"location":"gatesmashers/sql/#self-join","text":"S_id course_id since s1 c1 2016 s2 c2 2017 s1 c2 2017 find student who is enrolled in two courses ? cross prduct S_id (Left) course_id (Left) since (Left) S_id (Right) course_id (Right) since (Right) s1 c1 2016 s1 c1 2016 s1 c1 2016 s2 c2 2017 s1 c1 2016 s1 c2 2017 s2 c2 2017 s1 c1 2016 s2 c2 2017 s2 c2 2017 s2 c2 2017 s1 c2 2017 s1 c2 2017 s1 c1 2016 s1 c2 2017 s2 c2 2017 s1 c2 2017 s1 c2 2017 select LEFT.s_id from study as left study as right where left.s_id = right.s_id and left.course_id < > right.course_id S_id (Left) course_id (Left) since (Left) S_id (Right) course_id (Right) since (Right) CONDF s1 c1 2016 s1 c1 2016 FALSE s1 c1 2016 s2 c2 2017 FALSE s1 c1 2016 s1 c2 2017 TRUE s2 c2 2017 s1 c1 2016 FALSE s2 c2 2017 s2 c2 2017 FALSE s2 c2 2017 s1 c2 2017 FALSE s1 c2 2017 s1 c1 2016 TRUE s1 c2 2017 s2 c2 2017 FALSE s1 c2 2017 s1 c2 2017 FALSE S_id (Left) s1","title":"self Join"},{"location":"gatesmashers/sql/#equi-join","text":"select e.E_name from emp e dept d where e.address = d.location and e.en_no = d.eno;","title":"Equi Join"},{"location":"gatesmashers/sql/#left-outer-join","text":"A LEFT OUTER JOIN in SQL is a type of join operation that combines rows from two or more tables based on a specified condition and includes unmatched rows from the left table. It allows you to retrieve data from multiple tables based on their related values. Here's a detailed explanation:","title":"left outer join"},{"location":"gatesmashers/sql/#what-is-a-left-outer-join","text":"A LEFT OUTER JOIN is a type of join operation that combines rows from two or more tables based on a specified condition. It includes all rows from the left table (the \"left\" or \"first\" table) and matching rows from the right table (the \"right\" or \"second\" table). If there is no match in the right table, the result includes NULL values for the columns of the right table[1][2][3].","title":"What is a LEFT OUTER JOIN?"},{"location":"gatesmashers/sql/#syntax","text":"The syntax for a LEFT OUTER JOIN in SQL is as follows: SELECT column_name ( s ) FROM table1 LEFT JOIN table2 ON table1 . column_name = table2 . column_name ;","title":"Syntax"},{"location":"gatesmashers/sql/#example","text":"For example, consider a query that retrieves all employees along with their departments and salaries (if available). The Employees table is the left table, and we perform a LEFT OUTER JOIN with the Departments table using the join condition E.DepartmentID = D.DepartmentID . This ensures that all employees from the Employees table are included in the result set, regardless of whether they have a matching department. We then perform another LEFT OUTER JOIN with the Salaries table using the join condition E.EmployeeID = S.EmployeeID , allowing us to include salary information for employees if it exists[2]. SELECT E . EmployeeID , E . Name , D . DepartmentName , S . SalaryAmount FROM Employees E LEFT OUTER JOIN Departments D ON E . DepartmentID = D . DepartmentID LEFT OUTER JOIN Salaries S ON E . EmployeeID = S . EmployeeID ;","title":"Example"},{"location":"gatesmashers/sql/#output","text":"The output of this query would include all employees, even if they do not have a matching department or salary. The unmatched rows in the Employees table would have NULL values in the DepartmentName and SalaryAmount columns[2].","title":"Output"},{"location":"gatesmashers/sql/#key-points","text":"Includes all rows from the left table : A LEFT OUTER JOIN includes all rows from the left table, even if there are no matching rows in the right table. Includes matching rows from the right table : If there is a match in the right table, the result includes the corresponding row from the right table. Includes NULL values for unmatched rows in the right table : If there is no match in the right table, the result includes NULL values for the columns of the right table[1][2][3].","title":"Key Points"},{"location":"gatesmashers/sql/#practical-examples","text":"Retrieving all customers, even if they haven't placed any orders : A LEFT OUTER JOIN can be used to retrieve all customers, even if they haven't placed any orders. The unmatched rows in the Customers table would have NULL values in the OrdersID column[2].","title":"Practical Examples"},{"location":"gatesmashers/sql/#right-outer-join","text":"","title":"Right outer join"},{"location":"week1/Lecture%201.1%20-%20Course%20Overview/","text":"Lecture 1.1 - Course Overview.pdf (PDF file) Summary Database Management Systems (DBMSs) are crucial in modern applications, providing organized access to large volumes of interconnected data through a user-friendly interface. They offer advantages such as eliminating data redundancy, enhancing data accessibility, promoting data security, and ensuring data integrity. This course provides an overview of DBMS concepts and applications, including fundamental sets, relations, functions, propositional and predicate logic, data structures, object-oriented analysis, and Python programming. The essential prerequisites for the course include set theory, relations and functions, propositional logic, predicate logic, data structures, programming in Python, and algorithms and programming in C. Desirable prerequisites include object-oriented analysis and design. The course outline covers: Why Databases? Know Your Course (KYC) KYC: Course Prerequisite KYC: Course Outline KYC: Course Text Book Module Summary The textbook for the course is \"Database System Concepts\" by Abraham Silberschatz, Henry Korth, and S. Sudarshan.","title":"Lecture 1.1 - Course Overview.pdf (PDF file)"},{"location":"week1/Lecture%201.1%20-%20Course%20Overview/#lecture-11-course-overviewpdf-pdf-file","text":"Summary Database Management Systems (DBMSs) are crucial in modern applications, providing organized access to large volumes of interconnected data through a user-friendly interface. They offer advantages such as eliminating data redundancy, enhancing data accessibility, promoting data security, and ensuring data integrity. This course provides an overview of DBMS concepts and applications, including fundamental sets, relations, functions, propositional and predicate logic, data structures, object-oriented analysis, and Python programming. The essential prerequisites for the course include set theory, relations and functions, propositional logic, predicate logic, data structures, programming in Python, and algorithms and programming in C. Desirable prerequisites include object-oriented analysis and design. The course outline covers: Why Databases? Know Your Course (KYC) KYC: Course Prerequisite KYC: Course Outline KYC: Course Text Book Module Summary The textbook for the course is \"Database System Concepts\" by Abraham Silberschatz, Henry Korth, and S. Sudarshan.","title":"Lecture 1.1 - Course Overview.pdf (PDF file)"},{"location":"week1/Lecture%201.2%20-%20Why%20DBMS1/","text":"Lecture 1.2 - Why DBMS1.pdf (PDF file) Summary Module 2 of the course focuses on the evolution of data management and the history of database management systems (DBMSs). It highlights the need for DBMSs from a historical perspective, tracing the evolution of data management practices. The module covers the history of DBMSs, starting with physical data management (book keeping) using ledgers and journals. It discusses the significant advancement in 1886 when Henry Brown patented a device for storing and preserving papers. The invention of punch cards by Herman Hollerith in 1890 for use in tabulating machines further propelled electronic data management. The module explores key parameters for electronic data management, including durability, scalability, security, ease of use, consistency, efficiency, cost, and others. It examines the limitations of traditional file systems in meeting growing data needs and discusses the transition to DBMSs. The module reviews the history of DBMSs, starting with the use of magnetic tapes in the 1950s and early 1960s. It highlights the development of hard disks in the late 1960s and 1970s, enabling direct access to data. The introduction of the relational data model by Ted Codd and the development of commercial relational database systems in the 1980s are also mentioned. The module concludes with a summary of the evolution of data models, DB technology, and DB architecture. Data Management Storage Retrieval Transaction Audit Archival for : individual Small/ big enterprise global Major Approach: Physical also know as Book keeping Electronic Electronic Data or Records management depends on various parameters including: \u2022 Durability \u2022 Scalability \u2022 Security \u2022 Retrieval \u2022 Ease of Use \u2022 Consistency \u2022 Efficiency \u2022 Cost Problems with such an approach of book-keeping: \u2022 Durability: Physical damage to these registers is a possibility due to rodents, humidity, wear and tear \u2022 Scalability: Very difficult to maintain for many years, some shops have numerous registers spanning over years \u2022 Security: Susceptible to tampering by outsiders \u2022 Retrieval: Time consuming process to search for a previous entry \u2022 Consistency: Prone to human errors Spreadsheet files - a better solutionm to natural file creation","title":"Lecture 1.2 - Why DBMS1.pdf (PDF file)"},{"location":"week1/Lecture%201.2%20-%20Why%20DBMS1/#lecture-12-why-dbms1pdf-pdf-file","text":"Summary Module 2 of the course focuses on the evolution of data management and the history of database management systems (DBMSs). It highlights the need for DBMSs from a historical perspective, tracing the evolution of data management practices. The module covers the history of DBMSs, starting with physical data management (book keeping) using ledgers and journals. It discusses the significant advancement in 1886 when Henry Brown patented a device for storing and preserving papers. The invention of punch cards by Herman Hollerith in 1890 for use in tabulating machines further propelled electronic data management. The module explores key parameters for electronic data management, including durability, scalability, security, ease of use, consistency, efficiency, cost, and others. It examines the limitations of traditional file systems in meeting growing data needs and discusses the transition to DBMSs. The module reviews the history of DBMSs, starting with the use of magnetic tapes in the 1950s and early 1960s. It highlights the development of hard disks in the late 1960s and 1970s, enabling direct access to data. The introduction of the relational data model by Ted Codd and the development of commercial relational database systems in the 1980s are also mentioned. The module concludes with a summary of the evolution of data models, DB technology, and DB architecture. Data Management Storage Retrieval Transaction Audit Archival for : individual Small/ big enterprise global Major Approach: Physical also know as Book keeping Electronic Electronic Data or Records management depends on various parameters including: \u2022 Durability \u2022 Scalability \u2022 Security \u2022 Retrieval \u2022 Ease of Use \u2022 Consistency \u2022 Efficiency \u2022 Cost Problems with such an approach of book-keeping: \u2022 Durability: Physical damage to these registers is a possibility due to rodents, humidity, wear and tear \u2022 Scalability: Very difficult to maintain for many years, some shops have numerous registers spanning over years \u2022 Security: Susceptible to tampering by outsiders \u2022 Retrieval: Time consuming process to search for a previous entry \u2022 Consistency: Prone to human errors Spreadsheet files - a better solutionm to natural file creation","title":"Lecture 1.2 - Why DBMS1.pdf (PDF file)"},{"location":"week1/Lecture%201.3%20-%20Why%20DBMS2/","text":"Lecture 1.3 - Why DBMS2.pdf (PDF file) Summary This module introduces file systems and database management systems (DBMSs) and compares their features. File Systems vs. Databases File systems are less efficient for data management, especially with increasing data volume and structural changes. DBMSs are scalable and provide built-in mechanisms for data handling. Python vs. SQL Python is easier to implement for file handling, while SQL provides faster execution in milliseconds even for large datasets. Parameterized Comparison Scalability: DBMSs are more scalable in terms of both data volume and structural changes. Time and Efficiency: DBMSs provide faster data processing through built-in mechanisms like indexing. However, for small datasets, the setup time of a DBMS may outweigh its advantages. Persistence, Robustness, and Security: DBMSs ensure automatic data persistence, provide mechanisms for backup and recovery, and offer user-specific security. Programmer's Productivity: DBMSs reduce coding effort by providing built-in mechanisms for data consistency and relationship maintenance. Arithmetic Operations: Python offers extensive arithmetic and logical operations, while SQL has limited support for these. Costs and Complexity: File systems are less expensive to implement and maintain, while DBMSs require specialized hardware, software, and personnel, leading to higher costs.","title":"Lecture 1.3 - Why DBMS2.pdf (PDF file)"},{"location":"week1/Lecture%201.3%20-%20Why%20DBMS2/#lecture-13-why-dbms2pdf-pdf-file","text":"Summary This module introduces file systems and database management systems (DBMSs) and compares their features. File Systems vs. Databases File systems are less efficient for data management, especially with increasing data volume and structural changes. DBMSs are scalable and provide built-in mechanisms for data handling. Python vs. SQL Python is easier to implement for file handling, while SQL provides faster execution in milliseconds even for large datasets. Parameterized Comparison Scalability: DBMSs are more scalable in terms of both data volume and structural changes. Time and Efficiency: DBMSs provide faster data processing through built-in mechanisms like indexing. However, for small datasets, the setup time of a DBMS may outweigh its advantages. Persistence, Robustness, and Security: DBMSs ensure automatic data persistence, provide mechanisms for backup and recovery, and offer user-specific security. Programmer's Productivity: DBMSs reduce coding effort by providing built-in mechanisms for data consistency and relationship maintenance. Arithmetic Operations: Python offers extensive arithmetic and logical operations, while SQL has limited support for these. Costs and Complexity: File systems are less expensive to implement and maintain, while DBMSs require specialized hardware, software, and personnel, leading to higher costs.","title":"Lecture 1.3 - Why DBMS2.pdf (PDF file)"},{"location":"week1/Lecture%201.4%20-%20Intro%20to%20DBMS1/","text":"Lecture 1.4 - Intro to DBMS1.pdf (PDF file) Summary This document provides an introduction to Database Management Systems (DBMS) by discussing various concepts and components. Levels of Abstraction: Physical level: Database storage and organization. Logical level: Data representation and relationships.= type instructor = record ID : string; name : string; dept name : string; salary : integer; end; View level: Application-specific data presentation and security. Schema and Instance: Schema: Logical structure of the database, specifying data types, constraints, and relationships. logical schema - Analogous to type information of a variable in a program. Physical schema - The overall physical structure of the database. Instance: Actual data stored in the database at a specific time. Data Models: Tools for describing data, relationships, semantics, and constraints. Relational model: Stores data in tables, with rows representing records and columns representing attributes. DDL and DML: Data Definition Language (DDL): Used to create, modify, and delete database structures (e.g., tables). Data Manipulation Language (DML): Used to access and manipulate data (e.g., insert, update, delete). SQL (Structured Query Language): Commercial DML widely used in database systems. Not Turing-machine equivalent, but often embedded in other programming languages. Database Design: Process of creating the database schema and physical layout. Logical design: Deciding on the schema, including attributes and relationships. Physical design: Determining the physical storage and optimization strategies.","title":"Lecture 1.4 - Intro to DBMS1.pdf (PDF file)"},{"location":"week1/Lecture%201.4%20-%20Intro%20to%20DBMS1/#lecture-14-intro-to-dbms1pdf-pdf-file","text":"Summary This document provides an introduction to Database Management Systems (DBMS) by discussing various concepts and components. Levels of Abstraction: Physical level: Database storage and organization. Logical level: Data representation and relationships.= type instructor = record ID : string; name : string; dept name : string; salary : integer; end; View level: Application-specific data presentation and security. Schema and Instance: Schema: Logical structure of the database, specifying data types, constraints, and relationships. logical schema - Analogous to type information of a variable in a program. Physical schema - The overall physical structure of the database. Instance: Actual data stored in the database at a specific time. Data Models: Tools for describing data, relationships, semantics, and constraints. Relational model: Stores data in tables, with rows representing records and columns representing attributes. DDL and DML: Data Definition Language (DDL): Used to create, modify, and delete database structures (e.g., tables). Data Manipulation Language (DML): Used to access and manipulate data (e.g., insert, update, delete). SQL (Structured Query Language): Commercial DML widely used in database systems. Not Turing-machine equivalent, but often embedded in other programming languages. Database Design: Process of creating the database schema and physical layout. Logical design: Deciding on the schema, including attributes and relationships. Physical design: Determining the physical storage and optimization strategies.","title":"Lecture 1.4 - Intro to DBMS1.pdf (PDF file)"},{"location":"week1/Lecture%201.5%20-%20Intro%20to%20DBMS2/","text":"Lecture 1.5 - Intro to DBMS2.pdf (PDF file) Summary Module Overview This module provides an introduction to Database Management Systems (DBMS). Objectives Understand models of DBMS Learn about key components of a database engine Familiarize with database internals and architecture Topics Database Design: Logical design (schema design) Physical design (data layout) Design methodologies (Entity-Relationship Model, Normalization Theory) Object-Relational Data Models: Extension of relational models to include object-oriented concepts Features: complex types, non-atomic values XML: Extensible Markup Language: Overview and uses Data exchange format Database Engine: Storage management: file interaction, data storage/retrieval Query processing: parsing, optimization, evaluation Transaction management: ensuring data integrity and consistency Database System Internals: Database architecture: centralized, client-server, distributed, cloud Database Users and Administrators: Different types of database users and their roles","title":"Lecture 1.5 - Intro to DBMS2.pdf (PDF file)"},{"location":"week1/Lecture%201.5%20-%20Intro%20to%20DBMS2/#lecture-15-intro-to-dbms2pdf-pdf-file","text":"Summary Module Overview This module provides an introduction to Database Management Systems (DBMS). Objectives Understand models of DBMS Learn about key components of a database engine Familiarize with database internals and architecture Topics Database Design: Logical design (schema design) Physical design (data layout) Design methodologies (Entity-Relationship Model, Normalization Theory) Object-Relational Data Models: Extension of relational models to include object-oriented concepts Features: complex types, non-atomic values XML: Extensible Markup Language: Overview and uses Data exchange format Database Engine: Storage management: file interaction, data storage/retrieval Query processing: parsing, optimization, evaluation Transaction management: ensuring data integrity and consistency Database System Internals: Database architecture: centralized, client-server, distributed, cloud Database Users and Administrators: Different types of database users and their roles","title":"Lecture 1.5 - Intro to DBMS2.pdf (PDF file)"},{"location":"week1/summary/","text":"Summary The query processor subsystem compiles and executes DDL and DML state- ments. Transaction management ensures that the database remains in a consistent (cor- rect) state despite system failures. The transaction manager ensures that concur- rent transaction executions proceed without con\ufb02icts. The architecture of a database system is greatly in\ufb02uenced by the underlying com- puter system on which the database system runs. Database systems can be central- ized, or parallel, involving multiple machines. Distributed databases span multiple geographically separated machines. Database applications are typically broken up into a front-end part that runs at client machines and a part that runs at the backend. In two-tier architectures, the front end directly communicates with a database running at the back end. In three- tier architectures, the back end part is itself broken up into an application server and a database server. There are four di\ufb00erent types of database-system users, di\ufb00erentiated by the way they expect to interact with the system. Di\ufb00erent types of user interfaces have been designed for the di\ufb00erent types of users. Data-analysis techniques attempt to automatically discover rules and patterns from data. The \ufb01eld of data mining combines knowledge-discovery techniques invented by arti\ufb01cial intelligence researchers and statistical analysts with e\ufb03cient imple- mentation techniques that enable them to be used on extremely large databases. Database-management system (DBMS) Database-system applications Online transaction processing Data analytics File-processing systems Data inconsistency Consistency constraints Data abstraction Physical level Logical level View level Instance Schema Physical schema Logical schema Subschema Physical data independence Data models Entity-relationship model Relational data model Semi-structured data model Object-based data model Database languages Data-de\ufb01nition language Data-manipulation language Procedural DML Declarative DML nonprocedural DML Query language Data-de\ufb01nition language Domain Constraints Referential Integrity Authorization Read authorization Insert authorization Update authorization Delete authorization Metadata Application program Database design Conceptual design Normalization Speci\ufb01cation of functional re- quirements Physical-design phase Database Engine Storage manager Authorization and integrity manager Transaction manager File manager Bu\ufb00er manager Data \ufb01les Data dictionary Indices Query processor DDL interpreter DML compiler Query optimization Query evaluation engine Transaction Atomicity Consistency Durability Recovery manager Failure recovery Concurrency-control manager Database Architecture Centralized Parallel Distributed Database Application Architecture Two-tier Three-tier Application server Database administrator (DBA) This chapter has described several major advantages of a database system. What are two disadvantages? List \ufb01ve ways in which the type declaration system of a language such as Java or C++ di\ufb00ers from the data de\ufb01nition language used in a database. 3 List six major steps that you would take in setting up a database for a particular enterprise. 4Suppose you want to build a video site similar to YouTube. Consider each of the points listed in Section - 2 as disadvantages of keeping data in a \ufb01le-processing system. Discuss the relevance of each of these points to the storage of actual video data, and to metadata about the video, such as title, the user who uploaded it, tags, and which users viewed it. 5Keyword queries used in web search are quite di\ufb00erent from database queries. List key di\ufb00erences between the two, in terms of the way the queries are speci\ufb01ed and in terms of what is the result of a query. List four applications you have used that most likely employed a database system to store persistent data. 7List four signi\ufb01cant di\ufb00erences between a \ufb01le-processing system and a DBMS. 8Explain the concept of physical data independence and its importance in database systems. 9List \ufb01ve responsibilities of a database-management system. For each responsi- bility, explain the problems that would arise if the responsibility were not dis- charged. 10List at least two reasons why database systems support data manipulation using a declarative query language such as SQL, instead of just providing a library of C or C++ functions to carry out data manipulation. 11Assume that two students are trying to register for a course in which there is only one open seat. What component of a database system prevents both students from being given that last seat? 12Explain the di\ufb00erence between two-tier and three-tier application architectures. Which is better suited for web applications? Why? 13List two features developed in the 2000s and that help database systems handle data-analytics workloads. 14Explain why NoSQL systems emerged in the 2000s, and brie\ufb02y contrast their features with traditional database systems. 15Describe at least three tables that might be used to store information in a social- networking system such as Facebook.","title":"Summary"},{"location":"week1/textbook/","text":"","title":"Textbook"},{"location":"week1/week1/","text":"[X] lec class [X] PPA [X] GRPA [X] GA [X] instructor section 1 [X] instructor section 2 [X] TA session 1 [X] TA session 2 [X] Text book","title":"Week1"},{"location":"week2/Lecture%202.1%20-%20Introduction%20to%20Relational%20Model1/","text":"Lecture 2.1 - Introduction to Relational Model1 Summary This module introduces the relational model for database management systems. It covers: Attributes and Types: Attributes represent data characteristics and have specific types, such as alphanumeric strings alpha strings dates numbers alpha strings each attributes has to atomic - same datatype that is indivisble null - spl value for every domain indicates that value is unknown domain is the allowed value for each attribute Schema and Instance: Schema defines the structure of a relation (table) specifying attributes and their types. Instance is the current state of a relation, represented as a table with rows (tuples). A1 , A2 , \u00b7 \u00b7 \u00b7 , An are attributes R = (A1 , A2 , \u00b7 \u00b7 \u00b7 , An ) is a relation schema Example: instructor = (ID, name, dept name, salary ) Formally, given sets D1 , D2 , \u00b7 \u00b7 \u00b7 , Dn a relation r is a subset of D 1 \u00d7 D2 \u00d7 \u00b7 \u00b7 \u00b7 \u00d7 Dn instructor \u2261 (String (5) \u00d7 String \u00d7 String \u00d7 Number +), where D \u2208 String (5), name \u2208 String , dept name \u2208 String , and salary \u2208 Number + imp thing to note : Order of tuples / rows is irrelevant (tuples may be stored in an arbitrary order) No two tuples / rows may be identical Keys: A superkey uniquely identifies tuples in a relation. Example: {ID} and {ID, name} are both superkeys of instructor A candidate key is a minimal superkey. Example: {ID} is a candidate key for instructor A primary key is the selected candidate key used for unique identification. A surrogate key (or synthetic key) in a database is a unique identifier for either an entity in the modeled world or an object in the database eg : transaction id of amazon the transaction id is only valid in the order life time . Secondary / Alternate Key: {First Name, Last Name}, Aadhaar # Simple Key: Consists of a single attribute Composite Key: {First Name, Last Name} Consists of more than one attribute to uniquely identify an entity occurrence One or more of the attributes, which make up the key, are not simple keys in their own right Relational Query Languages: Relational algebra, a procedural language, is introduced as a tool for manipulating relations using basic operations. Other \"pure\" languages exist but are not covered here.","title":"Lecture 2.1 - Introduction to Relational Model1"},{"location":"week2/Lecture%202.1%20-%20Introduction%20to%20Relational%20Model1/#lecture-21-introduction-to-relational-model1","text":"Summary This module introduces the relational model for database management systems. It covers: Attributes and Types: Attributes represent data characteristics and have specific types, such as alphanumeric strings alpha strings dates numbers alpha strings each attributes has to atomic - same datatype that is indivisble null - spl value for every domain indicates that value is unknown domain is the allowed value for each attribute Schema and Instance: Schema defines the structure of a relation (table) specifying attributes and their types. Instance is the current state of a relation, represented as a table with rows (tuples). A1 , A2 , \u00b7 \u00b7 \u00b7 , An are attributes R = (A1 , A2 , \u00b7 \u00b7 \u00b7 , An ) is a relation schema Example: instructor = (ID, name, dept name, salary ) Formally, given sets D1 , D2 , \u00b7 \u00b7 \u00b7 , Dn a relation r is a subset of D 1 \u00d7 D2 \u00d7 \u00b7 \u00b7 \u00b7 \u00d7 Dn instructor \u2261 (String (5) \u00d7 String \u00d7 String \u00d7 Number +), where D \u2208 String (5), name \u2208 String , dept name \u2208 String , and salary \u2208 Number + imp thing to note : Order of tuples / rows is irrelevant (tuples may be stored in an arbitrary order) No two tuples / rows may be identical Keys: A superkey uniquely identifies tuples in a relation. Example: {ID} and {ID, name} are both superkeys of instructor A candidate key is a minimal superkey. Example: {ID} is a candidate key for instructor A primary key is the selected candidate key used for unique identification. A surrogate key (or synthetic key) in a database is a unique identifier for either an entity in the modeled world or an object in the database eg : transaction id of amazon the transaction id is only valid in the order life time . Secondary / Alternate Key: {First Name, Last Name}, Aadhaar # Simple Key: Consists of a single attribute Composite Key: {First Name, Last Name} Consists of more than one attribute to uniquely identify an entity occurrence One or more of the attributes, which make up the key, are not simple keys in their own right Relational Query Languages: Relational algebra, a procedural language, is introduced as a tool for manipulating relations using basic operations. Other \"pure\" languages exist but are not covered here.","title":"Lecture 2.1 - Introduction to Relational Model1"},{"location":"week2/Lecture%202.2%20-%20Introduction%20to%20Relational%20Model2/","text":"Lecture 2.2 - Introduction to Relational Model2 Summary Introduction to Relational Model Module Objectives To understand relational algebra To familiarize with the operators of relational algebra Module Outline Operations Select Project Union Difference Intersection Cartesian Product Natural Join Aggregate Operations Relational Operators Select Operation: Selects rows (tuples) that meet a specified condition. \u2022 Relation r \u2022 \u03c3A=B\u2227D>5(r) \u2227 means and student = Roll Name Age 1 A 20 2 B 21 3 C 19 \\[ \\sigma_{roll=2}(student) \\] ROLL Name Age 2 B 21 \\[ \\pi_{name} \\sigma_{roll=2}(student) \\] Name B first condition to select and then projection Project Operation: Selects columns (Attributes) of a relation. \u2022 Relation r \u2022 \u03c0A,C (r) student = Roll Name Age 1 A 20 2 B 21 3 C 19 \\[ \\pi_{Roll}(student) = \\] Roll 1 2 3 \\[ \\pi_{Roll, Name}(student) = \\] Roll Name 1 A 2 B 3 C The projection will always give distinct rows Union of two relations: Combines the rows of two relations, eliminating duplicates. Relation r,s r \u222a s Union Operation Basics : The union operator in relational algebra functions similarly to set theory, combining elements from two sets and eliminating duplicates, ensuring each element appears only once. Requirements for Union : To perform a union on two tables in a database, they must have the same number of columns, and the data types (domains) of these columns must match. Order and Matching : The order of columns is crucial when performing a union. If the order is mismatched between the tables (e.g., numeric first in one and character first in the other), the union will fail, resulting in null values. Maintaining the correct order ensures the union operates correctly. Set difference of two relations: Removes rows from the first relation that are also in the second relation. Relation r,s (r \u2212 s) No of col or attriubutes have to same Set intersection of two relations: Returns rows that are common to both relations. \u2022 Relation r,s r \u2229 s Joining two relations \u2013 Cartesian-product: Combines all rows from the first relation with all rows from the second relation. \u2022 Relation r,s \u2022 r \u00d7 s when you have two atrributes with same name we remane the atrributes in cartseian product \\[ R_1 = \\] A B C 1 2 3 2 1 4 \\[ R_2 = \\] C D E 3 4 5 2 1 2 \\[ R_1 \\ X \\ R_2 = \\] A B \\(R_1.C\\) \\(R_2.C\\) D E 1 2 3 3 4 5 1 2 3 2 1 2 2 1 4 3 4 5 2 1 4 2 1 2 Natural Join: Joins two relations on the common attributes, eliminating duplicate columns. \u2022 Let r and s be relations on schemas R and S respectively. Then, the \u201cnatural join\u201d of relations R and S is a relation on schema R \u222a S obtained as follows: \u25e6 Consider each pair of tuples tr from r and ts from s. \u25e6 If tr and ts have the same value on each of the attributes in R \u2229 S, add a tuple t to the result, where . t has the same value as tr on r . t has the same value as ts on s Aggregation Operators Aggregate Operators: Perform calculations on groups of rows. SUM: Computes the sum of a specified column. AVG: Computes the average of a specified column. MAX: Computes the maximum value of a specified column. MIN: Computes the minimum value of a specified column. Notes about Relational Languages Each query input is a table (or set of tables). Each query output is a table. All data in the output table appears in one of the input tables. Relational Algebra is not Turing complete. Summary of Relational Algebra Operators Operator Description \u03c3 Select \u03c0 Project \u222a Union \u2212 Difference \u2229 Intersection \u00d7 Cartesian Product $ \\rho$ Rename \\(\\bowtie\\) Natural Join SUM Computes the sum of a specified column AVG Computes the average of a specified column MAX Computes the maximum value of a specified column MIN Computes the minimum value of a specified column Module Summary Introduced relational algebra Familiarized with the operators of relational algebra","title":"Lecture 2.2 - Introduction to Relational Model2"},{"location":"week2/Lecture%202.2%20-%20Introduction%20to%20Relational%20Model2/#lecture-22-introduction-to-relational-model2","text":"Summary Introduction to Relational Model Module Objectives To understand relational algebra To familiarize with the operators of relational algebra Module Outline Operations Select Project Union Difference Intersection Cartesian Product Natural Join Aggregate Operations Relational Operators","title":"Lecture 2.2 - Introduction to Relational Model2"},{"location":"week2/Lecture%202.2%20-%20Introduction%20to%20Relational%20Model2/#select-operation-selects-rows-tuples-that-meet-a-specified-condition","text":"\u2022 Relation r \u2022 \u03c3A=B\u2227D>5(r) \u2227 means and student = Roll Name Age 1 A 20 2 B 21 3 C 19 \\[ \\sigma_{roll=2}(student) \\] ROLL Name Age 2 B 21 \\[ \\pi_{name} \\sigma_{roll=2}(student) \\] Name B first condition to select and then projection","title":"Select Operation: Selects rows (tuples) that meet a specified condition."},{"location":"week2/Lecture%202.2%20-%20Introduction%20to%20Relational%20Model2/#project-operation-selects-columns-attributes-of-a-relation","text":"\u2022 Relation r \u2022 \u03c0A,C (r) student = Roll Name Age 1 A 20 2 B 21 3 C 19 \\[ \\pi_{Roll}(student) = \\] Roll 1 2 3 \\[ \\pi_{Roll, Name}(student) = \\] Roll Name 1 A 2 B 3 C The projection will always give distinct rows","title":"Project Operation: Selects columns (Attributes) of a relation."},{"location":"week2/Lecture%202.2%20-%20Introduction%20to%20Relational%20Model2/#union-of-two-relations-combines-the-rows-of-two-relations-eliminating-duplicates","text":"Relation r,s r \u222a s Union Operation Basics : The union operator in relational algebra functions similarly to set theory, combining elements from two sets and eliminating duplicates, ensuring each element appears only once. Requirements for Union : To perform a union on two tables in a database, they must have the same number of columns, and the data types (domains) of these columns must match. Order and Matching : The order of columns is crucial when performing a union. If the order is mismatched between the tables (e.g., numeric first in one and character first in the other), the union will fail, resulting in null values. Maintaining the correct order ensures the union operates correctly.","title":"Union of two relations: Combines the rows of two relations, eliminating duplicates."},{"location":"week2/Lecture%202.2%20-%20Introduction%20to%20Relational%20Model2/#set-difference-of-two-relations-removes-rows-from-the-first-relation-that-are-also-in-the-second-relation","text":"Relation r,s (r \u2212 s) No of col or attriubutes have to same","title":"Set difference of two relations: Removes rows from the first relation that are also in the second relation."},{"location":"week2/Lecture%202.2%20-%20Introduction%20to%20Relational%20Model2/#set-intersection-of-two-relations-returns-rows-that-are-common-to-both-relations","text":"\u2022 Relation r,s r \u2229 s","title":"Set intersection of two relations: Returns rows that are common to both relations."},{"location":"week2/Lecture%202.2%20-%20Introduction%20to%20Relational%20Model2/#joining-two-relations-cartesian-product-combines-all-rows-from-the-first-relation-with-all-rows-from-the-second-relation","text":"\u2022 Relation r,s \u2022 r \u00d7 s when you have two atrributes with same name we remane the atrributes in cartseian product \\[ R_1 = \\] A B C 1 2 3 2 1 4 \\[ R_2 = \\] C D E 3 4 5 2 1 2 \\[ R_1 \\ X \\ R_2 = \\] A B \\(R_1.C\\) \\(R_2.C\\) D E 1 2 3 3 4 5 1 2 3 2 1 2 2 1 4 3 4 5 2 1 4 2 1 2 Natural Join: Joins two relations on the common attributes, eliminating duplicate columns. \u2022 Let r and s be relations on schemas R and S respectively. Then, the \u201cnatural join\u201d of relations R and S is a relation on schema R \u222a S obtained as follows: \u25e6 Consider each pair of tuples tr from r and ts from s. \u25e6 If tr and ts have the same value on each of the attributes in R \u2229 S, add a tuple t to the result, where . t has the same value as tr on r . t has the same value as ts on s Aggregation Operators Aggregate Operators: Perform calculations on groups of rows. SUM: Computes the sum of a specified column. AVG: Computes the average of a specified column. MAX: Computes the maximum value of a specified column. MIN: Computes the minimum value of a specified column. Notes about Relational Languages Each query input is a table (or set of tables). Each query output is a table. All data in the output table appears in one of the input tables. Relational Algebra is not Turing complete. Summary of Relational Algebra Operators Operator Description \u03c3 Select \u03c0 Project \u222a Union \u2212 Difference \u2229 Intersection \u00d7 Cartesian Product $ \\rho$ Rename \\(\\bowtie\\) Natural Join SUM Computes the sum of a specified column AVG Computes the average of a specified column MAX Computes the maximum value of a specified column MIN Computes the minimum value of a specified column Module Summary Introduced relational algebra Familiarized with the operators of relational algebra","title":"Joining two relations \u2013 Cartesian-product: Combines all rows from the first relation with all rows from the second relation."},{"location":"week2/Lecture%202.3%20-%20Introduction%20to%20SQL1/","text":"Lecture 2.3 - Introduction to SQL1 Summary Module 08: Introduction to SQL Objectives Understand relational query language Understand data definition and basic query structure Outline History of SQL Data Definition Language (DDL) Create Table Integrity Constraints Update Table Data Manipulation Language (DML): Query Structure Select Clause Where Clause From Clause History of SQL IBM developed Structured English Query Language (SEQUEL) as part of System R project. Renamed Structured Query Language (SQL: pronounced still as SEQUEL) ANSI and ISO standard SQL: SQL-86 First formalized by ANSI SQL-89 + Integrity Constraints SQL-92 Major revision (ISO/IEC 9075 standard), De-facto Industry Standard SQL:1999 + Regular Expression Matching, Recursive Queries, Triggers, Support for Procedural and Control Flow Statements, Nonscalar types (Arrays), and Some OO features (structured types), Embedding SQL in Java (SQL/OLB), and Embedding Java in SQL (SQL/JRT) SQL:2003 + XML features (SQL/XML), Window Functions, Standardized Sequences, and Columns with Auto-generated Values (identity columns) SQL:2006 + Ways of importing and storing XML data in an SQL database, manipulating it within the database, and publishing both XML and conventional SQL-data in XML form SQL:2008 Legalizes ORDER BY outside Cursor Definitions INSTEAD OF Triggers, TRUNCATE Statement, and FETCH Clause SQL:2011 + Temporal Data (PERIOD FOR) Enhancements for Window Functions and FETCH Clause SQL:2016 + Row Pattern Matching, Polymorphic Table Functions, and JSON SQL:2019 + Multidimensional Arrays (MDarray type and operators) History of Query Language: Compliance SQL is the de facto industry standard today for relational or structred data systems (that is, SQL as a protocol), but there are many alternatives to writing SQL in the applications These alternatives have been implemented in the form of frontends for working with relational databases. Some examples of a frontend include (for a section of languages): \u25e6 SchemeQL and CLSQL, which are probably the most flexible, owing to their Lisp heritage, but they also look like a lot more like SQL than other frontends \u25e6 LINQ (in .Net) \u25e6 ScalaQL and ScalaQuery (in Scala) \u25e6 SqlStatement, ActiveRecord and many others in Ruby \u25e6 HaskellDB \u25e6 ...the list goes on for many other languages. History of Query Language: Alternatives There aren\u2019t any alternatives to SQL for speaking to relational databases (that is, SQL as a protocol), but there are many alternatives to writing SQL in the applications These alternatives have been implemented in the form of frontends for working with relational databases. Some examples of a frontend include (for a section of languages): \u25e6 SchemeQL and CLSQL, which are probably the most flexible, owing to their Lisp heritage, but they also look like a lot more like SQL than other frontends \u25e6 LINQ (in .Net) \u25e6 ScalaQL and ScalaQuery (in Scala) \u25e6 SqlStatement, ActiveRecord and many others in Ruby \u25e6 HaskellDB \u25e6 ...the list goes on for many other languages. Source: What are good alternatives to SQL (the language)? History of Query Language: Derivatives There are several query languages that are derived from or inspired by SQL. Of these, the most popular and effective is SPARQL. \u25e6 SPARQL (pronounced sparkle, a recursive acronym for SPARQL Protocol and RDF Query Language) is an RDF query language . A semantic query language for databases - able to retrieve and manipulate data stored in Resource Description Framework (RDF) format. . It has been standardized by the W3C Consortium as key technology of the semantic web . Versions: \u2212 SPARQL 1.0 (January 2008) \u2212 SPARQL 1.1 (March, 2013) . Used as the query languages for several NoSQL systems - particularly the Graph Databases that use RDF as store Data Definition Language (DDL) The SQL data-definition language (DDL) allows the specification of information about relations, including: The Schema for each Relation The Domain of values associated with each Attribute Integrity Constraints And, as we will see later, also other information such as \u25e6 The set of Indices to be maintained for each relations \u25e6 Security and Authorization information for each relation \u25e6 The Physical Storage Structure of each relation on disk Domain Types in SQL char(n). Fixed length character string, with user-specified length n varchar(n). Variable length character strings, with user-specified maximum length n int. Integer (a finite subset of the integers that is machine-dependent) smallint(n). Small integer (a machine-dependent subset of the integer domain type) numeric(p, d). Fixed point number, with user-specified precision of p digits, with d digits to the right of decimal point. (ex., numeric(3, 1), allows 44.5 to be stores exactly, but not 444.5 or 0.32) real, double precision. Floating point and double-precision floating point numbers, with machine-dependent precision float(n). Floating point number, with user-specified precision of at least n digits More are covered in Chapter 4 Create Table Construct An SQL relation is defined using the create table command: create table r (A1D1, A2D2, . . . , AnDn), (integrity-constraint1), . . . (integrity-constraintk )); \u25e6 r is the name of the relation \u25e6 each Ai is an attribute name in the schema of relation r \u25e6 Di is the data type of values in the domain of attribute Ai Create Table Construct (2) create table instructor ( ID char(5), name varchar(20) dept name varchar(20) salary numeric(8, 2)); Create Table Construct (3): Integrity Constraints not null primary key (A1, . . . , An) foreign key (Am, . . . , An) references r create table instructor (ID char(5),name varchar(20) not null,dept name varchar(20),salary numeric(8, 2),primary key (ID),foreign key (dept name) references department)); primary key declaration on an attribute automatically ensures not null University Schema Create Table Construct (4): More Relations create table student ( ID varchar(5), name varchar(20) not null, dept name varchar(20), tot cred numeric(3, 0), primary key (ID), foreign key (dept name) references department); create table course ( course id varchar(8), title varchar(50), dept name varchar(20), credits numeric(2, 0), primary key (course id), foreign key (dept name) references department); create table takes ( ID varchar(5), course id varchar(8), sec id varchar(8), semester varchar(6), year numeric(4, 0), grade varchar(2), primary key (ID, course id, sec id, semester, year ), foreign key (ID) references student foreign key (course id, sec id, semester, year ) references section); \u2022 Note: sec id can be dropped from primary key above, to ensure a student cannot be registered for two sections of the same course in the same semester Update Tables Insert (DML command) \u25e6 insert into instructor values (\u201810211\u2019, \u2018Smith\u2019, \u2018Biology\u2019, 66000); Delete (DML command) \u25e6 Remove all tuples from the student relation delete from student Drop Table (DDL command) \u25e6 drop table r Alter (DDL command) \u25e6 alter table r add A D . Where A is the name of the attribute to be added to relation r and D is the domain of A . All existing tuples in the relation are assigned null as the value for the new attribute \u25e6 alter table r drop A . Where A is the name of an attribute of relation r . Dropping of attributes not supported by many databases Data Manipulation Language (DML): Query Structure A typical SQL query has the form: select A1, A2, . . . , An,from r1,r2, ...,rmwhere P \u25e6 Ai represents an attribute from ri \u2019s \u25e6 ri represents a relation \u25e6 P is a predicate The result of an SQL query is a relation Basic Query Structure The select clause lists the attributes desired in the result of a query \u25e6 Corresponds to the projection operation of the relational algebra","title":"Lecture 2.3 - Introduction to SQL1"},{"location":"week2/Lecture%202.3%20-%20Introduction%20to%20SQL1/#lecture-23-introduction-to-sql1","text":"Summary Module 08: Introduction to SQL Objectives Understand relational query language Understand data definition and basic query structure Outline History of SQL Data Definition Language (DDL) Create Table Integrity Constraints Update Table Data Manipulation Language (DML): Query Structure Select Clause Where Clause From Clause History of SQL IBM developed Structured English Query Language (SEQUEL) as part of System R project. Renamed Structured Query Language (SQL: pronounced still as SEQUEL) ANSI and ISO standard SQL: SQL-86 First formalized by ANSI SQL-89 + Integrity Constraints SQL-92 Major revision (ISO/IEC 9075 standard), De-facto Industry Standard SQL:1999 + Regular Expression Matching, Recursive Queries, Triggers, Support for Procedural and Control Flow Statements, Nonscalar types (Arrays), and Some OO features (structured types), Embedding SQL in Java (SQL/OLB), and Embedding Java in SQL (SQL/JRT) SQL:2003 + XML features (SQL/XML), Window Functions, Standardized Sequences, and Columns with Auto-generated Values (identity columns) SQL:2006 + Ways of importing and storing XML data in an SQL database, manipulating it within the database, and publishing both XML and conventional SQL-data in XML form SQL:2008 Legalizes ORDER BY outside Cursor Definitions INSTEAD OF Triggers, TRUNCATE Statement, and FETCH Clause SQL:2011 + Temporal Data (PERIOD FOR) Enhancements for Window Functions and FETCH Clause SQL:2016 + Row Pattern Matching, Polymorphic Table Functions, and JSON SQL:2019 + Multidimensional Arrays (MDarray type and operators) History of Query Language: Compliance SQL is the de facto industry standard today for relational or structred data systems (that is, SQL as a protocol), but there are many alternatives to writing SQL in the applications These alternatives have been implemented in the form of frontends for working with relational databases. Some examples of a frontend include (for a section of languages): \u25e6 SchemeQL and CLSQL, which are probably the most flexible, owing to their Lisp heritage, but they also look like a lot more like SQL than other frontends \u25e6 LINQ (in .Net) \u25e6 ScalaQL and ScalaQuery (in Scala) \u25e6 SqlStatement, ActiveRecord and many others in Ruby \u25e6 HaskellDB \u25e6 ...the list goes on for many other languages. History of Query Language: Alternatives There aren\u2019t any alternatives to SQL for speaking to relational databases (that is, SQL as a protocol), but there are many alternatives to writing SQL in the applications These alternatives have been implemented in the form of frontends for working with relational databases. Some examples of a frontend include (for a section of languages): \u25e6 SchemeQL and CLSQL, which are probably the most flexible, owing to their Lisp heritage, but they also look like a lot more like SQL than other frontends \u25e6 LINQ (in .Net) \u25e6 ScalaQL and ScalaQuery (in Scala) \u25e6 SqlStatement, ActiveRecord and many others in Ruby \u25e6 HaskellDB \u25e6 ...the list goes on for many other languages. Source: What are good alternatives to SQL (the language)? History of Query Language: Derivatives There are several query languages that are derived from or inspired by SQL. Of these, the most popular and effective is SPARQL. \u25e6 SPARQL (pronounced sparkle, a recursive acronym for SPARQL Protocol and RDF Query Language) is an RDF query language . A semantic query language for databases - able to retrieve and manipulate data stored in Resource Description Framework (RDF) format. . It has been standardized by the W3C Consortium as key technology of the semantic web . Versions: \u2212 SPARQL 1.0 (January 2008) \u2212 SPARQL 1.1 (March, 2013) . Used as the query languages for several NoSQL systems - particularly the Graph Databases that use RDF as store Data Definition Language (DDL) The SQL data-definition language (DDL) allows the specification of information about relations, including: The Schema for each Relation The Domain of values associated with each Attribute Integrity Constraints And, as we will see later, also other information such as \u25e6 The set of Indices to be maintained for each relations \u25e6 Security and Authorization information for each relation \u25e6 The Physical Storage Structure of each relation on disk Domain Types in SQL char(n). Fixed length character string, with user-specified length n varchar(n). Variable length character strings, with user-specified maximum length n int. Integer (a finite subset of the integers that is machine-dependent) smallint(n). Small integer (a machine-dependent subset of the integer domain type) numeric(p, d). Fixed point number, with user-specified precision of p digits, with d digits to the right of decimal point. (ex., numeric(3, 1), allows 44.5 to be stores exactly, but not 444.5 or 0.32) real, double precision. Floating point and double-precision floating point numbers, with machine-dependent precision float(n). Floating point number, with user-specified precision of at least n digits More are covered in Chapter 4 Create Table Construct An SQL relation is defined using the create table command: create table r (A1D1, A2D2, . . . , AnDn), (integrity-constraint1), . . . (integrity-constraintk )); \u25e6 r is the name of the relation \u25e6 each Ai is an attribute name in the schema of relation r \u25e6 Di is the data type of values in the domain of attribute Ai Create Table Construct (2) create table instructor ( ID char(5), name varchar(20) dept name varchar(20) salary numeric(8, 2)); Create Table Construct (3): Integrity Constraints not null primary key (A1, . . . , An) foreign key (Am, . . . , An) references r create table instructor (ID char(5),name varchar(20) not null,dept name varchar(20),salary numeric(8, 2),primary key (ID),foreign key (dept name) references department)); primary key declaration on an attribute automatically ensures not null University Schema Create Table Construct (4): More Relations create table student ( ID varchar(5), name varchar(20) not null, dept name varchar(20), tot cred numeric(3, 0), primary key (ID), foreign key (dept name) references department); create table course ( course id varchar(8), title varchar(50), dept name varchar(20), credits numeric(2, 0), primary key (course id), foreign key (dept name) references department); create table takes ( ID varchar(5), course id varchar(8), sec id varchar(8), semester varchar(6), year numeric(4, 0), grade varchar(2), primary key (ID, course id, sec id, semester, year ), foreign key (ID) references student foreign key (course id, sec id, semester, year ) references section); \u2022 Note: sec id can be dropped from primary key above, to ensure a student cannot be registered for two sections of the same course in the same semester Update Tables Insert (DML command) \u25e6 insert into instructor values (\u201810211\u2019, \u2018Smith\u2019, \u2018Biology\u2019, 66000); Delete (DML command) \u25e6 Remove all tuples from the student relation delete from student Drop Table (DDL command) \u25e6 drop table r Alter (DDL command) \u25e6 alter table r add A D . Where A is the name of the attribute to be added to relation r and D is the domain of A . All existing tuples in the relation are assigned null as the value for the new attribute \u25e6 alter table r drop A . Where A is the name of an attribute of relation r . Dropping of attributes not supported by many databases Data Manipulation Language (DML): Query Structure A typical SQL query has the form: select A1, A2, . . . , An,from r1,r2, ...,rmwhere P \u25e6 Ai represents an attribute from ri \u2019s \u25e6 ri represents a relation \u25e6 P is a predicate The result of an SQL query is a relation Basic Query Structure The select clause lists the attributes desired in the result of a query \u25e6 Corresponds to the projection operation of the relational algebra","title":"Lecture 2.3 - Introduction to SQL1"},{"location":"week2/Lecture%202.4%20-%20Introduction%20to%20SQL2/","text":"Lecture 2.4 - Introduction to SQL2 Summary Additional Basic Operations Cartesian Product Finds all possible combinations of tuples from two or more relations. Useful when selecting data based on relationships between tables. Example: Select all possible instructor-course pairs using Cartesian product: select * from instructor , teaches Rename AS Operation Allows renaming of relations and attributes using the as clause: old name as new name Optional keyword as may be omitted. String Values SQL includes a string-matching operator ( like ) for character string comparisons. Uses special characters: Percent (%) matches any substring Underscore (_) matches any character Example: Find instructors with \"dar\" in their name: select name from instructor where name like '%dar%' \u2022 Patterns are case sensitive \u2022 Pattern matching examples: \u25e6 \u2019Intro%\u2019 matches any string beginning with \u201cIntro\u201d \u25e6 \u2019%Comp%\u2019 matches any string containing \u201cComp\u201d as a substring \u25e6 \u2019- - - \u2019 matches any string of exactly three characters \u25e6 \u2019 _ _%\u2019 matches any string of at least two characters \u2022 SQL supports a variety of string operations such as \u25e6 concatenation (using \u201c||\u201d) \u25e6 converting from upper to lower case (and vice versa) \u25e6 finding string length, extracting substrings, et Order By Clause Orders the display of tuples in ascending or descending order. By default, it is in ascending order. Can order by multiple attributes. Example: Order by name in descending order: select distinct name from instructor order by name desc Select Top / Fetch Clause Limits the number of records returned in the output. Useful for large tables to avoid performance impact. Example: Select the top 10 distinct names from the instructor table: select top 10 distinct name from instructor Where Clause Predicates Allows selecting tuples that meet specified conditions. Uses comparison operators, logical operators, and functions. Between operator allows specifying a range of values. Example: Find instructors with salaries between $90,000 and $100,000: select name from instructor where salary between 90000 and 100000 In Operator Allows specifying multiple values in a where clause. Shorthand for multiple or conditions. Example: Find instructors in the 'Comp. Sci.' or 'Biology' departments: select name from instructor where dept name in ( 'Comp. Sci.' , 'Biology' ) Tuple comparison select name, course_id from instructor , teaches where (instructor.ID, dept name) = (teaches.ID, \u2019Biology\u2019); Duplicates ???? SQL handles duplicates based on multiset semantics. Number of copies of tuples in the result depends on the number of copies in the input relations. For example, if there are two copies of tuple (1, a) in r1 and three copies of tuple (2) in r2, then the expression: \u03a0 B ( r1 ) x r2 would result in six copies of tuple (a, 2).","title":"Lecture 2.4 - Introduction to SQL2"},{"location":"week2/Lecture%202.4%20-%20Introduction%20to%20SQL2/#lecture-24-introduction-to-sql2","text":"Summary","title":"Lecture 2.4 - Introduction to SQL2"},{"location":"week2/Lecture%202.4%20-%20Introduction%20to%20SQL2/#additional-basic-operations","text":"","title":"Additional Basic Operations"},{"location":"week2/Lecture%202.4%20-%20Introduction%20to%20SQL2/#cartesian-product","text":"Finds all possible combinations of tuples from two or more relations. Useful when selecting data based on relationships between tables. Example: Select all possible instructor-course pairs using Cartesian product: select * from instructor , teaches","title":"Cartesian Product"},{"location":"week2/Lecture%202.4%20-%20Introduction%20to%20SQL2/#rename-as-operation","text":"Allows renaming of relations and attributes using the as clause: old name as new name Optional keyword as may be omitted.","title":"Rename AS Operation"},{"location":"week2/Lecture%202.4%20-%20Introduction%20to%20SQL2/#string-values","text":"SQL includes a string-matching operator ( like ) for character string comparisons. Uses special characters: Percent (%) matches any substring Underscore (_) matches any character Example: Find instructors with \"dar\" in their name: select name from instructor where name like '%dar%' \u2022 Patterns are case sensitive \u2022 Pattern matching examples: \u25e6 \u2019Intro%\u2019 matches any string beginning with \u201cIntro\u201d \u25e6 \u2019%Comp%\u2019 matches any string containing \u201cComp\u201d as a substring \u25e6 \u2019- - - \u2019 matches any string of exactly three characters \u25e6 \u2019 _ _%\u2019 matches any string of at least two characters \u2022 SQL supports a variety of string operations such as \u25e6 concatenation (using \u201c||\u201d) \u25e6 converting from upper to lower case (and vice versa) \u25e6 finding string length, extracting substrings, et","title":"String Values"},{"location":"week2/Lecture%202.4%20-%20Introduction%20to%20SQL2/#order-by-clause","text":"Orders the display of tuples in ascending or descending order. By default, it is in ascending order. Can order by multiple attributes. Example: Order by name in descending order: select distinct name from instructor order by name desc","title":"Order By Clause"},{"location":"week2/Lecture%202.4%20-%20Introduction%20to%20SQL2/#select-top-fetch-clause","text":"Limits the number of records returned in the output. Useful for large tables to avoid performance impact. Example: Select the top 10 distinct names from the instructor table: select top 10 distinct name from instructor","title":"Select Top / Fetch Clause"},{"location":"week2/Lecture%202.4%20-%20Introduction%20to%20SQL2/#where-clause-predicates","text":"Allows selecting tuples that meet specified conditions. Uses comparison operators, logical operators, and functions. Between operator allows specifying a range of values. Example: Find instructors with salaries between $90,000 and $100,000: select name from instructor where salary between 90000 and 100000","title":"Where Clause Predicates"},{"location":"week2/Lecture%202.4%20-%20Introduction%20to%20SQL2/#in-operator","text":"Allows specifying multiple values in a where clause. Shorthand for multiple or conditions. Example: Find instructors in the 'Comp. Sci.' or 'Biology' departments: select name from instructor where dept name in ( 'Comp. Sci.' , 'Biology' ) Tuple comparison select name, course_id from instructor , teaches where (instructor.ID, dept name) = (teaches.ID, \u2019Biology\u2019);","title":"In Operator"},{"location":"week2/Lecture%202.4%20-%20Introduction%20to%20SQL2/#duplicates","text":"SQL handles duplicates based on multiset semantics. Number of copies of tuples in the result depends on the number of copies in the input relations. For example, if there are two copies of tuple (1, a) in r1 and three copies of tuple (2) in r2, then the expression: \u03a0 B ( r1 ) x r2 would result in six copies of tuple (a, 2).","title":"Duplicates ????"},{"location":"week2/Lecture%202.5%20-%20Introduction%20to%20SQL3/","text":"Lecture 2.5 - Introduction to SQL3 Summary Introduction This module provides an overview of set operations, null values, and aggregation in SQL/3. It introduces the concepts of set union, intersection, and exception, as well as the handling of null values and aggregate functions. The module concludes with a summary of the key points covered. Objectives Upon completion of this module, students will be able to: Understand and apply set operations (union, intersection, except) Handle null values in SQL queries Use aggregate functions (avg, min, max, sum, count) Group data using the GROUP BY clause Filter grouped data using the HAVING clause Outline Set Operations Null Values Three-Valued Logic Aggregate Functions GROUP BY HAVING Null Values with Aggregates Set Operations Set operations in SQL/3 allow you to combine or compare the results of two or more queries. The three most common set operations are union, intersection, and except. Union: Returns all unique rows from both input queries. Intersection: Returns only the rows that are common to both input queries. Except: Returns all rows from the first input query that are not present in the second input query. Null Values Null values represent the absence of a value or an unknown value in SQL/3. They are distinct from zero or empty strings. usage : is null or is not null Three-Valued Logic Due to the inclusion of null values, SQL/3 uses a three-valued logic system, where a predicate can be evaluated as true, false, or unknown. True: If the predicate is satisfied without any null values. False: If the predicate is not satisfied, or if it involves null values. Unknown: If the predicate involves a comparison with a null value. Aggregate Functions Aggregate functions operate on a group of values and return a single result. Some common aggregate functions include: AVG: Average value MIN: Minimum value MAX: Maximum value SUM: Sum of values COUNT: Number of values GROUP BY The GROUP BY clause is used to group the results of a query based on one or more attributes. It allows for aggregation and filtering of data within each group. HAVING The HAVING clause is similar to the WHERE clause, but it is used to filter grouped data. It applies predicates to the aggregate values rather than the individual rows. Null Values with Aggregates Aggregate functions ignore null values unless the COUNT( ) function is used. COUNT( ) counts all rows, regardless of whether they contain null values. Module Summary This module has covered the following key concepts: Set operations (union, intersection, except) Null values and three-valued logic Aggregate functions (avg, min, max, sum, count) GROUP BY and HAVING clauses Handling null values with aggregates These concepts are essential for working with data in SQL/3. Understanding these concepts will enable you to perform complex data analysis and manipulation tasks efficiently.","title":"Lecture 2.5 - Introduction to SQL3"},{"location":"week2/Lecture%202.5%20-%20Introduction%20to%20SQL3/#lecture-25-introduction-to-sql3","text":"Summary Introduction This module provides an overview of set operations, null values, and aggregation in SQL/3. It introduces the concepts of set union, intersection, and exception, as well as the handling of null values and aggregate functions. The module concludes with a summary of the key points covered. Objectives Upon completion of this module, students will be able to: Understand and apply set operations (union, intersection, except) Handle null values in SQL queries Use aggregate functions (avg, min, max, sum, count) Group data using the GROUP BY clause Filter grouped data using the HAVING clause Outline Set Operations Null Values Three-Valued Logic Aggregate Functions GROUP BY HAVING Null Values with Aggregates Set Operations Set operations in SQL/3 allow you to combine or compare the results of two or more queries. The three most common set operations are union, intersection, and except. Union: Returns all unique rows from both input queries. Intersection: Returns only the rows that are common to both input queries. Except: Returns all rows from the first input query that are not present in the second input query. Null Values Null values represent the absence of a value or an unknown value in SQL/3. They are distinct from zero or empty strings. usage : is null or is not null Three-Valued Logic Due to the inclusion of null values, SQL/3 uses a three-valued logic system, where a predicate can be evaluated as true, false, or unknown. True: If the predicate is satisfied without any null values. False: If the predicate is not satisfied, or if it involves null values. Unknown: If the predicate involves a comparison with a null value. Aggregate Functions Aggregate functions operate on a group of values and return a single result. Some common aggregate functions include: AVG: Average value MIN: Minimum value MAX: Maximum value SUM: Sum of values COUNT: Number of values GROUP BY The GROUP BY clause is used to group the results of a query based on one or more attributes. It allows for aggregation and filtering of data within each group. HAVING The HAVING clause is similar to the WHERE clause, but it is used to filter grouped data. It applies predicates to the aggregate values rather than the individual rows. Null Values with Aggregates Aggregate functions ignore null values unless the COUNT( ) function is used. COUNT( ) counts all rows, regardless of whether they contain null values. Module Summary This module has covered the following key concepts: Set operations (union, intersection, except) Null values and three-valued logic Aggregate functions (avg, min, max, sum, count) GROUP BY and HAVING clauses Handling null values with aggregates These concepts are essential for working with data in SQL/3. Understanding these concepts will enable you to perform complex data analysis and manipulation tasks efficiently.","title":"Lecture 2.5 - Introduction to SQL3"},{"location":"week2/TRC/","text":"Tuple Relational Calculus (TRC) is a non-procedural query language used in relational databases, focusing on tuples (rows) and utilizing first-order logic to express queries. TRC uses the format { T | P(T) }, where T represents the resulting tuple and P(T) is a predicate or condition that must be satisfied for T to be included in the result. Unlike relational algebra, which is procedural, TRC specifies what to retrieve without detailing how to retrieve it, making it non-procedural. TRC supports operations similar to relational algebra, such as conjunction (AND), disjunction (OR), and negation (NOT), and employs existential (\u2203) and universal (\u2200) quantifiers to form conditions. Both TRC and relational algebra have the same expressive power, allowing the same queries to be written in either language, although TRC requires careful handling of unsafe expressions to avoid infinite loops.","title":"TRC"},{"location":"week2/check_list/","text":"[ ] Text Book [X] slides [ ] weekly assigment [X] lecture [ ] live session [ ] text book activity","title":"Check list"},{"location":"week2/inst_sec/","text":"columns - attribute rows - tuple Primary keys: not null uniquie Table will have one Primary key multiple candiates key Domain set of allowed values for each attribute is called domain primary key is not nullable Atomic values - it cant mean broken down into smaller junks eg : Schema $$ R = (A_1, A_2, ..... A_n) \\ \\ \\\\ Domain\\ D = (D_1 , D_2, ....D_n) $$ order of rows or tuple is irrelevant no two tuple or row may be identical Keys A superkey uniquely identifies tuples in a relation. Example: {ID} and {ID, name} are both superkeys of instructor A candidate key is a minimal superkey. min no of super key to indentify a tuple. Example: {ID} is a candidate key for instructor A primary key is the selected candidate key used for unique identification. A surrogate key (or synthetic key) in a database is a unique identifier for either an entity in the modeled world or an object in the database eg : transaction id of amazon the transaction id is only valid in the order life time . Super key. Candidate key. Primary key. Surrogate key. Secondary / Alternate Key: {First Name, Last Name}, Aadhaar # Simple Key: Consists of a single attribute Aadhaar # Composite Key: {First Name, Last Name} Foreign key constrain : Value in a relation must appear in another he matches becomes the referencing relationship and host_team_id , guest_team_id is foreign key. Match_num is primary key in match_referees and matches. Compound key = two foreign key + simple key to used to identify an entity occurrence . Procedural and Non Procedural Language Operations Select Project Union Difference Intersection Cartesian Product Natural Join A relation is set. Selection \u2022 Relation r \\(\u03c3\\_{A=B\u2227D>5(r)}\\) \u2227 means and (A = B) intersect D > 5 Projection \u2022 Relation r \u2022 \\(\u03c0\\_{A,C}\\) (r) fetch the columns no dulipcates Union \u2022 Relation r,s \u2022 \\(r \u222a s\\) same nuumber of attributes or degree domains of the attributes has to be same Difference \\[ r-s \\] Intersection \\[ r \u2229 s = r- (r-s) \\] rows that are common to both relations. Cartesian Product \\[ R \\\\bowtie S \\] when you have two atrributes with same name we remane the atrributes in cartseian product. we rename the table using \\[ P_s(r) \\] renaming the table or relationship r to s \\[ r \\\\bowtie p_s(r) \\] self join and rename r to s = $ r\\bowtie s$ \\[ \\\\sigma\\_{A=C}(r \\\\bowtie s) \\] do a cross join of r and s and the find A = C not equal \\(\\<>\\) Inner Join Natural Join \\[ r\u2229s \\]","title":"Inst sec"},{"location":"week2/inst_sec/#domain","text":"set of allowed values for each attribute is called domain primary key is not nullable Atomic values - it cant mean broken down into smaller junks eg : Schema $$ R = (A_1, A_2, ..... A_n) \\ \\ \\\\ Domain\\ D = (D_1 , D_2, ....D_n) $$ order of rows or tuple is irrelevant no two tuple or row may be identical","title":"Domain"},{"location":"week2/inst_sec/#keys","text":"A superkey uniquely identifies tuples in a relation. Example: {ID} and {ID, name} are both superkeys of instructor A candidate key is a minimal superkey. min no of super key to indentify a tuple. Example: {ID} is a candidate key for instructor A primary key is the selected candidate key used for unique identification. A surrogate key (or synthetic key) in a database is a unique identifier for either an entity in the modeled world or an object in the database eg : transaction id of amazon the transaction id is only valid in the order life time . Super key. Candidate key. Primary key. Surrogate key. Secondary / Alternate Key: {First Name, Last Name}, Aadhaar # Simple Key: Consists of a single attribute Aadhaar # Composite Key: {First Name, Last Name} Foreign key constrain : Value in a relation must appear in another he matches becomes the referencing relationship and host_team_id , guest_team_id is foreign key. Match_num is primary key in match_referees and matches. Compound key = two foreign key + simple key to used to identify an entity occurrence .","title":"Keys"},{"location":"week2/inst_sec/#procedural-and-non-procedural-language","text":"","title":"Procedural and Non Procedural Language"},{"location":"week2/inst_sec/#operations","text":"Select Project Union Difference Intersection Cartesian Product Natural Join A relation is set.","title":"Operations"},{"location":"week2/inst_sec/#selection","text":"\u2022 Relation r \\(\u03c3\\_{A=B\u2227D>5(r)}\\) \u2227 means and (A = B) intersect D > 5","title":"Selection"},{"location":"week2/inst_sec/#projection","text":"\u2022 Relation r \u2022 \\(\u03c0\\_{A,C}\\) (r) fetch the columns no dulipcates","title":"Projection"},{"location":"week2/inst_sec/#union","text":"\u2022 Relation r,s \u2022 \\(r \u222a s\\) same nuumber of attributes or degree domains of the attributes has to be same","title":"Union"},{"location":"week2/inst_sec/#difference","text":"\\[ r-s \\]","title":"Difference"},{"location":"week2/inst_sec/#intersection","text":"\\[ r \u2229 s = r- (r-s) \\] rows that are common to both relations.","title":"Intersection"},{"location":"week2/inst_sec/#cartesian-product","text":"\\[ R \\\\bowtie S \\] when you have two atrributes with same name we remane the atrributes in cartseian product. we rename the table using \\[ P_s(r) \\] renaming the table or relationship r to s \\[ r \\\\bowtie p_s(r) \\] self join and rename r to s = $ r\\bowtie s$ \\[ \\\\sigma\\_{A=C}(r \\\\bowtie s) \\] do a cross join of r and s and the find A = C not equal \\(\\<>\\)","title":"Cartesian Product"},{"location":"week2/inst_sec/#inner-join","text":"","title":"Inner Join"},{"location":"week2/inst_sec/#natural-join","text":"\\[ r\u2229s \\]","title":"Natural Join"},{"location":"week2/live%20session_sat/","text":"SELECT * FROM sales WHERE discount LIKE '100\\%' ESCAPE '\\' ;","title":"Live session sat"},{"location":"week2/tutorial_2.1/","text":"","title":"Tutorial 2.1"},{"location":"week3/Lecture%203.1%20-%20SQL%20Examples/","text":"Lecture 3.1 - SQL Examples.pdf (PDF file) Summary Introduction summary of the concepts covered in SQL Examples, a module in Database Management Systems. The focus is on providing a comprehensive overview of the material, including select statements, Cartesian products, the AS keyword, WHERE clauses with AND/OR operators, string operations, ORDER BY statements, the IN operator, set operations (UNION, INTERSECT, EXCEPT), and aggregation functions (AVG, MIN, MAX, COUNT, SUM). SELECT Statements The SELECT statement is used to retrieve data from one or more tables. The basic syntax is: SELECT column_list FROM table_name WHERE conditions; The column_list specifies the columns to be retrieved, table_name specifies the table(s) to be queried, and the WHERE clause specifies any conditions that must be met for the rows to be included in the result. Cartesian Products / AS Keyword A Cartesian product is a combination of all rows from one table with all rows from another table. The AS keyword is used to assign an alias to a column or table. The syntax for a Cartesian product is: SELECT column_list FROM table_name1, table_name2 [AS alias]; WHERE Clauses with AND/OR Operators The WHERE clause is used to specify conditions that must be met for rows to be included in the result. The AND operator is used to combine multiple conditions that must all be true, and the OR operator is used to combine multiple conditions that only one must be true. The syntax is: WHERE condition1 [AND/OR condition2]...; String Operations String operations can be used to compare strings and extract substrings. The most common string operators are: = and !=: Equality and inequality \\< and >: Less than and greater than LIKE: Pattern matching SUBSTRING(): Extracts a substring ORDER BY Statements The ORDER BY statement is used to sort the results of a query. The syntax is: ORDER BY column_name [ASC/DESC]; The ASC keyword specifies ascending order, and the DESC keyword specifies descending order. IN Operator The IN operator is used to check if a value is contained in a set of values. The syntax is: WHERE column_name IN (value1, value2, ...); Set Operations (UNION, INTERSECT, EXCEPT) Set operations are used to combine the results of multiple queries. The UNION operator combines the results of two or more queries, removing duplicate rows. The INTERSECT operator combines the results of two or more queries, keeping only the rows that are common to all queries. The EXCEPT operator combines the results of two or more queries, keeping only the rows that are not common to all queries. The syntax is: SELECT column_list FROM query1 [UNION/INTERSECT/EXCEPT] SELECT column_list FROM query2; Aggregation Functions (AVG, MIN, MAX, COUNT, SUM) Aggregation functions are used to perform calculations on groups of rows. The most common aggregation functions are: AVG(): Average MIN(): Minimum MAX(): Maximum COUNT(): Count SUM(): Sum The syntax is: SELECT aggregate_function(column_name) FROM table_name GROUP BY group_by_column; Conclusion This summary has provided a comprehensive overview of the concepts covered in SQL Examples, a module in Database Management Systems. By understanding these concepts, you can effectively use SQL to retrieve, manipulate, and analyze data stored in relational databases.","title":"Lecture 3.1 - SQL Examples.pdf (PDF file)"},{"location":"week3/Lecture%203.1%20-%20SQL%20Examples/#lecture-31-sql-examplespdf-pdf-file","text":"Summary Introduction summary of the concepts covered in SQL Examples, a module in Database Management Systems. The focus is on providing a comprehensive overview of the material, including select statements, Cartesian products, the AS keyword, WHERE clauses with AND/OR operators, string operations, ORDER BY statements, the IN operator, set operations (UNION, INTERSECT, EXCEPT), and aggregation functions (AVG, MIN, MAX, COUNT, SUM). SELECT Statements The SELECT statement is used to retrieve data from one or more tables. The basic syntax is: SELECT column_list FROM table_name WHERE conditions; The column_list specifies the columns to be retrieved, table_name specifies the table(s) to be queried, and the WHERE clause specifies any conditions that must be met for the rows to be included in the result. Cartesian Products / AS Keyword A Cartesian product is a combination of all rows from one table with all rows from another table. The AS keyword is used to assign an alias to a column or table. The syntax for a Cartesian product is: SELECT column_list FROM table_name1, table_name2 [AS alias]; WHERE Clauses with AND/OR Operators The WHERE clause is used to specify conditions that must be met for rows to be included in the result. The AND operator is used to combine multiple conditions that must all be true, and the OR operator is used to combine multiple conditions that only one must be true. The syntax is: WHERE condition1 [AND/OR condition2]...; String Operations String operations can be used to compare strings and extract substrings. The most common string operators are: = and !=: Equality and inequality \\< and >: Less than and greater than LIKE: Pattern matching SUBSTRING(): Extracts a substring ORDER BY Statements The ORDER BY statement is used to sort the results of a query. The syntax is: ORDER BY column_name [ASC/DESC]; The ASC keyword specifies ascending order, and the DESC keyword specifies descending order. IN Operator The IN operator is used to check if a value is contained in a set of values. The syntax is: WHERE column_name IN (value1, value2, ...); Set Operations (UNION, INTERSECT, EXCEPT) Set operations are used to combine the results of multiple queries. The UNION operator combines the results of two or more queries, removing duplicate rows. The INTERSECT operator combines the results of two or more queries, keeping only the rows that are common to all queries. The EXCEPT operator combines the results of two or more queries, keeping only the rows that are not common to all queries. The syntax is: SELECT column_list FROM query1 [UNION/INTERSECT/EXCEPT] SELECT column_list FROM query2; Aggregation Functions (AVG, MIN, MAX, COUNT, SUM) Aggregation functions are used to perform calculations on groups of rows. The most common aggregation functions are: AVG(): Average MIN(): Minimum MAX(): Maximum COUNT(): Count SUM(): Sum The syntax is: SELECT aggregate_function(column_name) FROM table_name GROUP BY group_by_column; Conclusion This summary has provided a comprehensive overview of the concepts covered in SQL Examples, a module in Database Management Systems. By understanding these concepts, you can effectively use SQL to retrieve, manipulate, and analyze data stored in relational databases.","title":"Lecture 3.1 - SQL Examples.pdf (PDF file)"},{"location":"week3/Lecture%203.2%20-%20Intermediate%20SQL1/","text":"Lecture 3.2 - Intermediate SQL1 Summary Nested Subqueries In SQL, a subquery is a select-from-where expression that is nested within another query. SQL provides mechanisms for nesting subqueries in the following ways: As a condition in the WHERE clause As a table in the FROM clause As a value in the SELECT clause Subqueries in the WHERE Clause Subqueries in the WHERE clause are used to test conditions on the results of another query. For example, to find courses offered in both Fall 2009 and Spring 2010, you could use the following query: select distinct course_id from section where semester = 'Fall' and year = 2009 and course_id in ( select course_id from section where semester = 'Spring' and year = 2010 ); Subqueries in the WHERE clause can also be used to perform set membership, set comparisons, and test for empty relations. Subqueries in the FROM Clause Subqueries in the FROM clause are used to create temporary tables that can be used in the main query. For example, to find the average salary of instructors in each department, you could use the following query: select dept name , avg salary from ( select dept name , avg ( salary ) as avg salary from instructor group by dept name ) where avg salary > 42000 ; The subquery in the FROM clause is used to create a temporary table that contains the average salary for each department. This temporary table can then be used in the main query to find the departments with the highest average salaries. Subqueries in the SELECT Clause Subqueries in the SELECT clause are used to return a single value or a set of values as a column in the result set. For example, to list all departments along with the number of instructors in each department, you could use the following query: select dept name , ( select count ( * ) from instructor where department . dept name = instructor . dept name ) as num instructors from department ; The subquery in the SELECT clause is used to return the number of instructors in each department. This value is then included as a column in the result set. Modifications of the Database In addition to performing queries, SQL can also be used to modify the data in a database. The following are the three main types of database modifications: Deletion: Deleting tuples from a relation Insertion: Inserting new tuples into a relation Updating: Updating the values in some tuples in a relation For example, to delete all instructors whose salary is less than the average salary, you could use the following query: delete from instructor where salary < ( select avg ( salary ) from instructor ); Module Summary In this module, we have introduced nested subqueries in SQL and discussed how they can be used to perform complex queries and modify data in a database. Database Management Systems: Intermediate SQL/1 Outline Nested Subqueries Subqueries in the WHERE Clause Subqueries in the FROM Clause Subqueries in the SELECT Clause Modifications of the Database","title":"Lecture 3.2 - Intermediate SQL1"},{"location":"week3/Lecture%203.2%20-%20Intermediate%20SQL1/#lecture-32-intermediate-sql1","text":"Summary Nested Subqueries In SQL, a subquery is a select-from-where expression that is nested within another query. SQL provides mechanisms for nesting subqueries in the following ways: As a condition in the WHERE clause As a table in the FROM clause As a value in the SELECT clause Subqueries in the WHERE Clause Subqueries in the WHERE clause are used to test conditions on the results of another query. For example, to find courses offered in both Fall 2009 and Spring 2010, you could use the following query: select distinct course_id from section where semester = 'Fall' and year = 2009 and course_id in ( select course_id from section where semester = 'Spring' and year = 2010 ); Subqueries in the WHERE clause can also be used to perform set membership, set comparisons, and test for empty relations. Subqueries in the FROM Clause Subqueries in the FROM clause are used to create temporary tables that can be used in the main query. For example, to find the average salary of instructors in each department, you could use the following query: select dept name , avg salary from ( select dept name , avg ( salary ) as avg salary from instructor group by dept name ) where avg salary > 42000 ; The subquery in the FROM clause is used to create a temporary table that contains the average salary for each department. This temporary table can then be used in the main query to find the departments with the highest average salaries. Subqueries in the SELECT Clause Subqueries in the SELECT clause are used to return a single value or a set of values as a column in the result set. For example, to list all departments along with the number of instructors in each department, you could use the following query: select dept name , ( select count ( * ) from instructor where department . dept name = instructor . dept name ) as num instructors from department ; The subquery in the SELECT clause is used to return the number of instructors in each department. This value is then included as a column in the result set. Modifications of the Database In addition to performing queries, SQL can also be used to modify the data in a database. The following are the three main types of database modifications: Deletion: Deleting tuples from a relation Insertion: Inserting new tuples into a relation Updating: Updating the values in some tuples in a relation For example, to delete all instructors whose salary is less than the average salary, you could use the following query: delete from instructor where salary < ( select avg ( salary ) from instructor ); Module Summary In this module, we have introduced nested subqueries in SQL and discussed how they can be used to perform complex queries and modify data in a database. Database Management Systems: Intermediate SQL/1 Outline Nested Subqueries Subqueries in the WHERE Clause Subqueries in the FROM Clause Subqueries in the SELECT Clause Modifications of the Database","title":"Lecture 3.2 - Intermediate SQL1"},{"location":"week3/Lecture%203.4%20-%20Intermediate%20SQL3/","text":"Lecture 3.4- Intermediate SQL3 Transactions Definition and Properties A transaction is a unit of work in a database that must be either fully completed or fully rolled back. Transactions ensure atomicity , meaning they are indivisible and irreducible. If a transaction is partially completed and an error occurs, it must be rolled back entirely as if it never happened. Transactions must also maintain isolation from other transactions to prevent concurrency issues. Implementation in SQL Transactions begin implicitly and are ended by either a commit or rollback command. In most databases, each SQL statement commits automatically by default. However, auto-commit can be turned off for a session using APIs or specific SQL commands. SQL:1999 introduced the begin atomic ... end syntax to explicitly define transactions, although this is not widely supported. Integrity Constraints Purpose and Types Integrity constraints are rules applied to database columns to ensure data accuracy and consistency. Common types of constraints include: NOT NULL : Ensures that a column cannot have a NULL value. PRIMARY KEY : A unique identifier for a row, which cannot be NULL. UNIQUE : Ensures all values in a column or a set of columns are unique. CHECK : Ensures that the value in a column meets a specific condition. Examples and Usage Example of a NOT NULL constraint: name VARCHAR(20) NOT NULL . Example of a UNIQUE constraint: UNIQUE (A1, A2, ..., Am) where A1, A2, ..., Am form a candidate key. Example of a CHECK constraint to restrict semester values: CREATE TABLE section ( course_id VARCHAR ( 8 ), sec_id VARCHAR ( 8 ), semester VARCHAR ( 6 ), year NUMERIC ( 4 , 0 ), building VARCHAR ( 15 ), room_number VARCHAR ( 7 ), time_slot_id VARCHAR ( 4 ), PRIMARY KEY ( course_id , sec_id , semester , year ), CHECK ( semester IN ( 'Fall' , 'Winter' , 'Spring' , 'Summer' )) ); Referential Integrity Definition and Enforcement Referential integrity ensures that a foreign key value in one table must match a primary key value in another table, maintaining consistency between related tables. Example: If \"Biology\" is a department name in the instructor table, it must exist in the department table. Cascading Actions Cascading actions define the behavior of the database when a user attempts to delete or update a key referenced by foreign keys. Example of cascading actions: CREATE TABLE course ( course_id CHAR(5) PRIMARY KEY, title VARCHAR(20), dept_name VARCHAR(20), FOREIGN KEY (dept_name) REFERENCES department ON DELETE CASCADE ON UPDATE CASCADE ); Alternative actions include NO ACTION , SET NULL , and SET DEFAULT . SQL Data Types and Schemas Built-in Data Types SQL provides several built-in data types: DATE : Stores dates. TIME : Stores time of day. TIMESTAMP : Combines date and time. INTERVAL : Represents a period of time. Examples: DATE '2005-07-27' TIME '09:00:30' TIMESTAMP '2005-07-27 09:00:30.75' INTERVAL '1' DAY Index Creation Alias or User defined Data Type Domains BLOB and Clob Authorization Privileges and Roles SQL includes mechanisms to control user access to data and operations. Privileges can be granted to users to allow specific actions, such as SELECT , INSERT , UPDATE , and DELETE . Example of granting select privilege on a view: CREATE VIEW geo_instructor AS SELECT * FROM instructor WHERE dept_name = 'Geology' ; GRANT SELECT ON geo_instructor TO geo_staff ; References privilege is necessary to create foreign keys: GRANT REFERENCES ( dept_name ) ON department TO Mariano ; Transfer and Revocation of Privileges Privileges can be transferred from one user to another using the GRANT ... WITH GRANT OPTION . Privileges can be revoked using the REVOKE command: REVOKE SELECT ON department FROM Amit , Satoshi CASCADE ; Role Module Summary The lecture summarizes the following key points: Introduction to transactions, ensuring atomicity and isolation. Detailed exploration of integrity constraints to maintain data consistency. Referential integrity to enforce relationships between tables. Advanced SQL data types for handling various forms of data. Authorization mechanisms to manage user permissions and roles within the database. Overall, this lecture provides an in-depth look at intermediate SQL concepts essential for maintaining robust and secure databases.","title":"Lecture 3.4   Intermediate SQL3"},{"location":"week3/Lecture%203.4%20-%20Intermediate%20SQL3/#lecture-34-intermediate-sql3","text":"","title":"Lecture 3.4- Intermediate SQL3"},{"location":"week3/Lecture%203.4%20-%20Intermediate%20SQL3/#transactions","text":"Definition and Properties A transaction is a unit of work in a database that must be either fully completed or fully rolled back. Transactions ensure atomicity , meaning they are indivisible and irreducible. If a transaction is partially completed and an error occurs, it must be rolled back entirely as if it never happened. Transactions must also maintain isolation from other transactions to prevent concurrency issues. Implementation in SQL Transactions begin implicitly and are ended by either a commit or rollback command. In most databases, each SQL statement commits automatically by default. However, auto-commit can be turned off for a session using APIs or specific SQL commands. SQL:1999 introduced the begin atomic ... end syntax to explicitly define transactions, although this is not widely supported.","title":"Transactions"},{"location":"week3/Lecture%203.4%20-%20Intermediate%20SQL3/#integrity-constraints","text":"Purpose and Types Integrity constraints are rules applied to database columns to ensure data accuracy and consistency. Common types of constraints include: NOT NULL : Ensures that a column cannot have a NULL value. PRIMARY KEY : A unique identifier for a row, which cannot be NULL. UNIQUE : Ensures all values in a column or a set of columns are unique. CHECK : Ensures that the value in a column meets a specific condition. Examples and Usage Example of a NOT NULL constraint: name VARCHAR(20) NOT NULL . Example of a UNIQUE constraint: UNIQUE (A1, A2, ..., Am) where A1, A2, ..., Am form a candidate key. Example of a CHECK constraint to restrict semester values: CREATE TABLE section ( course_id VARCHAR ( 8 ), sec_id VARCHAR ( 8 ), semester VARCHAR ( 6 ), year NUMERIC ( 4 , 0 ), building VARCHAR ( 15 ), room_number VARCHAR ( 7 ), time_slot_id VARCHAR ( 4 ), PRIMARY KEY ( course_id , sec_id , semester , year ), CHECK ( semester IN ( 'Fall' , 'Winter' , 'Spring' , 'Summer' )) );","title":"Integrity Constraints"},{"location":"week3/Lecture%203.4%20-%20Intermediate%20SQL3/#referential-integrity","text":"Definition and Enforcement Referential integrity ensures that a foreign key value in one table must match a primary key value in another table, maintaining consistency between related tables. Example: If \"Biology\" is a department name in the instructor table, it must exist in the department table. Cascading Actions Cascading actions define the behavior of the database when a user attempts to delete or update a key referenced by foreign keys. Example of cascading actions: CREATE TABLE course ( course_id CHAR(5) PRIMARY KEY, title VARCHAR(20), dept_name VARCHAR(20), FOREIGN KEY (dept_name) REFERENCES department ON DELETE CASCADE ON UPDATE CASCADE ); Alternative actions include NO ACTION , SET NULL , and SET DEFAULT .","title":"Referential Integrity"},{"location":"week3/Lecture%203.4%20-%20Intermediate%20SQL3/#sql-data-types-and-schemas","text":"Built-in Data Types SQL provides several built-in data types: DATE : Stores dates. TIME : Stores time of day. TIMESTAMP : Combines date and time. INTERVAL : Represents a period of time. Examples: DATE '2005-07-27' TIME '09:00:30' TIMESTAMP '2005-07-27 09:00:30.75' INTERVAL '1' DAY","title":"SQL Data Types and Schemas"},{"location":"week3/Lecture%203.4%20-%20Intermediate%20SQL3/#index-creation","text":"","title":"Index Creation"},{"location":"week3/Lecture%203.4%20-%20Intermediate%20SQL3/#alias-or-user-defined-data-type","text":"","title":"Alias or User defined Data Type"},{"location":"week3/Lecture%203.4%20-%20Intermediate%20SQL3/#domains","text":"","title":"Domains"},{"location":"week3/Lecture%203.4%20-%20Intermediate%20SQL3/#blob-and-clob","text":"","title":"BLOB and Clob"},{"location":"week3/Lecture%203.4%20-%20Intermediate%20SQL3/#authorization","text":"Privileges and Roles SQL includes mechanisms to control user access to data and operations. Privileges can be granted to users to allow specific actions, such as SELECT , INSERT , UPDATE , and DELETE . Example of granting select privilege on a view: CREATE VIEW geo_instructor AS SELECT * FROM instructor WHERE dept_name = 'Geology' ; GRANT SELECT ON geo_instructor TO geo_staff ; References privilege is necessary to create foreign keys: GRANT REFERENCES ( dept_name ) ON department TO Mariano ; Transfer and Revocation of Privileges Privileges can be transferred from one user to another using the GRANT ... WITH GRANT OPTION . Privileges can be revoked using the REVOKE command: REVOKE SELECT ON department FROM Amit , Satoshi CASCADE ;","title":"Authorization"},{"location":"week3/Lecture%203.4%20-%20Intermediate%20SQL3/#role","text":"","title":"Role"},{"location":"week3/Lecture%203.4%20-%20Intermediate%20SQL3/#module-summary","text":"The lecture summarizes the following key points: Introduction to transactions, ensuring atomicity and isolation. Detailed exploration of integrity constraints to maintain data consistency. Referential integrity to enforce relationships between tables. Advanced SQL data types for handling various forms of data. Authorization mechanisms to manage user permissions and roles within the database. Overall, this lecture provides an in-depth look at intermediate SQL concepts essential for maintaining robust and secure databases.","title":"Module Summary"},{"location":"week3/Lecture%203.5%20-%20Advanced%20SQL/","text":"Lecture 3.5 - Advanced SQL Summary Functions and Procedural Constructs SQL:1999 added support for functions and procedures to SQL. These functions and procedures can be written in SQL itself or in an external programming language (such as C, Java, or Python). Functions written in an external language are particularly useful for working with specialized data types, such as images or geometric objects. SQL:1999 also supports a rich set of imperative constructs, including loops, if-then-else statements, and assignment. Many databases have proprietary procedural extensions to SQL that differ from SQL:1999. Functions Functions are used to perform calculations or retrieve data from the database. They can be defined using the CREATE FUNCTION statement. The following example creates a function that returns the count of the number of instructors in a given department: CREATE FUNCTION dept_count(dept_name VARCHAR(20)) RETURNS INTEGER BEGIN DECLARE d_count INTEGER; This function can then be used to find the department names and budgets of all departments with more than 12 instructors: SELECT dept_name, budget FROM department WHERE dept_count(dept_name) > 12; Procedures Procedures are used to perform a series of actions, such as updating multiple rows in a table or inserting a new row into a table. They can be defined using the CREATE PROCEDURE statement. The following example creates a procedure that updates the salary of an employee: CREATE PROCEDURE update_salary ( emp_id INT , new_salary NUMERIC ( 8 , 2 )) BEGIN UPDATE employee SET salary = new_salary WHERE emp_id = emp_id ; END ; This procedure can then be called to update the salary of an employee: CALL update_salary ( 1000 , 50000 ); Language Constructs SQL:1999 supports a rich set of imperative constructs, including loops, if-then-else statements, and assignment. These constructs can be used to create complex procedures and functions. The following table summarizes the most common language constructs: Construct Description BEGIN ... END Compound statement DECLARE Declare a local variable SET Assign a value to a local variable IF ... THEN ... ELSE Conditional statement WHILE Loop while a condition is true REPEAT Loop until a condition is true FOR Loop through a set of values CASE Conditional statement with multiple branches SIGNAL Signal an exception DECLARE HANDLER FOR Declare a handler for an exception External Language Routines SQL:1999 allows the definition of functions and procedures in an imperative programming language (such as C, Java, or Python) that can be invoked from SQL queries. Such functions can be more efficient than functions defined in SQL, and computations that cannot be carried out in SQL can be executed by these functions. To declare an external language function or procedure, use the CREATE FUNCTION or CREATE PROCEDURE statement and specify the language and the external name of the function or procedure. For example, the following statement creates a function that returns the count of the number of instructors in a given department: CREATE FUNCTION dept_count ( dept_name VARCHAR ( 20 )) RETURNS INTEGER LANGUAGE C EXTERNAL NAME '/usr/avi/bin/dept_count' ; Triggers Triggers are database objects that are used to automatically perform actions when certain events occur in the database. For example, a trigger can be used to automatically update a table when a row is inserted into another table. Triggers are defined using the CREATE TRIGGER statement. The following example creates a trigger that updates the total_credits column in the student table when a row is inserted into the takes table: CREATE TRIGGER update_total_credits AFTER INSERT ON takes FOR EACH ROW BEGIN UPDATE student SET total_credits = total_credits + ( SELECT credits FROM course WHERE course . course_id = NEW . course_id ) WHERE student . id = NEW . student_id ; END ; Functionality vs. Performance Triggers can be a powerful tool for automating database operations, but they can also have a negative impact on performance. The following are some factors that can affect the performance of triggers: The number of triggers: The more triggers that are defined on a table, the greater the impact on performance. The complexity of the triggers: Complex triggers that perform multiple operations can be more time-consuming to execute than simple triggers. The frequency of the triggering events: Triggers that are activated by frequent events can have a significant impact on performance. It is important to carefully consider the impact of triggers on performance before creating them. If a trigger is not necessary, it should not be created. If a trigger is necessary, it should be designed to be as efficient as possible. How to Use Triggers Triggers can be used for a variety of purposes, including: Maintaining data integrity: Triggers can be used to enforce business rules and ensure that data is consistent. Automating tasks: Triggers can be used to automate tasks that would otherwise need to be performed manually. Improving performance: Triggers can be used to improve performance by performing operations","title":"Lecture 3.5 - Advanced SQL"},{"location":"week3/Lecture%203.5%20-%20Advanced%20SQL/#lecture-35-advanced-sql","text":"Summary Functions and Procedural Constructs SQL:1999 added support for functions and procedures to SQL. These functions and procedures can be written in SQL itself or in an external programming language (such as C, Java, or Python). Functions written in an external language are particularly useful for working with specialized data types, such as images or geometric objects. SQL:1999 also supports a rich set of imperative constructs, including loops, if-then-else statements, and assignment. Many databases have proprietary procedural extensions to SQL that differ from SQL:1999. Functions Functions are used to perform calculations or retrieve data from the database. They can be defined using the CREATE FUNCTION statement. The following example creates a function that returns the count of the number of instructors in a given department: CREATE FUNCTION dept_count(dept_name VARCHAR(20)) RETURNS INTEGER BEGIN DECLARE d_count INTEGER; This function can then be used to find the department names and budgets of all departments with more than 12 instructors: SELECT dept_name, budget FROM department WHERE dept_count(dept_name) > 12; Procedures Procedures are used to perform a series of actions, such as updating multiple rows in a table or inserting a new row into a table. They can be defined using the CREATE PROCEDURE statement. The following example creates a procedure that updates the salary of an employee: CREATE PROCEDURE update_salary ( emp_id INT , new_salary NUMERIC ( 8 , 2 )) BEGIN UPDATE employee SET salary = new_salary WHERE emp_id = emp_id ; END ; This procedure can then be called to update the salary of an employee: CALL update_salary ( 1000 , 50000 ); Language Constructs SQL:1999 supports a rich set of imperative constructs, including loops, if-then-else statements, and assignment. These constructs can be used to create complex procedures and functions. The following table summarizes the most common language constructs: Construct Description BEGIN ... END Compound statement DECLARE Declare a local variable SET Assign a value to a local variable IF ... THEN ... ELSE Conditional statement WHILE Loop while a condition is true REPEAT Loop until a condition is true FOR Loop through a set of values CASE Conditional statement with multiple branches SIGNAL Signal an exception DECLARE HANDLER FOR Declare a handler for an exception External Language Routines SQL:1999 allows the definition of functions and procedures in an imperative programming language (such as C, Java, or Python) that can be invoked from SQL queries. Such functions can be more efficient than functions defined in SQL, and computations that cannot be carried out in SQL can be executed by these functions. To declare an external language function or procedure, use the CREATE FUNCTION or CREATE PROCEDURE statement and specify the language and the external name of the function or procedure. For example, the following statement creates a function that returns the count of the number of instructors in a given department: CREATE FUNCTION dept_count ( dept_name VARCHAR ( 20 )) RETURNS INTEGER LANGUAGE C EXTERNAL NAME '/usr/avi/bin/dept_count' ; Triggers Triggers are database objects that are used to automatically perform actions when certain events occur in the database. For example, a trigger can be used to automatically update a table when a row is inserted into another table. Triggers are defined using the CREATE TRIGGER statement. The following example creates a trigger that updates the total_credits column in the student table when a row is inserted into the takes table: CREATE TRIGGER update_total_credits AFTER INSERT ON takes FOR EACH ROW BEGIN UPDATE student SET total_credits = total_credits + ( SELECT credits FROM course WHERE course . course_id = NEW . course_id ) WHERE student . id = NEW . student_id ; END ; Functionality vs. Performance Triggers can be a powerful tool for automating database operations, but they can also have a negative impact on performance. The following are some factors that can affect the performance of triggers: The number of triggers: The more triggers that are defined on a table, the greater the impact on performance. The complexity of the triggers: Complex triggers that perform multiple operations can be more time-consuming to execute than simple triggers. The frequency of the triggering events: Triggers that are activated by frequent events can have a significant impact on performance. It is important to carefully consider the impact of triggers on performance before creating them. If a trigger is not necessary, it should not be created. If a trigger is necessary, it should be designed to be as efficient as possible. How to Use Triggers Triggers can be used for a variety of purposes, including: Maintaining data integrity: Triggers can be used to enforce business rules and ensure that data is consistent. Automating tasks: Triggers can be used to automate tasks that would otherwise need to be performed manually. Improving performance: Triggers can be used to improve performance by performing operations","title":"Lecture 3.5 - Advanced SQL"},{"location":"week3/livesession/","text":"The key differences between the VARCHAR(5) and CHAR(5) data types in SQL are: Length : VARCHAR(5) can store variable-length strings up to 5 characters. CHAR(5) stores fixed-length strings of exactly 5 characters. Storage Space : VARCHAR(5) only uses the exact number of bytes required to store the data, plus 1-2 bytes of overhead. CHAR(5) always uses 5 bytes of storage, regardless of the actual string length. Padding : If a VARCHAR(5) column is assigned a string shorter than 5 characters, no padding occurs. If a CHAR(5) column is assigned a string shorter than 5 characters, it is right-padded with spaces to reach the full 5 character length. Performance : Queries on CHAR columns are generally faster than on VARCHAR columns, as the fixed length allows more efficient indexing and storage. However, the space efficiency of VARCHAR can outweigh the performance difference in many cases. The key requirements for a foreign key are:1. The data types of the foreign key column(s) and the referenced column(s) must be compatible. The referenced column(s) must have a unique index, either as a primary key or a unique constraint. This means that the foreign key can reference:* A primary key column A column with a unique constraint Multiple columns with a composite unique constraint The LIKE operator in SQL is used to search for specific patterns in a column. It is often used with the WHERE clause to filter data based on a specified pattern. There are two wildcards commonly used with the LIKE operator: Percent Sign ( % ) : Represents zero, one, or multiple characters. Used to match strings that start with a specific pattern and can contain any characters after that. Underscore ( _ ) : Represents one, single character. Used to match strings that start with a specific pattern and have a single character after that. Examples Matching Strings That Start with a Specific Pattern : SELECT * FROM Customers WHERE CustomerName LIKE 'a%' ; This query will return all customers whose names start with the letter \"a\". 2. Matching Strings That Contain a Specific Pattern : SELECT * FROM Customers WHERE CustomerName LIKE '%L%' ; This query will return all customers whose names contain the letter \"L\" anywhere. 3. Matching Strings That End with a Specific Pattern : SELECT * FROM Customers WHERE CustomerName LIKE '%ia' ; This query will return all customers whose names end with the string \"ia\". 4. Matching Strings That Start with a Specific Pattern and Contain a Specific Character : SELECT * FROM Customers WHERE CustomerName LIKE 'U_' ; This query will return all customers whose names start with the letter \"U\" and have a single character after that. Using NOT LIKE The NOT LIKE operator is used to negate the results of a LIKE query. It returns all records that do not match the specified pattern. Example SELECT * FROM Customers WHERE CustomerName NOT LIKE 'USA' ; This query will return all customers whose names do not contain the string \"USA\". Using LIKE with Multiple Values The LIKE operator can be used with multiple string patterns by combining it with the OR operator. Example SELECT * FROM Customers WHERE last_name LIKE 'R%t' OR last_name LIKE '%e' ; The \"in\" and \"not in\" operators in Python and SQL are used to check if a specified value is present or absent in a sequence or a table. Here are the key points about these operators: Python \"in\" and \"not in\" Operators \"in\" Operator: The \"in\" operator checks if a specified value is present in a sequence (like a list, tuple, or string). It returns True if the value is found and False if it is not[1]. SQL \"in\" and \"not in\" Operators \"in\" Operator: The \"in\" operator is used with the SELECT , UPDATE , and DELETE statements to filter records based on a condition. It selects records where the specified column's value is present in a list of values[2][3][4]. \"not in\" Operator: The \"not in\" operator is used to filter out records where the specified column's value is not present in a list of values. It is often used with the SELECT , UPDATE , and DELETE statements to exclude specific records[2][3][4]. Key Points Both \"in\" and \"not in\" operators can be used in SQL with the WHERE clause to filter data. The \"in\" operator returns True if the value is found and False if it is not. The \"not in\" operator returns True if the value is not found and False if it is found. The \"in\" operator can be used with both numeric and non-numeric data types, such as strings. The \"not in\" operator can be used with both numeric and non-numeric data types, such as strings. The \"in\" operator can be used in combination with other operators like AND and OR . The \"not in\" operator can be used in combination with other operators like AND and OR . Examples Python: list1 = [ 1 , 2 , 3 , 4 , 5 ] string1 = \"My name is AskPython\" tuple1 = ( 11 , 22 , 33 , 44 ) print ( 5 in list1 ) # True print ( \"is\" in string1 ) # True print ( 88 in tuple1 ) # False print ( 5 not in list1 ) # False print ( \"is\" not in string1 ) # False print ( 88 not in tuple1 ) # True - SQL: SELECT Student_ID , Student_name , City , Age FROM student WHERE Age IN ( 25 , 29 ) AND City NOT IN ( 'Chennai' , 'Delhi' ); SELECT Name FROM Emp WHERE age NOT IN ( 23 , 22 , 21 ); SELECT * FROM Emp WHERE country NOT IN ( 'Australia' , 'Austria' ); SQL joins are used to combine rows from two or more tables based on a related column between them. This allows you to retrieve data from multiple tables by establishing logical relationships between them. Here are the different types of SQL joins: INNER JOIN An INNER JOIN returns all records from both tables where the join condition is satisfied. It is the most commonly used type of join and assumes that there is a match between the tables. Syntax: SELECT table1 . column1 , table1 . column2 , table2 . column1 , ... FROM table1 INNER JOIN table2 ON table1 . matching_column = table2 . matching_column ; Example: SELECT StudentCourse . COURSE_ID , Student . NAME , Student . AGE FROM Student INNER JOIN StudentCourse ON Student . ROLL_NO = StudentCourse . ROLL_NO ; LEFT JOIN A LEFT JOIN returns all records from the left table and the matched records from the right table. If there is no match, the result-set will contain null values for the right table. Syntax: SELECT table1 . column1 , table1 . column2 , table2 . column1 , ... FROM table1 LEFT JOIN table2 ON table1 . matching_column = table2 . matching_column ; Example: SELECT Student . NAME , StudentCourse . COURSE_ID FROM Student LEFT JOIN StudentCourse ON StudentCourse . ROLL_NO = Student . ROLL_NO ; RIGHT JOIN A RIGHT JOIN returns all records from the right table and the matched records from the left table. If there is no match, the result-set will contain null values for the left table. Syntax: SELECT table1 . column1 , table1 . column2 , table2 . column1 , ... FROM table1 RIGHT JOIN table2 ON table1 . matching_column = table2 . matching_column ; Example: SELECT StudentCourse . COURSE_ID , Student . NAME FROM StudentCourse RIGHT JOIN Student ON StudentCourse . ROLL_NO = Student . ROLL_NO ; FULL JOIN A FULL JOIN returns all records when there is a match in either the left or right table. Syntax: SELECT table1 . column1 , table1 . column2 , table2 . column1 , ... FROM table1 FULL JOIN table2 ON table1 . matching_column = table2 . matching_column ; Example: SELECT Student . NAME , StudentCourse . COURSE_ID FROM Student FULL JOIN StudentCourse ON StudentCourse . ROLL_NO = Student . ROLL_NO ; CROSS JOIN A CROSS JOIN returns all possible combinations of rows from both tables. Syntax: SELECT table1 . column1 , table1 . column2 , table2 . column1 , ... FROM table1 CROSS JOIN table2 ; Example: SELECT Student . NAME , StudentCourse . COURSE_ID FROM Student CROSS JOIN StudentCourse ; SELF JOIN A SELF JOIN is used to join a table to itself. This is useful for comparing rows within the same table. Syntax: SELECT table1 . column1 , table1 . column2 , table2 . column1 , ... FROM table1 AS table1_alias JOIN table1 AS table2_alias ON table1_alias . matching_column = table2_alias . matching_column ; Example: SELECT Student . NAME , StudentCourse . COURSE_ID FROM Student AS s JOIN Student AS sc ON s . ROLL_NO = sc . ROLL_NO ; NATURAL JOIN A NATURAL JOIN is similar to an INNER JOIN but automatically matches columns with the same names. Syntax: SELECT table1 . column1 , table1 . column2 , table2 . column1 , ... FROM table1 NATURAL JOIN table2 ; Example: SELECT Student . NAME , StudentCourse . COURSE_ID FROM Student NATURAL JOIN StudentCourse ;","title":"Livesession"},{"location":"week3/livesession/#examples","text":"Matching Strings That Start with a Specific Pattern : SELECT * FROM Customers WHERE CustomerName LIKE 'a%' ; This query will return all customers whose names start with the letter \"a\". 2. Matching Strings That Contain a Specific Pattern : SELECT * FROM Customers WHERE CustomerName LIKE '%L%' ; This query will return all customers whose names contain the letter \"L\" anywhere. 3. Matching Strings That End with a Specific Pattern : SELECT * FROM Customers WHERE CustomerName LIKE '%ia' ; This query will return all customers whose names end with the string \"ia\". 4. Matching Strings That Start with a Specific Pattern and Contain a Specific Character : SELECT * FROM Customers WHERE CustomerName LIKE 'U_' ; This query will return all customers whose names start with the letter \"U\" and have a single character after that.","title":"Examples"},{"location":"week3/livesession/#using-not-like","text":"The NOT LIKE operator is used to negate the results of a LIKE query. It returns all records that do not match the specified pattern.","title":"Using NOT LIKE"},{"location":"week3/livesession/#example","text":"SELECT * FROM Customers WHERE CustomerName NOT LIKE 'USA' ; This query will return all customers whose names do not contain the string \"USA\".","title":"Example"},{"location":"week3/livesession/#using-like-with-multiple-values","text":"The LIKE operator can be used with multiple string patterns by combining it with the OR operator.","title":"Using LIKE with Multiple Values"},{"location":"week3/livesession/#example_1","text":"SELECT * FROM Customers WHERE last_name LIKE 'R%t' OR last_name LIKE '%e' ; The \"in\" and \"not in\" operators in Python and SQL are used to check if a specified value is present or absent in a sequence or a table. Here are the key points about these operators:","title":"Example"},{"location":"week3/livesession/#python-in-and-not-in-operators","text":"\"in\" Operator: The \"in\" operator checks if a specified value is present in a sequence (like a list, tuple, or string). It returns True if the value is found and False if it is not[1].","title":"Python \"in\" and \"not in\" Operators"},{"location":"week3/livesession/#sql-in-and-not-in-operators","text":"\"in\" Operator: The \"in\" operator is used with the SELECT , UPDATE , and DELETE statements to filter records based on a condition. It selects records where the specified column's value is present in a list of values[2][3][4]. \"not in\" Operator: The \"not in\" operator is used to filter out records where the specified column's value is not present in a list of values. It is often used with the SELECT , UPDATE , and DELETE statements to exclude specific records[2][3][4].","title":"SQL \"in\" and \"not in\" Operators"},{"location":"week3/livesession/#key-points","text":"Both \"in\" and \"not in\" operators can be used in SQL with the WHERE clause to filter data. The \"in\" operator returns True if the value is found and False if it is not. The \"not in\" operator returns True if the value is not found and False if it is found. The \"in\" operator can be used with both numeric and non-numeric data types, such as strings. The \"not in\" operator can be used with both numeric and non-numeric data types, such as strings. The \"in\" operator can be used in combination with other operators like AND and OR . The \"not in\" operator can be used in combination with other operators like AND and OR .","title":"Key Points"},{"location":"week3/livesession/#examples_1","text":"Python: list1 = [ 1 , 2 , 3 , 4 , 5 ] string1 = \"My name is AskPython\" tuple1 = ( 11 , 22 , 33 , 44 ) print ( 5 in list1 ) # True print ( \"is\" in string1 ) # True print ( 88 in tuple1 ) # False print ( 5 not in list1 ) # False print ( \"is\" not in string1 ) # False print ( 88 not in tuple1 ) # True - SQL: SELECT Student_ID , Student_name , City , Age FROM student WHERE Age IN ( 25 , 29 ) AND City NOT IN ( 'Chennai' , 'Delhi' ); SELECT Name FROM Emp WHERE age NOT IN ( 23 , 22 , 21 ); SELECT * FROM Emp WHERE country NOT IN ( 'Australia' , 'Austria' ); SQL joins are used to combine rows from two or more tables based on a related column between them. This allows you to retrieve data from multiple tables by establishing logical relationships between them. Here are the different types of SQL joins:","title":"Examples"},{"location":"week3/livesession/#inner-join","text":"An INNER JOIN returns all records from both tables where the join condition is satisfied. It is the most commonly used type of join and assumes that there is a match between the tables.","title":"INNER JOIN"},{"location":"week3/livesession/#syntax","text":"SELECT table1 . column1 , table1 . column2 , table2 . column1 , ... FROM table1 INNER JOIN table2 ON table1 . matching_column = table2 . matching_column ;","title":"Syntax:"},{"location":"week3/livesession/#example_2","text":"SELECT StudentCourse . COURSE_ID , Student . NAME , Student . AGE FROM Student INNER JOIN StudentCourse ON Student . ROLL_NO = StudentCourse . ROLL_NO ;","title":"Example:"},{"location":"week3/livesession/#left-join","text":"A LEFT JOIN returns all records from the left table and the matched records from the right table. If there is no match, the result-set will contain null values for the right table.","title":"LEFT JOIN"},{"location":"week3/livesession/#syntax_1","text":"SELECT table1 . column1 , table1 . column2 , table2 . column1 , ... FROM table1 LEFT JOIN table2 ON table1 . matching_column = table2 . matching_column ;","title":"Syntax:"},{"location":"week3/livesession/#example_3","text":"SELECT Student . NAME , StudentCourse . COURSE_ID FROM Student LEFT JOIN StudentCourse ON StudentCourse . ROLL_NO = Student . ROLL_NO ;","title":"Example:"},{"location":"week3/livesession/#right-join","text":"A RIGHT JOIN returns all records from the right table and the matched records from the left table. If there is no match, the result-set will contain null values for the left table.","title":"RIGHT JOIN"},{"location":"week3/livesession/#syntax_2","text":"SELECT table1 . column1 , table1 . column2 , table2 . column1 , ... FROM table1 RIGHT JOIN table2 ON table1 . matching_column = table2 . matching_column ;","title":"Syntax:"},{"location":"week3/livesession/#example_4","text":"SELECT StudentCourse . COURSE_ID , Student . NAME FROM StudentCourse RIGHT JOIN Student ON StudentCourse . ROLL_NO = Student . ROLL_NO ;","title":"Example:"},{"location":"week3/livesession/#full-join","text":"A FULL JOIN returns all records when there is a match in either the left or right table.","title":"FULL JOIN"},{"location":"week3/livesession/#syntax_3","text":"SELECT table1 . column1 , table1 . column2 , table2 . column1 , ... FROM table1 FULL JOIN table2 ON table1 . matching_column = table2 . matching_column ;","title":"Syntax:"},{"location":"week3/livesession/#example_5","text":"SELECT Student . NAME , StudentCourse . COURSE_ID FROM Student FULL JOIN StudentCourse ON StudentCourse . ROLL_NO = Student . ROLL_NO ;","title":"Example:"},{"location":"week3/livesession/#cross-join","text":"A CROSS JOIN returns all possible combinations of rows from both tables.","title":"CROSS JOIN"},{"location":"week3/livesession/#syntax_4","text":"SELECT table1 . column1 , table1 . column2 , table2 . column1 , ... FROM table1 CROSS JOIN table2 ;","title":"Syntax:"},{"location":"week3/livesession/#example_6","text":"SELECT Student . NAME , StudentCourse . COURSE_ID FROM Student CROSS JOIN StudentCourse ;","title":"Example:"},{"location":"week3/livesession/#self-join","text":"A SELF JOIN is used to join a table to itself. This is useful for comparing rows within the same table.","title":"SELF JOIN"},{"location":"week3/livesession/#syntax_5","text":"SELECT table1 . column1 , table1 . column2 , table2 . column1 , ... FROM table1 AS table1_alias JOIN table1 AS table2_alias ON table1_alias . matching_column = table2_alias . matching_column ;","title":"Syntax:"},{"location":"week3/livesession/#example_7","text":"SELECT Student . NAME , StudentCourse . COURSE_ID FROM Student AS s JOIN Student AS sc ON s . ROLL_NO = sc . ROLL_NO ;","title":"Example:"},{"location":"week3/livesession/#natural-join","text":"A NATURAL JOIN is similar to an INNER JOIN but automatically matches columns with the same names.","title":"NATURAL JOIN"},{"location":"week3/livesession/#syntax_6","text":"SELECT table1 . column1 , table1 . column2 , table2 . column1 , ... FROM table1 NATURAL JOIN table2 ;","title":"Syntax:"},{"location":"week3/livesession/#example_8","text":"SELECT Student . NAME , StudentCourse . COURSE_ID FROM Student NATURAL JOIN StudentCourse ;","title":"Example:"},{"location":"week3/image/Lecture%203.3%20-%20Intermediate%20SQL2/","text":"Lecture 3.3 - Intermediate SQL2.pdf (PDF file) Summary Module 13: Intermediate SQL/2 Objectives To learn SQL expressions for Join To learn SQL expressions for Views Outline Join Expressions Views Join Expressions Definition: Join operations take two relations and return as a result another relation. Purpose: Join operations are used to combine rows from two relations based on a specified condition. Types of Join between Relations Cross join: Returns the Cartesian product of rows from tables in the join. Inner join: Returns rows that match on the specified condition. Outer join: Returns all rows from one relation and rows from the other relation that match on the specified condition. Left outer join: Returns all rows from the left relation and rows from the right relation that match on the specified condition. Right outer join: Returns all rows from the right relation and rows from the left relation that match on the specified condition. Full outer join: Returns all rows from both relations, regardless of whether they match on the specified condition. Cross JOIN Cross join: Returns the Cartesian product of rows from tables in the join. select * from employee cross join department; is same select * from employee , department; INNER JOIN Inner join is the intersection of the two table if we add natural then the result will ignore the the common attribute in the second table Outer Join Left Outer join Right outer Join Natural Full outer Join Views Definition: A view is a virtual relation that is defined by a query expression. Purpose: Views provide a mechanism to hide certain data from users or to create a new relation that is derived from existing relations. View Definition A view is defined using the create view statement, which has the form: create view v as < query expression > The view name is represented by v . The query expression specifies the rows and columns that are included in the view. View Expansion Definition: View expansion is the process of replacing a view reference in a query or another view with the query expression that defines the view. Purpose: View expansion is used to ensure that queries that use views always return the correct results, even if the underlying relations change. Update of a View Updates to views are typically not allowed. In some cases, updates to simple views (views that meet certain criteria) may be allowed. Materialized Views Definition: A materialized view is a physical table that contains the results of a query. Purpose: Materialized views can improve query performance by avoiding the need to re-execute the query every time it is used. Module Summary Join expressions are used to combine rows from two relations based on a specified condition. Views provide a mechanism to hide certain data from users or to create a new relation that is derived from existing relations. View expansion ensures that queries that use views always return the correct results, even if the underlying relations change. Updates to views are typically not allowed, but may be allowed in some cases for simple views. Materialized views can improve query performance by avoiding the need to re-execute the query every time it is used.","title":"Lecture 3.3 - Intermediate SQL2.pdf (PDF file)"},{"location":"week3/image/Lecture%203.3%20-%20Intermediate%20SQL2/#lecture-33-intermediate-sql2pdf-pdf-file","text":"Summary Module 13: Intermediate SQL/2 Objectives To learn SQL expressions for Join To learn SQL expressions for Views Outline Join Expressions Views Join Expressions Definition: Join operations take two relations and return as a result another relation. Purpose: Join operations are used to combine rows from two relations based on a specified condition. Types of Join between Relations Cross join: Returns the Cartesian product of rows from tables in the join. Inner join: Returns rows that match on the specified condition. Outer join: Returns all rows from one relation and rows from the other relation that match on the specified condition. Left outer join: Returns all rows from the left relation and rows from the right relation that match on the specified condition. Right outer join: Returns all rows from the right relation and rows from the left relation that match on the specified condition. Full outer join: Returns all rows from both relations, regardless of whether they match on the specified condition.","title":"Lecture 3.3 - Intermediate SQL2.pdf (PDF file)"},{"location":"week3/image/Lecture%203.3%20-%20Intermediate%20SQL2/#cross-join","text":"Cross join: Returns the Cartesian product of rows from tables in the join. select * from employee cross join department; is same select * from employee , department;","title":"Cross JOIN"},{"location":"week3/image/Lecture%203.3%20-%20Intermediate%20SQL2/#inner-join","text":"Inner join is the intersection of the two table if we add natural then the result will ignore the the common attribute in the second table","title":"INNER JOIN"},{"location":"week3/image/Lecture%203.3%20-%20Intermediate%20SQL2/#outer-join","text":"","title":"Outer Join"},{"location":"week3/image/Lecture%203.3%20-%20Intermediate%20SQL2/#left-outer-join","text":"","title":"Left Outer join"},{"location":"week3/image/Lecture%203.3%20-%20Intermediate%20SQL2/#right-outer-join","text":"","title":"Right outer Join"},{"location":"week3/image/Lecture%203.3%20-%20Intermediate%20SQL2/#natural-full-outer-join","text":"","title":"Natural Full outer Join"},{"location":"week3/image/Lecture%203.3%20-%20Intermediate%20SQL2/#views","text":"Definition: A view is a virtual relation that is defined by a query expression. Purpose: Views provide a mechanism to hide certain data from users or to create a new relation that is derived from existing relations. View Definition A view is defined using the create view statement, which has the form: create view v as < query expression > The view name is represented by v . The query expression specifies the rows and columns that are included in the view. View Expansion Definition: View expansion is the process of replacing a view reference in a query or another view with the query expression that defines the view. Purpose: View expansion is used to ensure that queries that use views always return the correct results, even if the underlying relations change. Update of a View Updates to views are typically not allowed. In some cases, updates to simple views (views that meet certain criteria) may be allowed. Materialized Views Definition: A materialized view is a physical table that contains the results of a query. Purpose: Materialized views can improve query performance by avoiding the need to re-execute the query every time it is used. Module Summary Join expressions are used to combine rows from two relations based on a specified condition. Views provide a mechanism to hide certain data from users or to create a new relation that is derived from existing relations. View expansion ensures that queries that use views always return the correct results, even if the underlying relations change. Updates to views are typically not allowed, but may be allowed in some cases for simple views. Materialized views can improve query performance by avoiding the need to re-execute the query every time it is used.","title":"Views"},{"location":"week4/Lecture%204.1%20-%20Formal%20Relational%20Query%20Languages1_annotated/","text":"Formal Relational Query Languages1_annotated Summary Module 16: Formal Relational Query Languages/1 Week Recap This lecture provides an overview of formal query languages in the context of database management systems, with a focus on relational algebra. Objectives Understand the concepts of formal query language and relational algebra. Outline Formal Relational Query Language Relational Algebra Select Project Union Difference Intersection Cartesian Product Rename Division Relational Algebra A procedural language used to manipulate relations (tables). Introduced by Edgar F. Codd in 1970. Consists of six basic operators: Select (\u03c3) Project (\u03a0) Union (\u222a) Set Difference (-) Cartesian Product (x) Rename (\u03c1) Select Operation (\u03c3) Selects tuples from a relation based on a predicate condition. Notation: \\(\u03c3_p(r)\\) , where p is the selection predicate. Example: \\(\u03c3_{dept_name='Physics'}(instructor)\\) Project Operation (\u03a0) Projects a relation onto a subset of its attributes. Notation: \\(\u03a0_{A1,A2,...,Ak}(r)\\) , where A1, A2,..., Ak are the selected attributes. Example: \\(\u03a0_{ID,name,salary}(instructor)\\) \" Union Operation (\u222a) Combines two relations with the same schema. Notation: \\(r \u222a s\\) Requires compatible arities (number of attributes) and attribute domains. Example: Find all courses taught in Fall 2009 or Spring 2010: \\(\u03a0_{course_id}(\u03c3_{semester='Fall'\u2227year=2009}(section)) \u222a \u03a0_{course_id}(\u03c3_{semester='Spring'\u2227year=2010}(section))\\) Difference Operation (-) Removes tuples from a relation that are also in another relation. Notation: r - s. Requires compatible relations (arities and attribute domains). Example: Find all courses taught in Fall 2009 but not in Spring 2010: \u03a0course_id(\u03c3semester='Fall'\u2227year=2009(section)) - \u03a0course_id(\u03c3semester='Spring'\u2227year=2010(section)) Intersection Operation (\u2229) Retains tuples that are common to both relations. Notation: \\(r \u2229 s\\) . Requires compatible relations (arities and attribute domains). Note: \\(r \u2229 s = r - (r - s)\\) Cartesian Product Operation (x) Produces all possible combinations of tuples from two relations. Notation: \\(\\mathbf{r} \\times \\mathbf{s}\\) Attributes of r and s must be disjoint (non-overlapping). If attributes are not disjoint, renaming must be used. Rename Operation (\u03c1) Allows for the naming of the results of relational algebra expressions. Allows for references to relations using different names. Notation: \\(\u03c1_{x}(E)\\) renames the expression E as X. Division Operation (\u00f7) Derived operation expressed in terms of other operations. Notation: r \u00f7 s \u2261 \u03a0R-S(r) - \u03a0R-S(r)((\u03a0R-S(r) x s) - \u03a0R-S,S(r)) Returns tuples from r that appear with every tuple in s. Module Summary Introduced the concept of formal relational query languages. Focused primarily on relational algebra and its six basic operators. Highlighted the practical applications of relational algebra operations.","title":"Formal Relational Query Languages1_annotated"},{"location":"week4/Lecture%204.1%20-%20Formal%20Relational%20Query%20Languages1_annotated/#formal-relational-query-languages1_annotated","text":"Summary Module 16: Formal Relational Query Languages/1 Week Recap This lecture provides an overview of formal query languages in the context of database management systems, with a focus on relational algebra. Objectives Understand the concepts of formal query language and relational algebra. Outline Formal Relational Query Language Relational Algebra Select Project Union Difference Intersection Cartesian Product Rename Division Relational Algebra A procedural language used to manipulate relations (tables). Introduced by Edgar F. Codd in 1970. Consists of six basic operators: Select (\u03c3) Project (\u03a0) Union (\u222a) Set Difference (-) Cartesian Product (x) Rename (\u03c1) Select Operation (\u03c3) Selects tuples from a relation based on a predicate condition. Notation: \\(\u03c3_p(r)\\) , where p is the selection predicate. Example: \\(\u03c3_{dept_name='Physics'}(instructor)\\) Project Operation (\u03a0) Projects a relation onto a subset of its attributes. Notation: \\(\u03a0_{A1,A2,...,Ak}(r)\\) , where A1, A2,..., Ak are the selected attributes. Example: \\(\u03a0_{ID,name,salary}(instructor)\\) \" Union Operation (\u222a) Combines two relations with the same schema. Notation: \\(r \u222a s\\) Requires compatible arities (number of attributes) and attribute domains. Example: Find all courses taught in Fall 2009 or Spring 2010: \\(\u03a0_{course_id}(\u03c3_{semester='Fall'\u2227year=2009}(section)) \u222a \u03a0_{course_id}(\u03c3_{semester='Spring'\u2227year=2010}(section))\\) Difference Operation (-) Removes tuples from a relation that are also in another relation. Notation: r - s. Requires compatible relations (arities and attribute domains). Example: Find all courses taught in Fall 2009 but not in Spring 2010: \u03a0course_id(\u03c3semester='Fall'\u2227year=2009(section)) - \u03a0course_id(\u03c3semester='Spring'\u2227year=2010(section)) Intersection Operation (\u2229) Retains tuples that are common to both relations. Notation: \\(r \u2229 s\\) . Requires compatible relations (arities and attribute domains). Note: \\(r \u2229 s = r - (r - s)\\) Cartesian Product Operation (x) Produces all possible combinations of tuples from two relations. Notation: \\(\\mathbf{r} \\times \\mathbf{s}\\) Attributes of r and s must be disjoint (non-overlapping). If attributes are not disjoint, renaming must be used. Rename Operation (\u03c1) Allows for the naming of the results of relational algebra expressions. Allows for references to relations using different names. Notation: \\(\u03c1_{x}(E)\\) renames the expression E as X. Division Operation (\u00f7) Derived operation expressed in terms of other operations. Notation: r \u00f7 s \u2261 \u03a0R-S(r) - \u03a0R-S(r)((\u03a0R-S(r) x s) - \u03a0R-S,S(r)) Returns tuples from r that appear with every tuple in s. Module Summary Introduced the concept of formal relational query languages. Focused primarily on relational algebra and its six basic operators. Highlighted the practical applications of relational algebra operations.","title":"Formal Relational Query Languages1_annotated"},{"location":"week4/Lecture%204.2%20-%20Formal%20Relational%20Query%20Languages2_annotated/","text":"Formal Relational Query Languages Summary Module 17: Formal Relational Query Languages/2 Objectives and Outline Objectives To understand formal calculus-based query language through relational algebra Outline Overview of Tuple Relational Calculus Overview of Domain Relational Calculus Equivalence of Algebra and Calculus Predicate Logic Predicate Logic is an extension of Propositional Logic or Boolean Algebra. It adds the concept of predicates and quantifiers to better capture the meaning of statements that cannot be adequately expressed by propositional logic. Tuple Relational Calculus and Domain Relational Calculus are based on Predicate Calculus. Predicate A predicate is a property that the subject of a statement can have. A statement involving n variables x1, x2, x3, \u00b7 \u00b7 \u00b7 , xn can be denoted by P(x1, x2, x3, \u00b7 \u00b7 \u00b7 , xn). Quantifiers Universal Quantifier: Asserts that a property is true for all the values of a variable in a particular domain. Existential Quantifier: Asserts that there is an element with a certain property. Tuple Relational Calculus A non-procedural query language, where each query is of the form: t = resulting tuples P(t) = predicate Domain Relational Calculus A non-procedural query language equivalent in power to the tuple relational calculus Each query is an expression of the form: x1, x2, . . . , xn represent domain variables P represents a formula similar to that of the predicate calculus Equivalence of Algebra and Calculus Relational Algebra, Tuple Relational Calculus, and Domain Relational Calculus are equivalent in expressive power. This equivalence means that any query that can be expressed in one language can also be expressed in the other two languages.","title":"Formal Relational Query Languages"},{"location":"week4/Lecture%204.2%20-%20Formal%20Relational%20Query%20Languages2_annotated/#formal-relational-query-languages","text":"Summary Module 17: Formal Relational Query Languages/2 Objectives and Outline Objectives To understand formal calculus-based query language through relational algebra Outline Overview of Tuple Relational Calculus Overview of Domain Relational Calculus Equivalence of Algebra and Calculus Predicate Logic Predicate Logic is an extension of Propositional Logic or Boolean Algebra. It adds the concept of predicates and quantifiers to better capture the meaning of statements that cannot be adequately expressed by propositional logic. Tuple Relational Calculus and Domain Relational Calculus are based on Predicate Calculus. Predicate A predicate is a property that the subject of a statement can have. A statement involving n variables x1, x2, x3, \u00b7 \u00b7 \u00b7 , xn can be denoted by P(x1, x2, x3, \u00b7 \u00b7 \u00b7 , xn). Quantifiers Universal Quantifier: Asserts that a property is true for all the values of a variable in a particular domain. Existential Quantifier: Asserts that there is an element with a certain property. Tuple Relational Calculus A non-procedural query language, where each query is of the form: t = resulting tuples P(t) = predicate Domain Relational Calculus A non-procedural query language equivalent in power to the tuple relational calculus Each query is an expression of the form: x1, x2, . . . , xn represent domain variables P represents a formula similar to that of the predicate calculus Equivalence of Algebra and Calculus Relational Algebra, Tuple Relational Calculus, and Domain Relational Calculus are equivalent in expressive power. This equivalence means that any query that can be expressed in one language can also be expressed in the other two languages.","title":"Formal Relational Query Languages"},{"location":"week4/Lecture%204.3%20-%20Entity-Relationship%20Model1_annotated/","text":"Entity-Relationship Model Summary Module 18: Entity-Relationship (ER) Model Introduction ER model is a data modeling technique used to represent the logical structure of a database. It provides a graphical representation of the entities, attributes, and relationships present in a database. Design Process Requirement analysis: Analyze data needs of users. Database design: Create an ER diagram and normalize the database. Implementation: Convert ER diagram to tables, load data, and test. ER Model Concepts 1. Attributes Properties associated with entities. Can be simple or composite, single-valued or multivalued, and derived . Each attribute has a domain , which is the set of possible values for that attribute. 2. Entity Sets Collections of entities that share the same properties and attributes. Each entity is uniquely identified by a primary key. 3. Relationships Associations between entities. Can be binary (between two entities) or ternary (between three entities). Cardinality defines the number of entities that can be associated with each other through a relationship. 4. Cardinality Specifies the mapping between entities in a relationship. Types of cardinality include one-to-one, one-to-many, many-to-one, and many-to-many. partial 5. Constraints Rules that restrict the data in a database. Can be used to enforce referential integrity, data types, and other requirements. 6. Weak Entity Sets Entity sets that do not have sufficient attributes to uniquely identify their entities. Must have a total participation in an identifying relationship with a strong entity set. Discrimator ER Diagram A graphical representation of an ER model. Uses rectangles to represent entities, ovals to represent attributes, and diamonds to represent relationships. Cardinality is indicated using lines and notation. Example ER Diagram Benefits of ER Modeling Facilitates database design by mapping real-world concepts to a logical structure. Helps identify and understand data relationships. Improves communication between stakeholders involved in database development. Conclusion The ER model is a fundamental concept in database management systems. It provides a structured and intuitive way to represent the data and relationships in a database. By understanding the principles of ER modeling, database designers can create efficient and effective database systems.","title":"Entity-Relationship Model"},{"location":"week4/Lecture%204.3%20-%20Entity-Relationship%20Model1_annotated/#entity-relationship-model","text":"Summary Module 18: Entity-Relationship (ER) Model Introduction ER model is a data modeling technique used to represent the logical structure of a database. It provides a graphical representation of the entities, attributes, and relationships present in a database. Design Process Requirement analysis: Analyze data needs of users. Database design: Create an ER diagram and normalize the database. Implementation: Convert ER diagram to tables, load data, and test. ER Model Concepts 1. Attributes Properties associated with entities. Can be simple or composite, single-valued or multivalued, and derived . Each attribute has a domain , which is the set of possible values for that attribute. 2. Entity Sets Collections of entities that share the same properties and attributes. Each entity is uniquely identified by a primary key. 3. Relationships Associations between entities. Can be binary (between two entities) or ternary (between three entities). Cardinality defines the number of entities that can be associated with each other through a relationship. 4. Cardinality Specifies the mapping between entities in a relationship. Types of cardinality include one-to-one, one-to-many, many-to-one, and many-to-many. partial 5. Constraints Rules that restrict the data in a database. Can be used to enforce referential integrity, data types, and other requirements. 6. Weak Entity Sets Entity sets that do not have sufficient attributes to uniquely identify their entities. Must have a total participation in an identifying relationship with a strong entity set. Discrimator ER Diagram A graphical representation of an ER model. Uses rectangles to represent entities, ovals to represent attributes, and diamonds to represent relationships. Cardinality is indicated using lines and notation. Example ER Diagram Benefits of ER Modeling Facilitates database design by mapping real-world concepts to a logical structure. Helps identify and understand data relationships. Improves communication between stakeholders involved in database development. Conclusion The ER model is a fundamental concept in database management systems. It provides a structured and intuitive way to represent the data and relationships in a database. By understanding the principles of ER modeling, database designers can create efficient and effective database systems.","title":"Entity-Relationship Model"},{"location":"week4/Lecture%204.4%20-%20Entity-Relationship%20Model2_annotated/","text":"Entity-Relationship (ER) Model/2 Overview An Entity-Relationship (ER) model is a graphical representation of a database schema. It uses entity sets, relationship sets, and attributes to describe the structure of a database. ER Diagram Notation Entity Sets: Represented as rectangles. Attributes are listed inside the rectangle. Primary key attributes are underlined. Relationship Sets: Represented as diamonds. _ _ _ means a attribute of the relationship Cardinality Constraints Express the number of entities in one set that can relate to a single entity in another set. Represented using directed lines (\u2192) for \"one\" and undirected lines (\u2014) for \"many.\" Examples: A student can have at most one advisor (one-to-one relationship). A course can have many students (one-to-many relationship). A student can take many courses (many-to-many relationship). Constraints Participation: Total: Every entity in an entity set participates in at least one relationship in the relationship set. Partial: Some entities may not participate in any relationship. * Bounds: Minimum and maximum number of relationships an entity can participate in. Represented using the notation l..h, where l is the minimum and h is the maximum. {} -> multivalue attribute () -> function Weak Entity set ER Model to Relational Schema Entity Sets: Each entity set becomes a table with columns for each attribute. Relationship Sets: Many-to-many relationships become separate tables with columns for the primary keys of the participating entities. One-to-many and many-to-one relationships can be represented by adding an extra attribute to the \"many\" side with the primary key of the \"one\" side. Complex Attributes Composite Attributes: Attributes that consist of multiple components. Components are flattened out into separate attributes in the relational schema. Multivalued Attributes: Attributes that can have multiple values for a single entity. Represented by a separate table with columns for the primary key of the entity and an attribute for each value of the multivalued attribute. Redundancy Schemas derived from relationship sets that are total on the \"many\" side may contain redundant data. This redundancy can be reduced by adding an extra attribute to the \"many\" side. Schemas for weak entity sets are redundant and can be eliminated. Module Summary Explored the use of ER diagrams to model database structures. Discussed the translation of ER models into relational schemas. Analyzed the various constraints and attributes used in ER models. Explained how to handle complex attributes and redundancy in relational schemas derived from ER models.","title":"Entity-Relationship (ER) Model/2"},{"location":"week4/Lecture%204.4%20-%20Entity-Relationship%20Model2_annotated/#entity-relationship-er-model2","text":"","title":"Entity-Relationship (ER) Model/2"},{"location":"week4/Lecture%204.4%20-%20Entity-Relationship%20Model2_annotated/#overview","text":"An Entity-Relationship (ER) model is a graphical representation of a database schema. It uses entity sets, relationship sets, and attributes to describe the structure of a database.","title":"Overview"},{"location":"week4/Lecture%204.4%20-%20Entity-Relationship%20Model2_annotated/#er-diagram-notation","text":"Entity Sets: Represented as rectangles. Attributes are listed inside the rectangle. Primary key attributes are underlined. Relationship Sets: Represented as diamonds. _ _ _ means a attribute of the relationship","title":"ER Diagram Notation"},{"location":"week4/Lecture%204.4%20-%20Entity-Relationship%20Model2_annotated/#cardinality-constraints","text":"Express the number of entities in one set that can relate to a single entity in another set. Represented using directed lines (\u2192) for \"one\" and undirected lines (\u2014) for \"many.\" Examples: A student can have at most one advisor (one-to-one relationship). A course can have many students (one-to-many relationship). A student can take many courses (many-to-many relationship).","title":"Cardinality Constraints"},{"location":"week4/Lecture%204.4%20-%20Entity-Relationship%20Model2_annotated/#constraints","text":"Participation: Total: Every entity in an entity set participates in at least one relationship in the relationship set. Partial: Some entities may not participate in any relationship. * Bounds: Minimum and maximum number of relationships an entity can participate in. Represented using the notation l..h, where l is the minimum and h is the maximum. {} -> multivalue attribute () -> function","title":"Constraints"},{"location":"week4/Lecture%204.4%20-%20Entity-Relationship%20Model2_annotated/#weak-entity-set","text":"","title":"Weak Entity set"},{"location":"week4/Lecture%204.4%20-%20Entity-Relationship%20Model2_annotated/#er-model-to-relational-schema","text":"Entity Sets: Each entity set becomes a table with columns for each attribute. Relationship Sets: Many-to-many relationships become separate tables with columns for the primary keys of the participating entities. One-to-many and many-to-one relationships can be represented by adding an extra attribute to the \"many\" side with the primary key of the \"one\" side.","title":"ER Model to Relational Schema"},{"location":"week4/Lecture%204.4%20-%20Entity-Relationship%20Model2_annotated/#complex-attributes","text":"Composite Attributes: Attributes that consist of multiple components. Components are flattened out into separate attributes in the relational schema. Multivalued Attributes: Attributes that can have multiple values for a single entity. Represented by a separate table with columns for the primary key of the entity and an attribute for each value of the multivalued attribute.","title":"Complex Attributes"},{"location":"week4/Lecture%204.4%20-%20Entity-Relationship%20Model2_annotated/#redundancy","text":"Schemas derived from relationship sets that are total on the \"many\" side may contain redundant data. This redundancy can be reduced by adding an extra attribute to the \"many\" side. Schemas for weak entity sets are redundant and can be eliminated.","title":"Redundancy"},{"location":"week4/Lecture%204.4%20-%20Entity-Relationship%20Model2_annotated/#module-summary","text":"Explored the use of ER diagrams to model database structures. Discussed the translation of ER models into relational schemas. Analyzed the various constraints and attributes used in ER models. Explained how to handle complex attributes and redundancy in relational schemas derived from ER models.","title":"Module Summary"},{"location":"week4/Lecture%204.5%20-%20Entity-Relationship%20Model3_annotated/","text":"Entity-Relationship Model Summary Entity-Relationship Model (ER Model): Extended Features and Design Issues Introduction The Entity-Relationship Model (ER Model) is a data modeling technique used to represent the structure and relationships of data in a database. ER Model provides a conceptual representation of data, making it easier to understand and manipulate. In this module, we will explore the extended features of the ER Model that enhance its representational capabilities and discuss various design issues involved in designing ER diagrams. Extended ER Features Non-Binary Relationships: Most ER relationships are binary, involving two entity sets. Non-binary relationships involve three or more entity sets. They can be represented with a ternary relationship construct, where three entity sets are connected by a diamond-shaped box. Specialization and Generalization: Specialization (ISA): Subdivide an entity set into smaller, more specific sub-entity sets (lower-level entity sets). Generalization: Combine multiple entity sets into a higher-level entity set that captures their common characteristics. Represented by a triangle component labeled ISA, indicating that a lower-level entity set inherits attributes and relationships from the higher-level entity set. Aggregation: Allows entities to have complex relationships by treating a relationship as an abstract entity. Associates attributes with the relationship itself, rather than with individual entities. Design Issues Entities vs. Attributes: Entities represent real-world objects or concepts. Attributes are characteristics of entities. Consider whether a real-world concept is best represented as an entity or an attribute. Entities vs. Relationship Sets: Entities represent objects, while relationship sets represent associations between objects. Use relationship sets to describe actions or interactions between entities. Binary vs. Non-Binary Relationships: Non-binary relationships represent complex associations involving multiple entities. Binary relationships are simpler and easier to implement. Consider whether a relationship is naturally binary or non-binary based on the underlying real-world scenario. Design Decisions: The use of an attribute or entity set to represent an object. Whether a real-world concept should be represented by an entity set or a relationship set. The use of ternary relationships versus pairs of binary relationships. The use of strong or weak entity sets. The use of specialization/generalization for modularity in design. The use of aggregation to treat complex relationships as single units. ER Notation Symbols Used in ER Notation: Symbol Meaning Rectangle Entity set Diamond Relationship set Line Connection between entity sets and relationship sets Ellipsis Weak entity set Double line Total specialization Dashed line Partial specialization Alternate Notations: Chen notation IDE1FX notation Crow's feet notation Module Summary In this module, we explored the extended features of the ER Model, including non-binary relationships, specialization/generalization, and aggregation. We also discussed various design issues that arise when creating ER diagrams and the symbols used in ER notation. Understanding these concepts and techniques is essential for effectively designing and implementing databases.","title":"Entity-Relationship Model"},{"location":"week4/Lecture%204.5%20-%20Entity-Relationship%20Model3_annotated/#entity-relationship-model","text":"Summary Entity-Relationship Model (ER Model): Extended Features and Design Issues Introduction The Entity-Relationship Model (ER Model) is a data modeling technique used to represent the structure and relationships of data in a database. ER Model provides a conceptual representation of data, making it easier to understand and manipulate. In this module, we will explore the extended features of the ER Model that enhance its representational capabilities and discuss various design issues involved in designing ER diagrams. Extended ER Features Non-Binary Relationships: Most ER relationships are binary, involving two entity sets. Non-binary relationships involve three or more entity sets. They can be represented with a ternary relationship construct, where three entity sets are connected by a diamond-shaped box. Specialization and Generalization: Specialization (ISA): Subdivide an entity set into smaller, more specific sub-entity sets (lower-level entity sets). Generalization: Combine multiple entity sets into a higher-level entity set that captures their common characteristics. Represented by a triangle component labeled ISA, indicating that a lower-level entity set inherits attributes and relationships from the higher-level entity set. Aggregation: Allows entities to have complex relationships by treating a relationship as an abstract entity. Associates attributes with the relationship itself, rather than with individual entities. Design Issues Entities vs. Attributes: Entities represent real-world objects or concepts. Attributes are characteristics of entities. Consider whether a real-world concept is best represented as an entity or an attribute. Entities vs. Relationship Sets: Entities represent objects, while relationship sets represent associations between objects. Use relationship sets to describe actions or interactions between entities. Binary vs. Non-Binary Relationships: Non-binary relationships represent complex associations involving multiple entities. Binary relationships are simpler and easier to implement. Consider whether a relationship is naturally binary or non-binary based on the underlying real-world scenario. Design Decisions: The use of an attribute or entity set to represent an object. Whether a real-world concept should be represented by an entity set or a relationship set. The use of ternary relationships versus pairs of binary relationships. The use of strong or weak entity sets. The use of specialization/generalization for modularity in design. The use of aggregation to treat complex relationships as single units. ER Notation Symbols Used in ER Notation: Symbol Meaning Rectangle Entity set Diamond Relationship set Line Connection between entity sets and relationship sets Ellipsis Weak entity set Double line Total specialization Dashed line Partial specialization Alternate Notations: Chen notation IDE1FX notation Crow's feet notation Module Summary In this module, we explored the extended features of the ER Model, including non-binary relationships, specialization/generalization, and aggregation. We also discussed various design issues that arise when creating ER diagrams and the symbols used in ER notation. Understanding these concepts and techniques is essential for effectively designing and implementing databases.","title":"Entity-Relationship Model"},{"location":"week4/er_model/","text":"description of the figures: Symbol/Shape Name Figure Description Description Rectangle Entity A rectangle with the entity name inside it. Represents an entity, which is a distinct object in the system with a unique identity. Ellipse Attribute An ellipse with the attribute name inside it. Represents an attribute, which is a property or characteristic of an entity. Double Ellipse Multivalued Attribute An ellipse with a double border and the attribute name inside it. Represents an attribute that can have multiple values for a single entity. Dashed Ellipse Derived Attribute An ellipse with a dashed border and the attribute name inside it. Represents an attribute whose value can be derived from other attributes. Diamond Relationship A diamond shape with the relationship name inside it. Represents a relationship, which is an association among two or more entities. Double Rectangle Weak Entity A rectangle with a double border and the entity name inside it. Represents a weak entity, which depends on another entity (its identifying owner) for its existence. Double Diamond Identifying Relationship A diamond shape with a double border and the relationship name inside it. Represents a relationship that links a weak entity to its identifying owner. Line Connector A simple line connecting shapes. Connects entities to relationships and attributes to entities or relationships. Double Line Total Participation A line connecting shapes with a double border. Indicates that every instance of the entity must participate in at least one instance of the relationship. Dashed Line Partial Participation A line with a dashed border connecting shapes. Indicates that not every instance of the entity must participate in the relationship. Primary Key (PK) Underlined Attribute An attribute name with an underline. Represents an attribute that uniquely identifies each entity instance. Foreign Key (FK) Dashed Underlined Attribute An attribute name with a dashed underline. Represents an attribute that is a primary key in another table, establishing a relationship between entities.","title":"Er model"},{"location":"week4/week4/","text":"[ ] lec class [ ] PPA [ ] GRPA [ ] GA [ ] instructor section 1 [ ] instructor section 2 [ ] TA session 1 [ ] TA session 2 [ ] Text book","title":"Week4"}]}